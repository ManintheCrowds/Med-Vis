"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/visualization/page",{

/***/ "(app-pages-browser)/./src/components/DataVisualization/ChordDiagram.tsx":
/*!***********************************************************!*\
  !*** ./src/components/DataVisualization/ChordDiagram.tsx ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ChordDiagram; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/useVisualizationData */ \"(app-pages-browser)/./src/components/DataVisualization/shared/useVisualizationData.ts\");\n/* harmony import */ var _shared_QuestionSelector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/QuestionSelector */ \"(app-pages-browser)/./src/components/DataVisualization/shared/QuestionSelector.tsx\");\n/* harmony import */ var _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shared/chordUtils */ \"(app-pages-browser)/./src/components/DataVisualization/shared/chordUtils.ts\");\n/* harmony import */ var _lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/context/AppContext */ \"(app-pages-browser)/./src/lib/context/AppContext.tsx\");\n/* harmony import */ var _components_shared_GlobalControlsNav__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/shared/GlobalControlsNav */ \"(app-pages-browser)/./src/components/shared/GlobalControlsNav.tsx\");\n/* harmony import */ var _shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shared/colorUtils */ \"(app-pages-browser)/./src/components/DataVisualization/shared/colorUtils.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n// Helper to get color for a node using global context (theme-aware)\nfunction getNodeColor(nodeName, category, globalColors) {\n    let isDarkMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    const themeColors = isDarkMode ? globalColors.dark : globalColors.light;\n    if (category === \"years_at_medtronic\") {\n        var _themeColors_years_at_medtronic;\n        return ((_themeColors_years_at_medtronic = themeColors.years_at_medtronic) === null || _themeColors_years_at_medtronic === void 0 ? void 0 : _themeColors_years_at_medtronic[nodeName]) || \"#FF6B6B\";\n    }\n    // Use global colors if available, otherwise fallback to defaults\n    if (category === \"learning_style\") {\n        var _themeColors_learning_style;\n        return ((_themeColors_learning_style = themeColors.learning_style) === null || _themeColors_learning_style === void 0 ? void 0 : _themeColors_learning_style[nodeName]) || \"#60a5fa\";\n    }\n    if (category === \"peak_performance\") {\n        var _themeColors_peak_performance;\n        return ((_themeColors_peak_performance = themeColors.peak_performance) === null || _themeColors_peak_performance === void 0 ? void 0 : _themeColors_peak_performance[nodeName]) || \"#4F8EF7\";\n    }\n    if (category === \"motivation\") {\n        var _themeColors_motivation;\n        return ((_themeColors_motivation = themeColors.motivation) === null || _themeColors_motivation === void 0 ? void 0 : _themeColors_motivation[nodeName]) || \"#9467bd\";\n    }\n    if (category === \"shaped_by\") {\n        var _themeColors_shaped_by;\n        return ((_themeColors_shaped_by = themeColors.shaped_by) === null || _themeColors_shaped_by === void 0 ? void 0 : _themeColors_shaped_by[nodeName]) || \"#1f77b4\";\n    }\n    return \"#8884d8\";\n}\n// --- TypeScript Types for Chord Diagram ---\n// (If you already import ChordGroup/ChordLink from shared/chordUtils, do not redefine here)\n// --- Simple Error Boundary for Robustness ---\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    static getDerivedStateFromError(_) {\n        return {\n            hasError: true\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        // Log error to monitoring service if needed\n        console.error(\"ChordDiagram ErrorBoundary:\", error, errorInfo);\n    }\n    render() {\n        if (this.state.hasError) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    color: \"red\",\n                    padding: 24\n                },\n                children: \"Something went wrong in the Chord Diagram.\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                lineNumber: 77,\n                columnNumber: 14\n            }, this);\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            hasError: false\n        };\n    }\n}\n// --- Main ChordDiagram wrapped in ErrorBoundary ---\nfunction ChordDiagramInternal(param) {\n    let { width = 1400, height = 1000, autoPlay = true, onRelationshipChange, enableRotation = true, showAllConnections = false } = param;\n    _s();\n    const svgRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const secondarySvgRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { data, isLoading, error } = (0,_shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_3__.useVisualizationData)();\n    const [currentSource, setCurrentSource] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[0].source);\n    const [currentTarget, setCurrentTarget] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[0].target);\n    const [insights, setInsights] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [tooltip, setTooltip] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const { settings } = (0,_lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__.useAppContext)();\n    const [lastCategoryChange, setLastCategoryChange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        source: currentSource,\n        target: currentTarget\n    });\n    const [showSecondaryChord, setShowSecondaryChord] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Animation state management (similar to AlluvialDiagram)\n    const [animationPhase, setAnimationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"full\");\n    const [highlightedArcIndex, setHighlightedArcIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [highlightedSide, setHighlightedSide] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isAnimating, setIsAnimating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Secondary chord animation state\n    const [secondaryAnimationPhase, setSecondaryAnimationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"full\");\n    const [secondaryHighlightedArcIndex, setSecondaryHighlightedArcIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [secondaryHighlightedSide, setSecondaryHighlightedSide] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Animation timing ref\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        timer: null,\n        running: false,\n        currentIndex: 0,\n        currentSide: \"left\",\n        isPaused: false,\n        cycleCount: 0\n    });\n    // Secondary chord animation timing ref\n    const secondaryAnimationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        timer: null,\n        running: false,\n        currentIndex: 0,\n        currentSide: \"left\",\n        isPaused: false\n    });\n    // Define available fields for the selector\n    const availableFields = [\n        {\n            value: \"years_at_medtronic\",\n            label: \"Years at Medtronic\"\n        },\n        {\n            value: \"peak_performance\",\n            label: \"Peak Performance\"\n        },\n        {\n            value: \"learning_style\",\n            label: \"Learning Style\"\n        },\n        {\n            value: \"motivation\",\n            label: \"Motivation\"\n        },\n        {\n            value: \"shaped_by\",\n            label: \"Shaped By\"\n        }\n    ];\n    // Typography constants (theme-aware)\n    const labelFontSize = 20;\n    const labelFontWeight = 700;\n    const labelColor = settings.isDarkMode ? \"#ffffff\" : \"#170F5F\";\n    const labelFontFamily = 'Avenir Next World, -apple-system, BlinkMacSystemFont, \"SF Pro\", \"Roboto\", sans-serif';\n    // Check if peak performance is involved and show secondary chord\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const isPeakPerformanceInvolved = currentSource === \"peak_performance\" || currentTarget === \"peak_performance\";\n        setShowSecondaryChord(isPeakPerformanceInvolved);\n    }, [\n        currentSource,\n        currentTarget\n    ]);\n    // Secondary chord diagram for peak performance breakdown\n    const renderSecondaryChord = ()=>{\n        if (!secondarySvgRef.current || !data.length || isLoading) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(secondarySvgRef.current);\n        svg.selectAll(\"*\").remove();\n        const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n        // Get all data for secondary chord (Years at Medtronic vs Peak Performance categories)\n        const secondaryData = filteredData.filter((d)=>d.peak_performance);\n        if (secondaryData.length < 5) return;\n        // Use same dimensions as main chord for consistency\n        const secondaryWidth = showSecondaryChord ? width * 0.45 : width;\n        const secondaryHeight = showSecondaryChord ? height * 0.8 : height * 0.85;\n        const secondaryMargin = {\n            top: 80,\n            right: 80,\n            bottom: 100,\n            left: 80\n        };\n        const secondaryChartWidth = secondaryWidth - secondaryMargin.left - secondaryMargin.right;\n        const secondaryChartHeight = secondaryHeight - secondaryMargin.top - secondaryMargin.bottom;\n        const secondaryRadius = Math.max(120, Math.min(secondaryChartWidth, secondaryChartHeight) / 2 - 60);\n        // Years categories and Peak Performance categories\n        const yearsCategories = [\n            \"0-5\",\n            \"6-10\",\n            \"11-15\",\n            \"16-20\",\n            \"20+\"\n        ];\n        const peakPerfCategories = Array.from(new Set(secondaryData.map((d)=>d.peak_performance))).filter(Boolean).sort();\n        // Create bipartite matrix: Years vs Peak Performance\n        const allCategories = [\n            ...yearsCategories,\n            ...peakPerfCategories\n        ];\n        const matrix = allCategories.map((sourceCategory, sourceIndex)=>allCategories.map((targetCategory, targetIndex)=>{\n                // Only create connections between years and peak performance (not within same type)\n                const sourceIsYears = sourceIndex < yearsCategories.length;\n                const targetIsYears = targetIndex < yearsCategories.length;\n                // Only connect years to peak performance\n                if (sourceIsYears === targetIsYears) return 0;\n                // Count people who match this year + performance combination\n                const yearsCat = sourceIsYears ? sourceCategory : targetCategory;\n                const perfCat = sourceIsYears ? targetCategory : sourceCategory;\n                return secondaryData.filter((d)=>{\n                    const years = (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0);\n                    const perf = d.peak_performance;\n                    return years === yearsCat && perf === perfCat;\n                }).length;\n            }));\n        // Create chord layout\n        const chordLayout = d3__WEBPACK_IMPORTED_MODULE_2__.chord().padAngle(0.05);\n        const chordData = chordLayout(matrix);\n        const g = svg.append(\"g\").attr(\"transform\", \"translate(\".concat(secondaryMargin.left + secondaryChartWidth / 2, \", \").concat(secondaryMargin.top + secondaryChartHeight / 2, \")\"));\n        // Draw arcs\n        const arc = d3__WEBPACK_IMPORTED_MODULE_2__.arc().innerRadius(secondaryRadius * 0.75).outerRadius(secondaryRadius * 0.95);\n        const ribbon = d3__WEBPACK_IMPORTED_MODULE_2__.ribbon().radius(secondaryRadius * 0.75);\n        // Colors: different hues for years vs peak performance types\n        const yearsColors = [\n            \"#0077CC\",\n            \"#00A3E0\",\n            \"#4FC3F7\",\n            \"#81C784\",\n            \"#AED581\"\n        ]; // Blues/Greens for years\n        const perfColors = [\n            \"#FF6B6B\",\n            \"#FFD166\",\n            \"#06D6A0\",\n            \"#118AB2\",\n            \"#FF9F1C\",\n            \"#4ECDC4\"\n        ]; // Various colors for performance types\n        const colors = [\n            ...yearsColors,\n            ...perfColors.slice(0, peakPerfCategories.length)\n        ];\n        // Draw groups (arcs) with animation and hover effects\n        const groupSelection = g.selectAll(\".chord-group\").data(chordData.groups).enter().append(\"path\").attr(\"class\", \"chord-group\").attr(\"d\", arc).style(\"fill\", (d, i)=>colors[i % colors.length]).style(\"opacity\", 0).on(\"mouseenter\", function(event, d) {\n            var _allCategories_d_index;\n            pauseAnimation(\"secondary arc hover\");\n            // Trigger highlighting for secondary chord\n            console.log(\"\\uD83C\\uDFAF Secondary chord arc hover:\", {\n                groupIndex: d.index,\n                category: allCategories[d.index]\n            });\n            setSecondaryAnimationPhase(\"highlighting\");\n            setSecondaryHighlightedArcIndex(d.index);\n            setSecondaryHighlightedSide(d.index < yearsCategories.length ? \"left\" : \"right\");\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: ((_allCategories_d_index = allCategories[d.index]) === null || _allCategories_d_index === void 0 ? void 0 : _allCategories_d_index.toString().replace(/_/g, \" \")) || \"\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 263,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: d.index < yearsCategories.length ? \"Years at Medtronic\" : \"Peak Performance Type\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 264,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Value: \",\n                                d.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 265,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 262,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", ()=>{\n            resumeAnimation(\"secondary arc hover end\");\n            setTooltip(null);\n            // Reset highlighting when animation resumes\n            setSecondaryAnimationPhase(\"full\");\n            setSecondaryHighlightedArcIndex(null);\n            setSecondaryHighlightedSide(null);\n        });\n        // Apply transition animations to groups\n        groupSelection.transition().duration(750).style(\"opacity\", (d, i)=>{\n            // Apply full relationship chain highlighting\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === i) {\n                    return 1.0; // Source arc is fully highlighted\n                }\n                // Check if this arc is connected to the highlighted arc\n                if (secondaryHighlightedArcIndex !== null) {\n                    const isConnected = chordData.some((chord)=>chord.source.index === i && chord.target.index === secondaryHighlightedArcIndex || chord.source.index === secondaryHighlightedArcIndex && chord.target.index === i);\n                    return isConnected ? 0.95 : 0.3;\n                }\n            }\n            return 0.8;\n        }).style(\"stroke-width\", (d, i)=>{\n            if (secondaryAnimationPhase === \"highlighting\" && secondaryHighlightedArcIndex === i) {\n                return 3;\n            }\n            return 1;\n        }).style(\"stroke\", (d, i)=>{\n            if (secondaryAnimationPhase === \"highlighting\" && secondaryHighlightedArcIndex === i) {\n                return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n            }\n            return \"none\";\n        });\n        // Draw chords (ribbons) with animation and hover effects\n        const chordSelection = g.selectAll(\".chord\").data(chordData).enter().append(\"path\").attr(\"class\", \"chord\").attr(\"d\", ribbon).style(\"fill\", (d)=>colors[d.source.index % colors.length]).style(\"opacity\", 0).on(\"mouseenter\", function(event, d) {\n            pauseAnimation(\"secondary ribbon hover\");\n            // Trigger highlighting for the source side of this ribbon\n            console.log(\"\\uD83C\\uDFAF Secondary ribbon hover:\", {\n                sourceIndex: d.source.index,\n                targetIndex: d.target.index,\n                sourceCategory: allCategories[d.source.index],\n                targetCategory: allCategories[d.target.index]\n            });\n            setSecondaryAnimationPhase(\"highlighting\");\n            setSecondaryHighlightedArcIndex(d.source.index);\n            setSecondaryHighlightedSide(d.source.index < yearsCategories.length ? \"left\" : \"right\");\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: [\n                                allCategories[d.source.index],\n                                \" ↔ \",\n                                allCategories[d.target.index]\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 343,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Connections: \",\n                                d.source.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 346,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 342,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", function() {\n            resumeAnimation(\"secondary ribbon hover end\");\n            setTooltip(null);\n            // Reset highlighting when animation resumes\n            setSecondaryAnimationPhase(\"full\");\n            setSecondaryHighlightedArcIndex(null);\n            setSecondaryHighlightedSide(null);\n        });\n        // Apply transition animations to chords\n        chordSelection.transition().duration(750).style(\"opacity\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                return 0.2; // Dim non-connected ribbons\n            }\n            return settings.isDarkMode ? 0.7 : 0.6;\n        }).style(\"stroke-width\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return 2.5;\n                }\n            }\n            return 0.5;\n        }).style(\"stroke\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n        // Add labels with proper spacing and rotation\n        const secondaryLabelRadius = Math.max(120, secondaryRadius * 1.45);\n        g.selectAll(\".chord-label\").data(chordData.groups).enter().append(\"text\").attr(\"class\", \"chord-label\").attr(\"transform\", (d)=>{\n            const angle = (d.startAngle + d.endAngle) / 2 - Math.PI / 2;\n            const x = secondaryLabelRadius * Math.cos(angle);\n            const y = secondaryLabelRadius * Math.sin(angle);\n            const rotation = angle * 180 / Math.PI;\n            // Rotate text for better readability\n            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {\n                return \"translate(\".concat(x, \", \").concat(y, \") rotate(\").concat(rotation + 180, \")\");\n            } else {\n                return \"translate(\".concat(x, \", \").concat(y, \") rotate(\").concat(rotation, \")\");\n            }\n        }).attr(\"text-anchor\", (d)=>{\n            const angle = (d.startAngle + d.endAngle) / 2 - Math.PI / 2;\n            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {\n                return \"end\";\n            } else {\n                return \"start\";\n            }\n        }).attr(\"alignment-baseline\", \"middle\").style(\"font-family\", labelFontFamily).style(\"font-weight\", labelFontWeight).style(\"font-size\", (d)=>{\n            // Dynamic font size based on number of labels\n            const totalLabels = allCategories.length;\n            if (totalLabels > 12) return \"13px\";\n            if (totalLabels > 10) return \"14px\";\n            if (totalLabels > 8) return \"15px\";\n            return \"16px\";\n        }).style(\"fill\", labelColor).style(\"text-transform\", \"uppercase\").text((d, i)=>{\n            var _allCategories_i;\n            const text = ((_allCategories_i = allCategories[i]) === null || _allCategories_i === void 0 ? void 0 : _allCategories_i.toString().replace(/_/g, \" \")) || \"\";\n            // Show full text for secondary chord labels\n            return text;\n        }).on(\"mouseenter\", function(event, d) {\n            var _allCategories_d_index;\n            const fullText = ((_allCategories_d_index = allCategories[d.index]) === null || _allCategories_d_index === void 0 ? void 0 : _allCategories_d_index.toString().replace(/_/g, \" \")) || \"\";\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: fullText\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 444,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: d.index < yearsCategories.length ? \"Years at Medtronic\" : \"Peak Performance Type\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 445,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 443,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", ()=>setTooltip(null));\n    };\n    // Helper function to ensure source and target are different\n    const ensureDifferentCategories = (source, target)=>{\n        if (source === target) {\n            // Find a different target\n            const differentOption = availableFields.find((field)=>field.value !== source);\n            return {\n                source,\n                target: differentOption ? differentOption.value : \"learning_style\"\n            };\n        }\n        return {\n            source,\n            target\n        };\n    };\n    // Ensure initial state doesn't have same categories\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const corrected = ensureDifferentCategories(currentSource, currentTarget);\n        if (corrected.source !== currentSource || corrected.target !== currentTarget) {\n            setCurrentSource(corrected.source);\n            setCurrentTarget(corrected.target);\n        }\n    }, []);\n    // Track current mode index with state\n    const [currentModeIndex, setCurrentModeIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Update mode index when source/target changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const modeIndex = _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes.findIndex((mode)=>mode.source === currentSource && mode.target === currentTarget);\n        if (modeIndex !== -1) {\n            setCurrentModeIndex(modeIndex);\n        }\n    }, [\n        currentSource,\n        currentTarget\n    ]);\n    // Remove pulsing animation to eliminate flickering - will use CSS animations instead if needed\n    // Arc highlighting animation with connected ribbons\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"\\uD83D\\uDD04 ChordDiagram arc highlighting effect:\", {\n            autoPlay,\n            isAutoPlayEnabled: settings.isAutoPlayEnabled,\n            dataLength: data.length\n        });\n        if (!autoPlay || !settings.isAutoPlayEnabled || !data.length) {\n            console.log(\"❌ Arc highlighting disabled\");\n            // Reset to full opacity when animation is disabled\n            setAnimationPhase(\"full\");\n            setHighlightedArcIndex(null);\n            setHighlightedSide(null);\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n            return;\n        }\n        const animate = ()=>{\n            if (!animationRef.current.running || animationRef.current.isPaused) return;\n            // Safety check: prevent infinite loops\n            if (animationRef.current.cycleCount > 1000) {\n                console.log(\"\\uD83D\\uDED1 Chord animation cycle limit reached, resetting\");\n                animationRef.current.cycleCount = 0;\n                animationRef.current.currentIndex = 0;\n                animationRef.current.currentSide = \"left\";\n            }\n            // Get current data context (this will adapt to mode changes)\n            const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n            // Define all possible categories for each field (not just those with data)\n            const allCategories = {\n                years_at_medtronic: [\n                    \"0-5\",\n                    \"6-10\",\n                    \"11-15\",\n                    \"16-20\",\n                    \"20+\"\n                ],\n                learning_style: [\n                    \"visual\",\n                    \"auditory\",\n                    \"kinesthetic\",\n                    \"reading_writing\"\n                ],\n                shaped_by: [\n                    \"mentor\",\n                    \"challenge\",\n                    \"failure\",\n                    \"success\",\n                    \"team\",\n                    \"other\"\n                ],\n                peak_performance: [\n                    \"Extrovert, Morning\",\n                    \"Extrovert, Evening\",\n                    \"Introvert, Morning\",\n                    \"Introvert, Night\",\n                    \"Ambivert, Morning\",\n                    \"Ambivert, Night\"\n                ],\n                motivation: [\n                    \"impact\",\n                    \"growth\",\n                    \"recognition\",\n                    \"autonomy\",\n                    \"purpose\"\n                ]\n            };\n            const leftValues = allCategories[currentSource] || [];\n            const rightValues = allCategories[currentTarget] || [];\n            const currentSideLength = animationRef.current.currentSide === \"left\" ? leftValues.length : rightValues.length;\n            // Safety check: if current index is out of bounds for new mode, reset to 0\n            if (animationRef.current.currentIndex >= currentSideLength) {\n                animationRef.current.currentIndex = 0;\n            }\n            // Debug: Log the current animation state for dev tools\n            console.log(\"[ChordAnimation] Side:\", animationRef.current.currentSide, \"Index:\", animationRef.current.currentIndex, \"Total on side:\", currentSideLength, \"Mode:\", currentSource + \" → \" + currentTarget);\n            setAnimationPhase(\"highlighting\");\n            setHighlightedArcIndex(animationRef.current.currentIndex);\n            setHighlightedSide(animationRef.current.currentSide);\n            const highlightedCategory = animationRef.current.currentSide === \"left\" ? leftValues[animationRef.current.currentIndex] : rightValues[animationRef.current.currentIndex];\n            // Check if this category has data\n            const hasData = filteredData.some((d)=>{\n                if (animationRef.current.currentSide === \"left\") {\n                    if (currentSource === \"years_at_medtronic\") {\n                        return (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) === highlightedCategory;\n                    }\n                    return d[currentSource] === highlightedCategory;\n                } else {\n                    if (currentTarget === \"years_at_medtronic\") {\n                        return (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) === highlightedCategory;\n                    }\n                    return d[currentTarget] === highlightedCategory;\n                }\n            });\n            console.log(\"✨ Highlighting full relationship chain for:\", {\n                sourceCategory: highlightedCategory,\n                sourceSide: animationRef.current.currentSide,\n                sourceIndex: animationRef.current.currentIndex,\n                hasData: hasData,\n                totalCategories: currentSideLength\n            });\n            // Calculate timing based on global settings - slower for better visibility\n            const stepDuration = Math.max(1500, (settings.autoPlaySpeed || 3000) / 3);\n            const pauseDuration = Math.max(300, stepDuration / 5);\n            // Move to next position - include the last index before switching\n            if (animationRef.current.currentIndex < currentSideLength - 1) {\n                animationRef.current.timer = setTimeout(()=>{\n                    if (animationRef.current.running && !animationRef.current.isPaused) {\n                        animationRef.current.currentIndex++;\n                        animate();\n                    }\n                }, stepDuration + pauseDuration);\n            } else {\n                // Show the last index for the full duration before switching\n                animationRef.current.timer = setTimeout(()=>{\n                    if (animationRef.current.running && !animationRef.current.isPaused) {\n                        // Now switch sides or complete cycle\n                        if (animationRef.current.currentSide === \"left\") {\n                            animationRef.current.currentSide = \"right\";\n                            animationRef.current.currentIndex = 0;\n                            animate();\n                        } else {\n                            // Complete cycle - show full diagram briefly, then restart\n                            animationRef.current.cycleCount++;\n                            const nextModeIndex = (currentModeIndex + 1) % _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes.length;\n                            console.log(\"\\uD83C\\uDF89 ChordAnimation completed full cycle #\" + animationRef.current.cycleCount + \"! Advancing to mode\", nextModeIndex, _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex]);\n                            setAnimationPhase(\"full\");\n                            setHighlightedArcIndex(null);\n                            setHighlightedSide(null);\n                            setTimeout(()=>{\n                                setCurrentModeIndex(nextModeIndex);\n                                setCurrentSource(_shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].source);\n                                setCurrentTarget(_shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].target);\n                                setLastCategoryChange({\n                                    source: _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].source,\n                                    target: _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].target\n                                });\n                                onRelationshipChange === null || onRelationshipChange === void 0 ? void 0 : onRelationshipChange(_shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].source, _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].target);\n                            // Animation will restart due to dependency on currentSource/currentTarget\n                            }, stepDuration * 2);\n                        }\n                    }\n                }, stepDuration + pauseDuration);\n            }\n        };\n        // Start animation if not already running\n        if (!animationRef.current.running) {\n            console.log(\"✅ Starting ChordDiagram arc highlighting animation\");\n            animationRef.current.running = true;\n            animationRef.current.currentIndex = 0;\n            animationRef.current.currentSide = \"left\";\n            animationRef.current.isPaused = false;\n            animate();\n        } else {\n            console.log(\"⚠️ Arc highlighting animation already running\");\n        }\n        return ()=>{\n            console.log(\"\\uD83E\\uDDF9 Cleaning up ChordDiagram arc highlighting animation\");\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n            setAnimationPhase(\"full\");\n            setHighlightedArcIndex(null);\n            setHighlightedSide(null);\n        };\n    }, [\n        autoPlay,\n        settings.isAutoPlayEnabled,\n        data.length,\n        settings.autoPlaySpeed,\n        settings.useTestData\n    ]); // Removed currentSource, currentTarget to prevent restarting\n    // Restart animation when mode changes (but only if not paused)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (autoPlay && settings.isAutoPlayEnabled && data.length && !animationRef.current.isPaused) {\n            console.log(\"\\uD83D\\uDD04 Mode changed, restarting animation with new mode:\", currentSource + \" → \" + currentTarget);\n            // Reset animation state for new mode\n            animationRef.current.currentIndex = 0;\n            animationRef.current.currentSide = \"left\";\n            animationRef.current.cycleCount = 0;\n            // Clear any existing timer\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            // Restart animation if it was running\n            if (animationRef.current.running) {\n                // Call animate function directly to restart with new mode\n                const animate = ()=>{\n                    if (!animationRef.current.running || animationRef.current.isPaused) return;\n                    // Safety check: prevent infinite loops\n                    if (animationRef.current.cycleCount > 1000) {\n                        console.log(\"\\uD83D\\uDED1 Chord animation cycle limit reached, resetting\");\n                        animationRef.current.cycleCount = 0;\n                        animationRef.current.currentIndex = 0;\n                        animationRef.current.currentSide = \"left\";\n                    }\n                    // Get current data context (this will adapt to mode changes)\n                    const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n                    // Define all possible categories for each field (not just those with data)\n                    const allCategories = {\n                        years_at_medtronic: [\n                            \"0-5\",\n                            \"6-10\",\n                            \"11-15\",\n                            \"16-20\",\n                            \"20+\"\n                        ],\n                        learning_style: [\n                            \"visual\",\n                            \"auditory\",\n                            \"kinesthetic\",\n                            \"reading_writing\"\n                        ],\n                        shaped_by: [\n                            \"mentor\",\n                            \"challenge\",\n                            \"failure\",\n                            \"success\",\n                            \"team\",\n                            \"other\"\n                        ],\n                        peak_performance: [\n                            \"Extrovert, Morning\",\n                            \"Extrovert, Evening\",\n                            \"Introvert, Morning\",\n                            \"Introvert, Night\",\n                            \"Ambivert, Morning\",\n                            \"Ambivert, Night\"\n                        ],\n                        motivation: [\n                            \"impact\",\n                            \"growth\",\n                            \"recognition\",\n                            \"autonomy\",\n                            \"purpose\"\n                        ]\n                    };\n                    const leftValues = allCategories[currentSource] || [];\n                    const rightValues = allCategories[currentTarget] || [];\n                    const currentSideLength = animationRef.current.currentSide === \"left\" ? leftValues.length : rightValues.length;\n                    // Safety check: if current index is out of bounds for new mode, reset to 0\n                    if (animationRef.current.currentIndex >= currentSideLength) {\n                        animationRef.current.currentIndex = 0;\n                    }\n                    // Debug: Log the current animation state for dev tools\n                    console.log(\"[ChordAnimation] Side:\", animationRef.current.currentSide, \"Index:\", animationRef.current.currentIndex, \"Total on side:\", currentSideLength, \"Mode:\", currentSource + \" → \" + currentTarget);\n                    setAnimationPhase(\"highlighting\");\n                    setHighlightedArcIndex(animationRef.current.currentIndex);\n                    setHighlightedSide(animationRef.current.currentSide);\n                    const highlightedCategory = animationRef.current.currentSide === \"left\" ? leftValues[animationRef.current.currentIndex] : rightValues[animationRef.current.currentIndex];\n                    // Check if this category has data\n                    const hasData = filteredData.some((d)=>{\n                        if (animationRef.current.currentSide === \"left\") {\n                            if (currentSource === \"years_at_medtronic\") {\n                                return (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) === highlightedCategory;\n                            }\n                            return d[currentSource] === highlightedCategory;\n                        } else {\n                            if (currentTarget === \"years_at_medtronic\") {\n                                return (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) === highlightedCategory;\n                            }\n                            return d[currentTarget] === highlightedCategory;\n                        }\n                    });\n                    console.log(\"✨ Highlighting full relationship chain for:\", {\n                        sourceCategory: highlightedCategory,\n                        sourceSide: animationRef.current.currentSide,\n                        sourceIndex: animationRef.current.currentIndex,\n                        hasData: hasData,\n                        totalCategories: currentSideLength\n                    });\n                    // Calculate timing based on global settings - slower for better visibility\n                    const stepDuration = Math.max(1500, (settings.autoPlaySpeed || 3000) / 3);\n                    const pauseDuration = Math.max(300, stepDuration / 5);\n                    // Move to next position - include the last index before switching\n                    if (animationRef.current.currentIndex < currentSideLength - 1) {\n                        animationRef.current.timer = setTimeout(()=>{\n                            if (animationRef.current.running && !animationRef.current.isPaused) {\n                                animationRef.current.currentIndex++;\n                                animate();\n                            }\n                        }, stepDuration + pauseDuration);\n                    } else {\n                        // Show the last index for the full duration before switching\n                        animationRef.current.timer = setTimeout(()=>{\n                            if (animationRef.current.running && !animationRef.current.isPaused) {\n                                // Now switch sides or complete cycle\n                                if (animationRef.current.currentSide === \"left\") {\n                                    animationRef.current.currentSide = \"right\";\n                                    animationRef.current.currentIndex = 0;\n                                    animate();\n                                } else {\n                                    // Complete cycle - show full diagram briefly, then restart\n                                    animationRef.current.cycleCount++;\n                                    const nextModeIndex = (currentModeIndex + 1) % _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes.length;\n                                    console.log(\"\\uD83C\\uDF89 ChordAnimation completed full cycle #\" + animationRef.current.cycleCount + \"! Advancing to mode\", nextModeIndex, _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex]);\n                                    setAnimationPhase(\"full\");\n                                    setHighlightedArcIndex(null);\n                                    setHighlightedSide(null);\n                                    setTimeout(()=>{\n                                        setCurrentModeIndex(nextModeIndex);\n                                        setCurrentSource(_shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].source);\n                                        setCurrentTarget(_shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].target);\n                                        setLastCategoryChange({\n                                            source: _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].source,\n                                            target: _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].target\n                                        });\n                                        onRelationshipChange === null || onRelationshipChange === void 0 ? void 0 : onRelationshipChange(_shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].source, _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex].target);\n                                    // Animation will restart due to dependency on currentSource/currentTarget\n                                    }, stepDuration * 2);\n                                }\n                            }\n                        }, stepDuration + pauseDuration);\n                    }\n                };\n                animate();\n            }\n        }\n    }, [\n        currentSource,\n        currentTarget,\n        autoPlay,\n        settings.isAutoPlayEnabled,\n        data.length,\n        settings.autoPlaySpeed,\n        settings.useTestData,\n        currentModeIndex\n    ]);\n    // Secondary chord animation system\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!autoPlay || !settings.isAutoPlayEnabled || !data.length || !showSecondaryChord) {\n            // Stop animation if conditions not met\n            console.log(\"\\uD83D\\uDED1 Stopping secondary chord animation:\", {\n                autoPlay,\n                isAutoPlayEnabled: settings.isAutoPlayEnabled,\n                hasData: data.length > 0,\n                showSecondaryChord\n            });\n            if (secondaryAnimationRef.current.timer) {\n                clearTimeout(secondaryAnimationRef.current.timer);\n                secondaryAnimationRef.current.timer = null;\n            }\n            secondaryAnimationRef.current.running = false;\n            return;\n        }\n        const animateSecondary = ()=>{\n            if (!secondaryAnimationRef.current.running || secondaryAnimationRef.current.isPaused) return;\n            // Get secondary chord data context first\n            const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n            const secondaryData = filteredData.filter((d)=>d.peak_performance);\n            const yearsCategories = [\n                \"0-5\",\n                \"6-10\",\n                \"11-15\",\n                \"16-20\",\n                \"20+\"\n            ];\n            const peakPerfCategories = Array.from(new Set(secondaryData.map((d)=>d.peak_performance))).filter(Boolean).sort();\n            const allCategories = [\n                ...yearsCategories,\n                ...peakPerfCategories\n            ];\n            const currentSideLength = secondaryAnimationRef.current.currentSide === \"left\" ? yearsCategories.length : peakPerfCategories.length;\n            // Safety check: if current index is out of bounds, reset to 0\n            if (secondaryAnimationRef.current.currentIndex >= currentSideLength) {\n                secondaryAnimationRef.current.currentIndex = 0;\n            }\n            console.log(\"\\uD83C\\uDFAF SecondaryChord arc animation:\", {\n                side: secondaryAnimationRef.current.currentSide,\n                index: secondaryAnimationRef.current.currentIndex\n            });\n            setSecondaryAnimationPhase(\"highlighting\");\n            // Calculate the actual arc index based on side and position\n            const actualArcIndex = secondaryAnimationRef.current.currentSide === \"left\" ? secondaryAnimationRef.current.currentIndex // Left side: direct index (0-4)\n             : yearsCategories.length + secondaryAnimationRef.current.currentIndex; // Right side: offset by years count\n            setSecondaryHighlightedArcIndex(actualArcIndex);\n            setSecondaryHighlightedSide(secondaryAnimationRef.current.currentSide);\n            // Calculate timing based on global settings - slower for better visibility\n            const stepDuration = Math.max(1500, (settings.autoPlaySpeed || 3000) / 3);\n            const pauseDuration = Math.max(300, stepDuration / 5);\n            // Move to next position - include the last index before switching\n            if (secondaryAnimationRef.current.currentIndex < currentSideLength - 1) {\n                secondaryAnimationRef.current.timer = setTimeout(()=>{\n                    if (secondaryAnimationRef.current.running && !secondaryAnimationRef.current.isPaused) {\n                        secondaryAnimationRef.current.currentIndex++;\n                        animateSecondary();\n                    }\n                }, stepDuration + pauseDuration);\n            } else {\n                // Show the last index for the full duration before switching\n                secondaryAnimationRef.current.timer = setTimeout(()=>{\n                    if (secondaryAnimationRef.current.running && !secondaryAnimationRef.current.isPaused) {\n                        // Now switch sides or complete cycle\n                        if (secondaryAnimationRef.current.currentSide === \"left\") {\n                            secondaryAnimationRef.current.currentSide = \"right\";\n                            secondaryAnimationRef.current.currentIndex = 0;\n                            animateSecondary();\n                        } else {\n                            // Complete cycle - show full diagram briefly, then restart\n                            console.log(\"\\uD83C\\uDF89 SecondaryChordAnimation completed full cycle! Restarting...\");\n                            setSecondaryAnimationPhase(\"full\");\n                            setSecondaryHighlightedArcIndex(null);\n                            setSecondaryHighlightedSide(null);\n                            secondaryAnimationRef.current.timer = setTimeout(()=>{\n                                if (secondaryAnimationRef.current.running && !secondaryAnimationRef.current.isPaused) {\n                                    secondaryAnimationRef.current.currentSide = \"left\";\n                                    secondaryAnimationRef.current.currentIndex = 0;\n                                    animateSecondary();\n                                }\n                            }, stepDuration * 2);\n                        }\n                    }\n                }, stepDuration + pauseDuration);\n            }\n        };\n        // Start animation if not already running\n        if (!secondaryAnimationRef.current.running) {\n            console.log(\"✅ Starting SecondaryChord arc highlighting animation\");\n            secondaryAnimationRef.current.running = true;\n            secondaryAnimationRef.current.currentIndex = 0;\n            secondaryAnimationRef.current.currentSide = \"left\";\n            secondaryAnimationRef.current.isPaused = false;\n            animateSecondary();\n        } else {\n            console.log(\"⚠️ Secondary arc highlighting animation already running\");\n        }\n        return ()=>{\n            console.log(\"\\uD83E\\uDDF9 Cleaning up SecondaryChord arc highlighting animation\");\n            if (secondaryAnimationRef.current.timer) {\n                clearTimeout(secondaryAnimationRef.current.timer);\n                secondaryAnimationRef.current.timer = null;\n            }\n            secondaryAnimationRef.current.running = false;\n            setSecondaryAnimationPhase(\"full\");\n            setSecondaryHighlightedArcIndex(null);\n            setSecondaryHighlightedSide(null);\n        };\n    }, [\n        autoPlay,\n        settings.isAutoPlayEnabled,\n        data.length,\n        showSecondaryChord,\n        settings.autoPlaySpeed,\n        settings.useTestData\n    ]); // Removed currentSource, currentTarget to prevent restarting\n    // Re-render secondary chord when its animation state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (showSecondaryChord) {\n            renderSecondaryChord();\n        }\n    }, [\n        showSecondaryChord,\n        data,\n        settings.useTestData,\n        settings.isDarkMode\n    ]);\n    // Update visual styling of existing main chord elements when animation state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        // Update left arcs opacity and stroke based on animation state\n        svg.selectAll(\"path.left-arc\").transition().duration(300).style(\"opacity\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\") {\n                    if (i === highlightedArcIndex) {\n                        return 1.0; // Source arc is fully highlighted\n                    }\n                    return 0.4; // Dim other left arcs\n                }\n            }\n            return 0.8; // Default opacity\n        }).style(\"stroke-width\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && i === highlightedArcIndex) {\n                    return 3;\n                }\n            }\n            return 1;\n        }).style(\"stroke\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && i === highlightedArcIndex) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n        // Update right arcs opacity and stroke based on animation state\n        svg.selectAll(\"path.right-arc\").transition().duration(300).style(\"opacity\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\") {\n                    if (i === highlightedArcIndex) {\n                        return 1.0; // Source arc is fully highlighted\n                    }\n                    return 0.4; // Dim other right arcs\n                }\n            }\n            return 0.8; // Default opacity\n        }).style(\"stroke-width\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\" && i === highlightedArcIndex) {\n                    return 3;\n                }\n            }\n            return 1;\n        }).style(\"stroke\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\" && i === highlightedArcIndex) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n        // Update ribbons opacity and stroke based on animation state\n        svg.selectAll(\"path.ribbon\").transition().duration(300).style(\"opacity\", (d)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                if (highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                return 0.2; // Dim non-connected ribbons\n            }\n            return settings.isDarkMode ? 0.7 : 0.6;\n        }).style(\"stroke-width\", (d)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index || highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return 2.5;\n                }\n            }\n            return 0.5;\n        }).style(\"stroke\", (d)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index || highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n    }, [\n        animationPhase,\n        highlightedArcIndex,\n        highlightedSide,\n        settings.isDarkMode\n    ]);\n    // Update visual styling of existing secondary chord elements when animation state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!secondarySvgRef.current || !showSecondaryChord) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(secondarySvgRef.current);\n        // Update secondary chord elements based on their animation state\n        svg.selectAll(\"path.chord-group\").transition().duration(300).style(\"opacity\", (d, i)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === i) {\n                    return 1.0; // Source arc is fully highlighted\n                }\n                return 0.4; // Dim other arcs\n            }\n            return 0.8;\n        }).style(\"stroke-width\", (d, i)=>{\n            if (secondaryAnimationPhase === \"highlighting\" && secondaryHighlightedArcIndex === i) {\n                return 3;\n            }\n            return 1;\n        }).style(\"stroke\", (d, i)=>{\n            if (secondaryAnimationPhase === \"highlighting\" && secondaryHighlightedArcIndex === i) {\n                return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n            }\n            return \"none\";\n        });\n        svg.selectAll(\"path.chord\").transition().duration(300).style(\"opacity\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                return 0.2; // Dim non-connected ribbons\n            }\n            return settings.isDarkMode ? 0.7 : 0.6;\n        }).style(\"stroke-width\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return 2.5;\n                }\n            }\n            return 0.5;\n        }).style(\"stroke\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n    }, [\n        secondaryAnimationPhase,\n        secondaryHighlightedArcIndex,\n        secondaryHighlightedSide,\n        settings.isDarkMode,\n        showSecondaryChord\n    ]);\n    // Remove conflicting opacity update system - opacity will be handled in main rendering\n    // Add pause/resume functionality\n    const pauseAnimation = (reason)=>{\n        console.log(\"⏸️ Pausing animation:\", reason);\n        animationRef.current.isPaused = true;\n        secondaryAnimationRef.current.isPaused = true;\n        if (animationRef.current.timer) {\n            clearTimeout(animationRef.current.timer);\n            animationRef.current.timer = null;\n        }\n        if (secondaryAnimationRef.current.timer) {\n            clearTimeout(secondaryAnimationRef.current.timer);\n            secondaryAnimationRef.current.timer = null;\n        }\n    };\n    const resumeAnimation = (reason)=>{\n        console.log(\"▶️ Resuming animation:\", reason);\n        animationRef.current.isPaused = false;\n        secondaryAnimationRef.current.isPaused = false;\n        // Ensure animation state is properly reset\n        if (!animationRef.current.running) {\n            console.log(\"\\uD83D\\uDD04 Restarting chord animation after resume\");\n            animationRef.current.running = true;\n            animationRef.current.currentIndex = 0;\n            animationRef.current.currentSide = \"left\";\n            animationRef.current.cycleCount = 0;\n        }\n    // The mode change useEffect will automatically restart the animation\n    // when isPaused becomes false and mode changes\n    };\n    // Check if container is too small - reduced minimum size for better compatibility\n    const margin = {\n        top: 80,\n        right: 80,\n        bottom: 100,\n        left: 80\n    };\n    const chartWidth = width - margin.left - margin.right;\n    const chartHeight = height - margin.top - margin.bottom;\n    const isContainerTooSmall = chartWidth < 100 || chartHeight < 100; // Reduced from 200x200 to 100x100\n    // Render circular chord diagram\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current || !data.length || isLoading || isContainerTooSmall) return;\n        // Clear previous content\n        d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current).selectAll(\"*\").remove();\n        // Filter data based on global settings\n        const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        // Adjust size based on whether we're showing two chords\n        const effectiveWidth = showSecondaryChord ? width * 0.45 : width;\n        const effectiveHeight = showSecondaryChord ? height * 0.8 : height * 0.85;\n        const effectiveChartWidth = effectiveWidth - margin.left - margin.right;\n        const effectiveChartHeight = effectiveHeight - margin.top - margin.bottom;\n        const radius = Math.max(120, Math.min(effectiveChartWidth, effectiveChartHeight) / 2 - 60);\n        // Create definitions for gradients\n        const defs = svg.append(\"defs\");\n        // Define fixed order for years at Medtronic\n        const YEARS_GROUPS = [\n            \"0-5\",\n            \"6-10\",\n            \"11-15\",\n            \"16-20\",\n            \"20+\"\n        ];\n        // Get unique values for left and right sides, using fixed order for years\n        const leftValues = currentSource === \"years_at_medtronic\" ? YEARS_GROUPS : Array.from(new Set(filteredData.map((d)=>d[currentSource]))).filter(Boolean);\n        const rightValues = currentTarget === \"years_at_medtronic\" ? YEARS_GROUPS : Array.from(new Set(filteredData.map((d)=>d[currentTarget]))).filter(Boolean);\n        // Process data for chord layout\n        const chordData = (0,_shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.processChordData)(filteredData, currentSource, currentTarget);\n        // Separate source and target categories\n        const sourceCategories = new Set();\n        const targetCategories = new Set();\n        filteredData.forEach((d)=>{\n            if (currentSource === \"years_at_medtronic\") {\n                sourceCategories.add((0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0));\n            } else {\n                sourceCategories.add(d[currentSource] || \"Unknown\");\n            }\n            if (currentTarget === \"years_at_medtronic\") {\n                targetCategories.add((0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0));\n            } else {\n                targetCategories.add(d[currentTarget] || \"Unknown\");\n            }\n        });\n        // Convert to arrays and sort\n        const sourceArray = Array.from(sourceCategories).sort();\n        const targetArray = Array.from(targetCategories).sort();\n        // Calculate totals for each category\n        const leftTotals = sourceArray.map((cat)=>filteredData.filter((d)=>{\n                const value = currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentSource];\n                return value === cat;\n            }).length);\n        const rightTotals = targetArray.map((cat)=>filteredData.filter((d)=>{\n                const value = currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentTarget];\n                return value === cat;\n            }).length);\n        const leftTotalSum = leftTotals.reduce((sum, val)=>sum + val, 0);\n        const rightTotalSum = rightTotals.reduce((sum, val)=>sum + val, 0);\n        // Create connection matrix\n        const connectionMatrix = sourceArray.map((sourceCat)=>targetArray.map((targetCat)=>{\n                return filteredData.filter((d)=>{\n                    const source = currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentSource];\n                    const target = currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentTarget];\n                    return source === sourceCat && target === targetCat;\n                }).length;\n            }));\n        // Check if this is a category change that should trigger animation\n        const isCategoryChange = lastCategoryChange.source !== currentSource || lastCategoryChange.target !== currentTarget;\n        // Add smooth transitions - faster for hover interactions\n        const transition = d3__WEBPACK_IMPORTED_MODULE_2__.transition().duration(isCategoryChange ? 750 : 100).ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut);\n        // --- True left/right bipartite layout with better spacing ---\n        // Left arcs: 180°+gap to 360°-gap (Math.PI+gap to 2*Math.PI-gap)\n        // Right arcs: 0+gap to 180°-gap (0+gap to Math.PI-gap)\n        const arcGap = Math.PI * 0.12; // Larger gap for better label spacing\n        const leftStart = Math.PI + arcGap; // 180° + gap\n        const leftEnd = 2 * Math.PI - arcGap; // 360° - gap\n        const rightStart = 0 + arcGap; // 0° + gap\n        const rightEnd = Math.PI - arcGap; // 180° - gap\n        const leftArcSpan = leftEnd - leftStart; // 180° - 2*gap\n        const rightArcSpan = rightEnd - rightStart; // 180° - 2*gap\n        // Add minimum spacing between arcs to prevent label overlap\n        const minArcSpacing = Math.PI * 0.02; // Minimum 2° between arcs\n        // Assign arc angles for left arcs with proper spacing\n        let leftAngle = leftStart;\n        const leftArcs = leftValues.map((value, i)=>{\n            const count = filteredData.filter((d)=>currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) === value : d[currentSource] === value).length;\n            // Calculate arc span with spacing consideration\n            const availableSpan = leftArcSpan - minArcSpacing * (leftValues.length - 1);\n            const arcSpan = currentSource === \"years_at_medtronic\" ? availableSpan / leftValues.length : Math.max(minArcSpacing, availableSpan * (count / (leftTotalSum || 1)));\n            const startAngle = leftAngle;\n            const endAngle = leftAngle + arcSpan;\n            leftAngle = endAngle + minArcSpacing; // Add spacing between arcs\n            const color = getNodeColor(value, currentSource, settings.categoryColors, settings.isDarkMode);\n            const opacity = count === 0 ? 0.15 : 0.8;\n            return {\n                name: value,\n                value: count,\n                startAngle,\n                endAngle,\n                color,\n                opacity\n            };\n        });\n        // Assign arc angles for right arcs with proper spacing\n        let rightAngle = rightStart;\n        const rightArcs = rightValues.map((value, i)=>{\n            const count = filteredData.filter((d)=>currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) === value : d[currentTarget] === value).length;\n            // Calculate arc span with spacing consideration\n            const availableSpan = rightArcSpan - minArcSpacing * (rightValues.length - 1);\n            const arcSpan = currentTarget === \"years_at_medtronic\" ? availableSpan / rightValues.length : Math.max(minArcSpacing, availableSpan * (count / (rightTotalSum || 1)));\n            const startAngle = rightAngle;\n            const endAngle = rightAngle + arcSpan;\n            rightAngle = endAngle + minArcSpacing; // Add spacing between arcs\n            const color = getNodeColor(value, currentTarget, settings.categoryColors, settings.isDarkMode);\n            const opacity = count === 0 ? 0.15 : 0.8;\n            return {\n                name: value,\n                value: count,\n                startAngle,\n                endAngle,\n                color,\n                opacity\n            };\n        });\n        // Draw arcs (use per-arc opacity)\n        const innerRadius = Math.max(60, radius * 0.75);\n        const outerRadius = Math.max(80, radius * 0.95);\n        const arcGen = d3__WEBPACK_IMPORTED_MODULE_2__.arc().innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius((d)=>{\n            // Only round the outer corners (outerRadius), not the inner\n            // D3 v7+ supports cornerRadius as a function\n            // We'll return 0 for inner, 8 for outer\n            // But d3.arc() only supports one value, so we need to use custom path if we want true squared inner corners\n            // As a workaround, set cornerRadius to 0 if the arc is small, else 8\n            return 0;\n        });\n        // Position the chart group with margins to prevent cropping\n        const g = svg.append(\"g\").attr(\"transform\", \"translate(\".concat(margin.left + effectiveChartWidth / 2, \", \").concat(margin.top + effectiveChartHeight / 2, \")\"));\n        // Add gradients for arcs\n        leftArcs.forEach((arc, i)=>{\n            var _d3_color;\n            const baseColor = arc.color;\n            const lighterColor = ((_d3_color = d3__WEBPACK_IMPORTED_MODULE_2__.color(baseColor)) === null || _d3_color === void 0 ? void 0 : _d3_color.brighter(0.3).toString()) || baseColor;\n            defs.append(\"linearGradient\").attr(\"id\", \"left-arc-gradient-\".concat(i)).attr(\"gradientUnits\", \"userSpaceOnUse\").attr(\"x1\", 0).attr(\"y1\", 0).attr(\"x2\", 0).attr(\"y2\", 1).selectAll(\"stop\").data([\n                {\n                    offset: \"0%\",\n                    color: baseColor\n                },\n                {\n                    offset: \"100%\",\n                    color: lighterColor\n                }\n            ]).enter().append(\"stop\").attr(\"offset\", (d)=>d.offset).attr(\"stop-color\", (d)=>d.color);\n        });\n        rightArcs.forEach((arc, i)=>{\n            var _d3_color;\n            const baseColor = arc.color;\n            const lighterColor = ((_d3_color = d3__WEBPACK_IMPORTED_MODULE_2__.color(baseColor)) === null || _d3_color === void 0 ? void 0 : _d3_color.brighter(0.3).toString()) || baseColor;\n            defs.append(\"linearGradient\").attr(\"id\", \"right-arc-gradient-\".concat(i)).attr(\"gradientUnits\", \"userSpaceOnUse\").attr(\"x1\", 0).attr(\"y1\", 0).attr(\"x2\", 0).attr(\"y2\", 1).selectAll(\"stop\").data([\n                {\n                    offset: \"0%\",\n                    color: baseColor\n                },\n                {\n                    offset: \"100%\",\n                    color: lighterColor\n                }\n            ]).enter().append(\"stop\").attr(\"offset\", (d)=>d.offset).attr(\"stop-color\", (d)=>d.color);\n        });\n        // Create left arcs with event handlers first\n        const leftArcSelection = g.selectAll(\"path.left-arc\").data(leftArcs).enter().append(\"path\").attr(\"class\", \"left-arc\").attr(\"d\", (d)=>arcGen({\n                startAngle: d.startAngle,\n                endAngle: d.endAngle\n            })).attr(\"fill\", (d, i)=>\"url(#left-arc-gradient-\".concat(i, \")\")).attr(\"opacity\", 0).on(\"mouseenter\", function(event, d) {\n            pauseAnimation(\"left arc hover\");\n            // Trigger the same highlighting as auto-cycle animation\n            const arcIndex = leftArcs.findIndex((arc)=>arc.name === d.name);\n            setAnimationPhase(\"highlighting\");\n            setHighlightedArcIndex(arcIndex);\n            setHighlightedSide(\"left\");\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: (d.name || \"Unknown\").toString().replace(/_/g, \" \")\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1368,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Count: \",\n                                d.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1369,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 1367,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", ()=>{\n            resumeAnimation(\"left arc hover end\");\n            setTooltip(null);\n            // Reset highlighting when animation resumes\n            setAnimationPhase(\"full\");\n            setHighlightedArcIndex(null);\n            setHighlightedSide(null);\n        });\n        // Apply transition animations separately\n        leftArcSelection.transition(transition).attr(\"opacity\", (d, i)=>{\n            // Apply full relationship chain highlighting\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\") {\n                    // Highlight the source arc\n                    if (i === highlightedArcIndex) {\n                        return 1.0; // Source arc is fully highlighted\n                    }\n                    // Check if this arc is connected to the highlighted right arc\n                    if (highlightedSide === \"left\" && highlightedArcIndex !== null) {\n                        return 0.4; // Dim other left arcs\n                    }\n                } else if (highlightedSide === \"right\" && highlightedArcIndex !== null) {\n                    var _leftArcs_i, _rightArcs_highlightedArcIndex;\n                    // When right arc is highlighted, highlight left arcs connected to it\n                    const matrixValue = connectionMatrix[i] && connectionMatrix[i][highlightedArcIndex];\n                    const isConnectedToHighlightedRight = matrixValue > 0;\n                    console.log(\"\\uD83D\\uDD17 Left arc \".concat(i, \" (\").concat((_leftArcs_i = leftArcs[i]) === null || _leftArcs_i === void 0 ? void 0 : _leftArcs_i.name, \") connected to right arc \").concat(highlightedArcIndex, \" (\").concat((_rightArcs_highlightedArcIndex = rightArcs[highlightedArcIndex]) === null || _rightArcs_highlightedArcIndex === void 0 ? void 0 : _rightArcs_highlightedArcIndex.name, \")?\"), isConnectedToHighlightedRight, \"Matrix value:\", matrixValue);\n                    return isConnectedToHighlightedRight ? 0.95 : 0.3; // Higher contrast\n                }\n            }\n            // Use stable base opacity without pulsing to prevent flickering\n            return Math.max(0.8, d.opacity);\n        }).attr(\"stroke-width\", (d, i)=>{\n            // Enhanced stroke for relationship chain\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && i === highlightedArcIndex) {\n                    return 3; // Thickest stroke for source arc\n                }\n                // Stroke for connected arcs when right side is highlighted\n                if (highlightedSide === \"right\" && highlightedArcIndex !== null) {\n                    const matrixValue = connectionMatrix[i] && connectionMatrix[i][highlightedArcIndex];\n                    if (matrixValue > 0) {\n                        return 2; // Medium stroke for connected arcs\n                    }\n                }\n            }\n            return 1;\n        }).attr(\"stroke\", (d, i)=>{\n            // Enhanced stroke color for relationship chain\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && i === highlightedArcIndex) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n                // Stroke for connected arcs when right side is highlighted\n                if (highlightedSide === \"right\" && highlightedArcIndex !== null) {\n                    const matrixValue = connectionMatrix[i] && connectionMatrix[i][highlightedArcIndex];\n                    if (matrixValue > 0) {\n                        return settings.isDarkMode ? \"rgba(255,255,255,0.3)\" : \"rgba(0,0,0,0.2)\";\n                    }\n                }\n            }\n            return \"none\";\n        });\n        // Create right arcs with event handlers first\n        const rightArcSelection = g.selectAll(\"path.right-arc\").data(rightArcs).enter().append(\"path\").attr(\"class\", \"right-arc\").attr(\"d\", (d)=>arcGen({\n                startAngle: d.startAngle,\n                endAngle: d.endAngle\n            })).attr(\"fill\", (d, i)=>\"url(#right-arc-gradient-\".concat(i, \")\")).attr(\"opacity\", 0).on(\"mouseenter\", function(event, d) {\n            pauseAnimation(\"arc hover\");\n            // Trigger the same highlighting as auto-cycle animation\n            const arcIndex = rightArcs.findIndex((arc)=>arc.name === d.name);\n            console.log(\"\\uD83C\\uDFAF Hover triggering right arc highlighting:\", {\n                arcName: d.name,\n                arcIndex: arcIndex\n            });\n            setAnimationPhase(\"highlighting\");\n            setHighlightedArcIndex(arcIndex);\n            setHighlightedSide(\"right\");\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: (d.name || \"Unknown\").toString().replace(/_/g, \" \")\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1471,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Count: \",\n                                d.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1472,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 1470,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", ()=>{\n            resumeAnimation(\"arc hover end\");\n            setTooltip(null);\n            // Reset highlighting when animation resumes\n            setAnimationPhase(\"full\");\n            setHighlightedArcIndex(null);\n            setHighlightedSide(null);\n        });\n        // Apply transition animations separately\n        rightArcSelection.transition(transition).attr(\"opacity\", (d, i)=>{\n            // Apply full relationship chain highlighting\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\") {\n                    // Highlight the source arc\n                    if (i === highlightedArcIndex) {\n                        return 1.0; // Source arc is fully highlighted\n                    }\n                    return 0.4; // Dim other right arcs\n                } else if (highlightedSide === \"left\" && highlightedArcIndex !== null) {\n                    var _rightArcs_i, _leftArcs_highlightedArcIndex;\n                    // When left arc is highlighted, highlight right arcs connected to it\n                    const matrixValue = connectionMatrix[highlightedArcIndex] && connectionMatrix[highlightedArcIndex][i];\n                    const isConnectedToHighlightedLeft = matrixValue > 0;\n                    console.log(\"\\uD83D\\uDD17 Right arc \".concat(i, \" (\").concat((_rightArcs_i = rightArcs[i]) === null || _rightArcs_i === void 0 ? void 0 : _rightArcs_i.name, \") connected to left arc \").concat(highlightedArcIndex, \" (\").concat((_leftArcs_highlightedArcIndex = leftArcs[highlightedArcIndex]) === null || _leftArcs_highlightedArcIndex === void 0 ? void 0 : _leftArcs_highlightedArcIndex.name, \")?\"), isConnectedToHighlightedLeft, \"Matrix value:\", matrixValue);\n                    return isConnectedToHighlightedLeft ? 0.95 : 0.3; // Higher contrast\n                }\n            }\n            // Use stable base opacity without pulsing to prevent flickering\n            return Math.max(0.8, d.opacity);\n        }).attr(\"stroke-width\", (d, i)=>{\n            // Enhanced stroke for relationship chain\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\" && i === highlightedArcIndex) {\n                    return 3; // Thickest stroke for source arc\n                }\n                // Stroke for connected arcs when left side is highlighted\n                if (highlightedSide === \"left\" && highlightedArcIndex !== null) {\n                    const matrixValue = connectionMatrix[highlightedArcIndex] && connectionMatrix[highlightedArcIndex][i];\n                    if (matrixValue > 0) {\n                        return 2; // Medium stroke for connected arcs\n                    }\n                }\n            }\n            return 1;\n        }).attr(\"stroke\", (d, i)=>{\n            // Enhanced stroke color for relationship chain\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\" && i === highlightedArcIndex) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n                // Stroke for connected arcs when left side is highlighted\n                if (highlightedSide === \"left\" && highlightedArcIndex !== null) {\n                    const matrixValue = connectionMatrix[highlightedArcIndex] && connectionMatrix[highlightedArcIndex][i];\n                    if (matrixValue > 0) {\n                        return settings.isDarkMode ? \"rgba(255,255,255,0.3)\" : \"rgba(0,0,0,0.2)\";\n                    }\n                }\n            }\n            return \"none\";\n        });\n        // Draw ribbons for connections (distributed along arc, proportional thickness)\n        // Use d3.ribbon() for each connection, but set the width by using the full segment for each connection\n        const ribbonRadius = Math.max(60, radius * 0.75); // Ensure minimum radius for ribbons\n        const ribbonGen = d3__WEBPACK_IMPORTED_MODULE_2__.ribbon().radius(ribbonRadius);\n        const connections = [];\n        for(let i = 0; i < sourceArray.length; i++){\n            for(let j = 0; j < targetArray.length; j++){\n                const value = connectionMatrix[i][j];\n                if (value > 0) {\n                    // Find the segment for this connection on both arcs\n                    const leftSeg = leftArcs[i];\n                    const rightSeg = rightArcs[j];\n                    // Compute arc midpoints for gradient direction\n                    const leftMidAngle = (leftSeg.startAngle + leftSeg.endAngle) / 2 - Math.PI / 2;\n                    const rightMidAngle = (rightSeg.startAngle + rightSeg.endAngle) / 2 - Math.PI / 2;\n                    const leftX = Math.cos(leftMidAngle) * ribbonRadius;\n                    const leftY = Math.sin(leftMidAngle) * ribbonRadius;\n                    const rightX = Math.cos(rightMidAngle) * ribbonRadius;\n                    const rightY = Math.sin(rightMidAngle) * ribbonRadius;\n                    // Add gradient for this ribbon\n                    const leftColor = leftArcs[i].color || d3__WEBPACK_IMPORTED_MODULE_2__.schemeCategory10[i % 10];\n                    const rightColor = rightArcs[j].color || d3__WEBPACK_IMPORTED_MODULE_2__.schemeCategory10[(j + 5) % 10];\n                    defs.append(\"linearGradient\").attr(\"id\", \"ribbon-gradient-\".concat(i, \"-\").concat(j)).attr(\"gradientUnits\", \"userSpaceOnUse\").attr(\"x1\", leftX).attr(\"y1\", leftY).attr(\"x2\", rightX).attr(\"y2\", rightY).selectAll(\"stop\").data([\n                        {\n                            offset: \"0%\",\n                            color: leftColor\n                        },\n                        {\n                            offset: \"100%\",\n                            color: rightColor\n                        }\n                    ]).enter().append(\"stop\").attr(\"offset\", (d)=>d.offset).attr(\"stop-color\", (d)=>d.color);\n                    connections.push({\n                        source: {\n                            startAngle: leftSeg.startAngle,\n                            endAngle: leftSeg.endAngle,\n                            index: i\n                        },\n                        target: {\n                            startAngle: rightSeg.startAngle,\n                            endAngle: rightSeg.endAngle,\n                            index: j\n                        },\n                        value,\n                        left: leftArcs[i],\n                        right: rightArcs[j],\n                        gradientId: \"ribbon-gradient-\".concat(i, \"-\").concat(j)\n                    });\n                }\n            }\n        }\n        // Create ribbons with event handlers first\n        const ribbonSelection = g.selectAll(\"path.ribbon\").data(connections).enter().append(\"path\").attr(\"class\", \"ribbon\").attr(\"d\", function(d) {\n            const path = ribbonGen({\n                source: d.source,\n                target: d.target\n            });\n            return typeof path === \"string\" ? path : \"\";\n        }).attr(\"fill\", (d)=>\"url(#\".concat(d.gradientId, \")\")).attr(\"opacity\", 0).on(\"mouseenter\", function(event, d) {\n            pauseAnimation(\"ribbon hover\");\n            // Trigger highlighting for the source side of this ribbon (same as auto-cycle)\n            console.log(\"\\uD83C\\uDFAF Hover triggering ribbon highlighting:\", {\n                leftArcName: d.left.name,\n                rightArcName: d.right.name,\n                sourceIndex: d.source.index,\n                targetIndex: d.target.index\n            });\n            setAnimationPhase(\"highlighting\");\n            setHighlightedArcIndex(d.source.index);\n            setHighlightedSide(\"left\");\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: [\n                                (d.left.name || \"Unknown\").toString().replace(/_/g, \" \"),\n                                \" ↔ \",\n                                (d.right.name || \"Unknown\").toString().replace(/_/g, \" \")\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1630,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Connections: \",\n                                d.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1633,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 1629,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", function(event, d) {\n            resumeAnimation(\"ribbon hover end\");\n            setTooltip(null);\n            // Reset highlighting when animation resumes\n            setAnimationPhase(\"full\");\n            setHighlightedArcIndex(null);\n            setHighlightedSide(null);\n        });\n        // Apply transition animations separately\n        ribbonSelection.transition(transition).attr(\"opacity\", (d)=>{\n            // Highlight ribbons connected to highlighted arcs with enhanced visibility\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                if (highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                return 0.2; // Dim non-connected ribbons more for better contrast\n            }\n            // Use stable base opacity without pulsing\n            return settings.isDarkMode ? 0.7 : 0.6;\n        }).attr(\"stroke-width\", (d)=>{\n            // Enhanced stroke for highlighted ribbons to show connections clearly\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index || highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return 2.5; // Slightly thicker for better visibility\n                }\n            }\n            return 0.5;\n        }).attr(\"stroke\", (d)=>{\n            // Enhanced stroke color for highlighted connections\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index || highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n        // --- Label placement: properly spaced around circle ---\n        const labelRadius = Math.max(120, radius * 1.45); // Even more space for full text labels\n        const labelGroup = svg.append(\"g\").attr(\"transform\", \"translate(\".concat(margin.left + effectiveChartWidth / 2, \", \").concat(margin.top + effectiveChartHeight / 2, \")\"));\n        // Combine all arcs for unified label placement\n        const allArcs = [\n            ...leftArcs.map((arc)=>({\n                    ...arc,\n                    side: \"left\"\n                })),\n            ...rightArcs.map((arc)=>({\n                    ...arc,\n                    side: \"right\"\n                }))\n        ];\n        // Add labels with smart positioning to avoid overlap\n        labelGroup.selectAll(\"text.arc-label\").data(allArcs).enter().append(\"text\").attr(\"class\", \"arc-label\").attr(\"transform\", (d)=>{\n            const angle = (d.startAngle + d.endAngle) / 2 - Math.PI / 2;\n            const x = labelRadius * Math.cos(angle);\n            const y = labelRadius * Math.sin(angle);\n            const rotation = angle * 180 / Math.PI;\n            // Rotate text for better readability\n            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {\n                return \"translate(\".concat(x, \", \").concat(y, \") rotate(\").concat(rotation + 180, \")\");\n            } else {\n                return \"translate(\".concat(x, \", \").concat(y, \") rotate(\").concat(rotation, \")\");\n            }\n        }).attr(\"text-anchor\", (d)=>{\n            const angle = (d.startAngle + d.endAngle) / 2 - Math.PI / 2;\n            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {\n                return \"end\";\n            } else {\n                return \"start\";\n            }\n        }).attr(\"alignment-baseline\", \"middle\").style(\"font-family\", labelFontFamily).style(\"font-weight\", labelFontWeight).style(\"font-size\", (d)=>{\n            // Dynamic font size based on number of labels - larger since we're showing full text\n            const totalLabels = allArcs.length;\n            if (totalLabels > 12) return \"13px\";\n            if (totalLabels > 10) return \"14px\";\n            if (totalLabels > 8) return \"15px\";\n            return \"\".concat(Math.max(16, labelFontSize), \"px\");\n        }).style(\"fill\", labelColor).style(\"text-transform\", \"uppercase\").text((d)=>{\n            const text = (d.name || \"Unknown\").toString().replace(/_/g, \" \");\n            // Show full text - no truncation\n            return text;\n        }).on(\"mouseenter\", function(event, d) {\n            pauseAnimation(\"label hover\");\n            const fullText = (d.name || \"Unknown\").toString().replace(/_/g, \" \");\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: fullText\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1746,\n                            columnNumber: 16\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Count: \",\n                                d.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1747,\n                            columnNumber: 16\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Side: \",\n                                d.side\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1748,\n                            columnNumber: 16\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 1745,\n                    columnNumber: 14\n                }, this)\n            });\n        }).on(\"mouseleave\", ()=>{\n            resumeAnimation(\"label hover end\");\n            setTooltip(null);\n        });\n        // Update insights\n        const totalConnections = connections.reduce((sum, d)=>sum + d.value, 0);\n        const strongestConnection = connections.length > 0 ? connections.reduce((max, d)=>d.value > max.value ? d : max, connections[0]) : null;\n        setInsights([\n            {\n                title: \"Total Responses\",\n                value: filteredData.length.toString()\n            },\n            {\n                title: \"Current View\",\n                value: \"\".concat(currentSource, \" ↔ \").concat(currentTarget)\n            },\n            strongestConnection ? {\n                title: \"Strongest Connection\",\n                value: \"\".concat(strongestConnection.left.name || \"Unknown\", \" ↔ \").concat(strongestConnection.right.name || \"Unknown\"),\n                description: \"\".concat(strongestConnection.value, \" connections\")\n            } : {\n                title: \"Strongest Connection\",\n                value: \"No connections found\",\n                description: \"\"\n            },\n            {\n                title: \"Total Connections\",\n                value: totalConnections.toString()\n            }\n        ]);\n    }, [\n        data,\n        currentSource,\n        currentTarget,\n        settings.useTestData,\n        settings.categoryColors,\n        isLoading,\n        lastCategoryChange,\n        isContainerTooSmall,\n        chartWidth,\n        chartHeight,\n        showSecondaryChord,\n        settings.isDarkMode\n    ]);\n    // Render secondary chord when peak performance is involved\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (showSecondaryChord) {\n            renderSecondaryChord();\n        }\n    }, [\n        showSecondaryChord,\n        data,\n        settings.useTestData,\n        settings.isDarkMode,\n        labelColor\n    ]);\n    // Tooltip rendering\n    const tooltipEl = tooltip ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: \"absolute\",\n            left: tooltip.x + 16,\n            top: tooltip.y + 16,\n            background: \"rgba(20,20,30,0.98)\",\n            color: \"#fff\",\n            padding: \"10px 16px\",\n            borderRadius: 8,\n            pointerEvents: \"none\",\n            zIndex: 100,\n            fontFamily: \"Avenir Next World, sans-serif\",\n            fontWeight: 600,\n            fontSize: 16,\n            boxShadow: \"0 4px 24px 0 rgba(16, 16, 235, 0.12)\",\n            maxWidth: 320\n        },\n        role: \"tooltip\",\n        \"aria-live\": \"polite\",\n        children: tooltip.content\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n        lineNumber: 1787,\n        columnNumber: 5\n    }, this) : null;\n    // Apply theme based on global settings\n    const themeClass = settings.isDarkMode ? \"dark\" : \"\";\n    const backgroundColor = settings.isDarkMode ? \"#1a1a1a\" : \"#ffffff\";\n    const textColor = settings.isDarkMode ? \"#ffffff\" : \"#0A0A0F\";\n    // Handle case where container is too small\n    if (isContainerTooSmall) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"w-full h-full flex items-center justify-center \".concat(themeClass),\n            style: {\n                backgroundColor\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-center\",\n                style: {\n                    color: textColor\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-lg mb-2\",\n                        children: \"Container too small\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                        lineNumber: 1821,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-sm opacity-70\",\n                        children: \"Minimum size: 100x100px\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                        lineNumber: 1822,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                lineNumber: 1820,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n            lineNumber: 1819,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full h-full flex flex-col items-center justify-center \".concat(themeClass),\n        style: {\n            backgroundColor\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_shared_GlobalControlsNav__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                lineNumber: 1830,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full h-full flex flex-col items-center justify-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full flex flex-col items-center justify-center mb-4\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_shared_QuestionSelector__WEBPACK_IMPORTED_MODULE_4__.QuestionSelector, {\n                            availableFields: availableFields,\n                            currentSource: currentSource,\n                            currentTarget: currentTarget,\n                            onChange: (source, target)=>{\n                                const corrected = ensureDifferentCategories(source, target);\n                                setCurrentSource(corrected.source);\n                                setCurrentTarget(corrected.target);\n                                setLastCategoryChange(corrected);\n                            }\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1833,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                        lineNumber: 1832,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full flex justify-center items-center relative\",\n                        style: {\n                            height: height * 0.85\n                        },\n                        children: [\n                            showSecondaryChord ? // Two-chord layout when peak performance is involved\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-full flex justify-center items-center gap-16\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex flex-col items-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                className: \"text-lg font-bold mb-4\",\n                                                style: {\n                                                    color: textColor\n                                                },\n                                                children: \"Main Relationships\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                                lineNumber: 1853,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                                ref: svgRef,\n                                                width: width * 0.45,\n                                                height: height * 0.8,\n                                                style: {\n                                                    display: \"block\",\n                                                    background: \"transparent\",\n                                                    color: textColor\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                                lineNumber: 1856,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                        lineNumber: 1852,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex flex-col items-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                className: \"text-lg font-bold mb-4\",\n                                                style: {\n                                                    color: textColor\n                                                },\n                                                children: \"Years \\xd7 Performance Types\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                                lineNumber: 1864,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                                ref: secondarySvgRef,\n                                                width: width * 0.45,\n                                                height: height * 0.8,\n                                                style: {\n                                                    display: \"block\",\n                                                    background: \"transparent\",\n                                                    color: textColor\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                                lineNumber: 1867,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                        lineNumber: 1863,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                lineNumber: 1851,\n                                columnNumber: 13\n                            }, this) : // Single chord layout when peak performance is not involved\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                ref: svgRef,\n                                width: width,\n                                height: height * 0.85,\n                                style: {\n                                    display: \"block\",\n                                    margin: \"0 auto\",\n                                    background: \"transparent\",\n                                    color: textColor\n                                }\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                lineNumber: 1877,\n                                columnNumber: 13\n                            }, this),\n                            tooltipEl\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                        lineNumber: 1845,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                lineNumber: 1831,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n        lineNumber: 1829,\n        columnNumber: 5\n    }, this);\n}\n_s(ChordDiagramInternal, \"peC16i84Ccx+IK/qKQcjQdugrE8=\", false, function() {\n    return [\n        _shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_3__.useVisualizationData,\n        _lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__.useAppContext\n    ];\n});\n_c = ChordDiagramInternal;\nfunction ChordDiagram(props) {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ErrorBoundary, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChordDiagramInternal, {\n            ...props\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n            lineNumber: 1894,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n        lineNumber: 1893,\n        columnNumber: 5\n    }, this);\n}\n_c1 = ChordDiagram;\nvar _c, _c1;\n$RefreshReg$(_c, \"ChordDiagramInternal\");\n$RefreshReg$(_c1, \"ChordDiagram\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0RhdGFWaXN1YWxpemF0aW9uL0Nob3JkRGlhZ3JhbS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUV5RztBQUNoRjtBQUU0QztBQUdSO0FBV2hDO0FBQzRCO0FBQ2E7QUFDZjtBQVd2RCxvRUFBb0U7QUFDcEUsU0FBU2EsYUFBYUMsUUFBZ0IsRUFBRUMsUUFBZ0IsRUFBRUMsWUFBaUI7UUFBRUMsYUFBQUEsaUVBQXNCO0lBQ2pHLE1BQU1DLGNBQWNELGFBQWFELGFBQWFHLElBQUksR0FBR0gsYUFBYUksS0FBSztJQUV2RSxJQUFJTCxhQUFhLHNCQUFzQjtZQUM5Qkc7UUFBUCxPQUFPQSxFQUFBQSxrQ0FBQUEsWUFBWUcsa0JBQWtCLGNBQTlCSCxzREFBQUEsK0JBQWdDLENBQUNKLFNBQVMsS0FBSTtJQUN2RDtJQUVBLGlFQUFpRTtJQUNqRSxJQUFJQyxhQUFhLGtCQUFrQjtZQUMxQkc7UUFBUCxPQUFPQSxFQUFBQSw4QkFBQUEsWUFBWUksY0FBYyxjQUExQkosa0RBQUFBLDJCQUE0QixDQUFDSixTQUFTLEtBQUk7SUFDbkQ7SUFDQSxJQUFJQyxhQUFhLG9CQUFvQjtZQUM1Qkc7UUFBUCxPQUFPQSxFQUFBQSxnQ0FBQUEsWUFBWUssZ0JBQWdCLGNBQTVCTCxvREFBQUEsNkJBQThCLENBQUNKLFNBQVMsS0FBSTtJQUNyRDtJQUNBLElBQUlDLGFBQWEsY0FBYztZQUN0Qkc7UUFBUCxPQUFPQSxFQUFBQSwwQkFBQUEsWUFBWU0sVUFBVSxjQUF0Qk4sOENBQUFBLHVCQUF3QixDQUFDSixTQUFTLEtBQUk7SUFDL0M7SUFDQSxJQUFJQyxhQUFhLGFBQWE7WUFDckJHO1FBQVAsT0FBT0EsRUFBQUEseUJBQUFBLFlBQVlPLFNBQVMsY0FBckJQLDZDQUFBQSxzQkFBdUIsQ0FBQ0osU0FBUyxLQUFJO0lBQzlDO0lBQ0EsT0FBTztBQUNUO0FBRUEsNkNBQTZDO0FBQzdDLDRGQUE0RjtBQUU1Riwr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QUFFQyxPQUFPcVM7Z0RBQVU7MERBQUc7Ozs7OzswREFHcEUsOERBQUNyTztnREFDQzBPLEtBQUs5UjtnREFDTE4sT0FBT0EsUUFBUTtnREFDZkMsUUFBUUEsU0FBUztnREFDakJSLE9BQU87b0RBQUU0UyxTQUFTO29EQUFTbEIsWUFBWTtvREFBZXpSLE9BQU9xUztnREFBVTs7Ozs7Ozs7Ozs7O2tEQUczRSw4REFBQ3ZTO3dDQUFJd1MsV0FBVTs7MERBQ2IsOERBQUNHO2dEQUFHSCxXQUFVO2dEQUF5QnZTLE9BQU87b0RBQUVDLE9BQU9xUztnREFBVTswREFBRzs7Ozs7OzBEQUdwRSw4REFBQ3JPO2dEQUNDME8sS0FBSzdSO2dEQUNMUCxPQUFPQSxRQUFRO2dEQUNmQyxRQUFRQSxTQUFTO2dEQUNqQlIsT0FBTztvREFBRTRTLFNBQVM7b0RBQVNsQixZQUFZO29EQUFlelIsT0FBT3FTO2dEQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FLN0UsNERBQTREOzBDQUM1RCw4REFBQ3JPO2dDQUNDME8sS0FBSzlSO2dDQUNMTixPQUFPQTtnQ0FDUEMsUUFBUUEsU0FBUztnQ0FDakJSLE9BQU87b0NBQUU0UyxTQUFTO29DQUFTN0csUUFBUTtvQ0FBVTJGLFlBQVk7b0NBQWV6UixPQUFPcVM7Z0NBQVU7Ozs7Ozs0QkFHNUZkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS1g7R0E3d0RTbFI7O1FBVTRCckMsOEVBQW9CQTtRQUtsQ0ksa0VBQWFBOzs7S0FmM0JpQztBQSt3RE0sU0FBU3VTLGFBQWExUyxLQUF3QjtJQUMzRCxxQkFDRSw4REFBQ2Q7a0JBQ0MsNEVBQUNpQjtZQUFzQixHQUFHSCxLQUFLOzs7Ozs7Ozs7OztBQUdyQztNQU53QjBTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0RhdGFWaXN1YWxpemF0aW9uL0Nob3JkRGlhZ3JhbS50c3g/NmQ2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCBDb21wb25lbnQsIEVycm9ySW5mbywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHsgYXJjIH0gZnJvbSAnZDMtc2hhcGUnO1xuaW1wb3J0IHsgdXNlVmlzdWFsaXphdGlvbkRhdGEgfSBmcm9tICcuL3NoYXJlZC91c2VWaXN1YWxpemF0aW9uRGF0YSc7XG5pbXBvcnQgeyBWaXN1YWxpemF0aW9uQ29udGFpbmVyIH0gZnJvbSAnLi9zaGFyZWQvVmlzdWFsaXphdGlvbkNvbnRhaW5lcic7XG5pbXBvcnQgeyBEYXRhSW5zaWdodFBhbmVsIH0gZnJvbSAnLi9zaGFyZWQvRGF0YUluc2lnaHRQYW5lbCc7XG5pbXBvcnQgeyBRdWVzdGlvblNlbGVjdG9yIH0gZnJvbSAnLi9zaGFyZWQvUXVlc3Rpb25TZWxlY3Rvcic7XG5pbXBvcnQgeyBcbiAgcHJvY2Vzc0Nob3JkRGF0YSwgXG4gIGNob3JkQ29uZmlnLCBcbiAgY3ljbGluZ01vZGVzLCBcbiAgZ2V0Q2hvcmRDb2xvcixcbiAgY2hvcmRBbmltYXRpb25zLFxuICBmaWx0ZXJDb25uZWN0ZWRDYXRlZ29yaWVzLFxuICB0eXBlIENob3JkTWF0cml4LFxuICB0eXBlIENob3JkR3JvdXAsXG4gIHR5cGUgQ2hvcmRMaW5rXG59IGZyb20gJy4vc2hhcmVkL2Nob3JkVXRpbHMnO1xuaW1wb3J0IHsgdXNlQXBwQ29udGV4dCB9IGZyb20gJ0AvbGliL2NvbnRleHQvQXBwQ29udGV4dCc7XG5pbXBvcnQgR2xvYmFsQ29udHJvbHNOYXYgZnJvbSAnQC9jb21wb25lbnRzL3NoYXJlZC9HbG9iYWxDb250cm9sc05hdic7XG5pbXBvcnQgeyBnZXRZZWFyc0NhdGVnb3J5IH0gZnJvbSAnLi9zaGFyZWQvY29sb3JVdGlscyc7XG5cbmludGVyZmFjZSBDaG9yZERpYWdyYW1Qcm9wcyB7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIGF1dG9QbGF5PzogYm9vbGVhbjtcbiAgb25SZWxhdGlvbnNoaXBDaGFuZ2U/OiAoc291cmNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nKSA9PiB2b2lkO1xuICBlbmFibGVSb3RhdGlvbj86IGJvb2xlYW47XG4gIHNob3dBbGxDb25uZWN0aW9ucz86IGJvb2xlYW47XG59XG5cbi8vIEhlbHBlciB0byBnZXQgY29sb3IgZm9yIGEgbm9kZSB1c2luZyBnbG9iYWwgY29udGV4dCAodGhlbWUtYXdhcmUpXG5mdW5jdGlvbiBnZXROb2RlQ29sb3Iobm9kZU5hbWU6IHN0cmluZywgY2F0ZWdvcnk6IHN0cmluZywgZ2xvYmFsQ29sb3JzOiBhbnksIGlzRGFya01vZGU6IGJvb2xlYW4gPSBmYWxzZSk6IHN0cmluZyB7XG4gIGNvbnN0IHRoZW1lQ29sb3JzID0gaXNEYXJrTW9kZSA/IGdsb2JhbENvbG9ycy5kYXJrIDogZ2xvYmFsQ29sb3JzLmxpZ2h0O1xuICBcbiAgaWYgKGNhdGVnb3J5ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgIHJldHVybiB0aGVtZUNvbG9ycy55ZWFyc19hdF9tZWR0cm9uaWM/Lltub2RlTmFtZV0gfHwgJyNGRjZCNkInO1xuICB9XG4gIFxuICAvLyBVc2UgZ2xvYmFsIGNvbG9ycyBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsYmFjayB0byBkZWZhdWx0c1xuICBpZiAoY2F0ZWdvcnkgPT09ICdsZWFybmluZ19zdHlsZScpIHtcbiAgICByZXR1cm4gdGhlbWVDb2xvcnMubGVhcm5pbmdfc3R5bGU/Lltub2RlTmFtZV0gfHwgJyM2MGE1ZmEnO1xuICB9XG4gIGlmIChjYXRlZ29yeSA9PT0gJ3BlYWtfcGVyZm9ybWFuY2UnKSB7XG4gICAgcmV0dXJuIHRoZW1lQ29sb3JzLnBlYWtfcGVyZm9ybWFuY2U/Lltub2RlTmFtZV0gfHwgJyM0RjhFRjcnO1xuICB9XG4gIGlmIChjYXRlZ29yeSA9PT0gJ21vdGl2YXRpb24nKSB7XG4gICAgcmV0dXJuIHRoZW1lQ29sb3JzLm1vdGl2YXRpb24/Lltub2RlTmFtZV0gfHwgJyM5NDY3YmQnO1xuICB9XG4gIGlmIChjYXRlZ29yeSA9PT0gJ3NoYXBlZF9ieScpIHtcbiAgICByZXR1cm4gdGhlbWVDb2xvcnMuc2hhcGVkX2J5Py5bbm9kZU5hbWVdIHx8ICcjMWY3N2I0JztcbiAgfVxuICByZXR1cm4gJyM4ODg0ZDgnO1xufVxuXG4vLyAtLS0gVHlwZVNjcmlwdCBUeXBlcyBmb3IgQ2hvcmQgRGlhZ3JhbSAtLS1cbi8vIChJZiB5b3UgYWxyZWFkeSBpbXBvcnQgQ2hvcmRHcm91cC9DaG9yZExpbmsgZnJvbSBzaGFyZWQvY2hvcmRVdGlscywgZG8gbm90IHJlZGVmaW5lIGhlcmUpXG5cbi8vIC0tLSBTaW1wbGUgRXJyb3IgQm91bmRhcnkgZm9yIFJvYnVzdG5lc3MgLS0tXG5cbmNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBDb21wb25lbnQ8eyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sIHsgaGFzRXJyb3I6IGJvb2xlYW4gfT4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgaGFzRXJyb3I6IGZhbHNlIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihfOiBFcnJvcikge1xuICAgIHJldHVybiB7IGhhc0Vycm9yOiB0cnVlIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3I6IEVycm9yLCBlcnJvckluZm86IEVycm9ySW5mbykge1xuICAgIC8vIExvZyBlcnJvciB0byBtb25pdG9yaW5nIHNlcnZpY2UgaWYgbmVlZGVkXG4gICAgY29uc29sZS5lcnJvcignQ2hvcmREaWFncmFtIEVycm9yQm91bmRhcnk6JywgZXJyb3IsIGVycm9ySW5mbyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmhhc0Vycm9yKSB7XG4gICAgICByZXR1cm4gPGRpdiBzdHlsZT17eyBjb2xvcjogJ3JlZCcsIHBhZGRpbmc6IDI0IH19PlNvbWV0aGluZyB3ZW50IHdyb25nIGluIHRoZSBDaG9yZCBEaWFncmFtLjwvZGl2PjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn1cblxuLy8gLS0tIE1haW4gQ2hvcmREaWFncmFtIHdyYXBwZWQgaW4gRXJyb3JCb3VuZGFyeSAtLS1cbmZ1bmN0aW9uIENob3JkRGlhZ3JhbUludGVybmFsKHtcbiAgd2lkdGggPSAxNDAwLFxuICBoZWlnaHQgPSAxMDAwLFxuICBhdXRvUGxheSA9IHRydWUsXG4gIG9uUmVsYXRpb25zaGlwQ2hhbmdlLFxuICBlbmFibGVSb3RhdGlvbiA9IHRydWUsXG4gIHNob3dBbGxDb25uZWN0aW9ucyA9IGZhbHNlLFxufTogQ2hvcmREaWFncmFtUHJvcHMpIHtcbiAgY29uc3Qgc3ZnUmVmID0gdXNlUmVmPFNWR1NWR0VsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBzZWNvbmRhcnlTdmdSZWYgPSB1c2VSZWY8U1ZHU1ZHRWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IHsgZGF0YSwgaXNMb2FkaW5nLCBlcnJvciB9ID0gdXNlVmlzdWFsaXphdGlvbkRhdGEoKTtcbiAgY29uc3QgW2N1cnJlbnRTb3VyY2UsIHNldEN1cnJlbnRTb3VyY2VdID0gdXNlU3RhdGUoY3ljbGluZ01vZGVzWzBdLnNvdXJjZSk7XG4gIGNvbnN0IFtjdXJyZW50VGFyZ2V0LCBzZXRDdXJyZW50VGFyZ2V0XSA9IHVzZVN0YXRlKGN5Y2xpbmdNb2Rlc1swXS50YXJnZXQpO1xuICBjb25zdCBbaW5zaWdodHMsIHNldEluc2lnaHRzXSA9IHVzZVN0YXRlPEFycmF5PHsgdGl0bGU6IHN0cmluZzsgdmFsdWU6IHN0cmluZzsgZGVzY3JpcHRpb24/OiBzdHJpbmcgfT4+KFtdKTtcbiAgY29uc3QgW3Rvb2x0aXAsIHNldFRvb2x0aXBdID0gdXNlU3RhdGU8eyB4OiBudW1iZXI7IHk6IG51bWJlcjsgY29udGVudDogUmVhY3QuUmVhY3ROb2RlIH0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdXNlQXBwQ29udGV4dCgpO1xuICBjb25zdCBbbGFzdENhdGVnb3J5Q2hhbmdlLCBzZXRMYXN0Q2F0ZWdvcnlDaGFuZ2VdID0gdXNlU3RhdGU8eyBzb3VyY2U6IHN0cmluZzsgdGFyZ2V0OiBzdHJpbmcgfT4oeyBzb3VyY2U6IGN1cnJlbnRTb3VyY2UsIHRhcmdldDogY3VycmVudFRhcmdldCB9KTtcbiAgY29uc3QgW3Nob3dTZWNvbmRhcnlDaG9yZCwgc2V0U2hvd1NlY29uZGFyeUNob3JkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgXG4gIC8vIEFuaW1hdGlvbiBzdGF0ZSBtYW5hZ2VtZW50IChzaW1pbGFyIHRvIEFsbHV2aWFsRGlhZ3JhbSlcbiAgY29uc3QgW2FuaW1hdGlvblBoYXNlLCBzZXRBbmltYXRpb25QaGFzZV0gPSB1c2VTdGF0ZTwnZnVsbCcgfCAnaGlnaGxpZ2h0aW5nJyB8ICd0cmFuc2l0aW9uaW5nJz4oJ2Z1bGwnKTtcbiAgY29uc3QgW2hpZ2hsaWdodGVkQXJjSW5kZXgsIHNldEhpZ2hsaWdodGVkQXJjSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtoaWdobGlnaHRlZFNpZGUsIHNldEhpZ2hsaWdodGVkU2lkZV0gPSB1c2VTdGF0ZTwnbGVmdCcgfCAncmlnaHQnIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpc0FuaW1hdGluZywgc2V0SXNBbmltYXRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIFxuICAvLyBTZWNvbmRhcnkgY2hvcmQgYW5pbWF0aW9uIHN0YXRlXG4gIGNvbnN0IFtzZWNvbmRhcnlBbmltYXRpb25QaGFzZSwgc2V0U2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2VdID0gdXNlU3RhdGU8J2Z1bGwnIHwgJ2hpZ2hsaWdodGluZycgfCAndHJhbnNpdGlvbmluZyc+KCdmdWxsJyk7XG4gIGNvbnN0IFtzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4LCBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4XSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRTaWRlLCBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZFNpZGVdID0gdXNlU3RhdGU8J2xlZnQnIHwgJ3JpZ2h0JyB8IG51bGw+KG51bGwpO1xuICBcbiAgLy8gQW5pbWF0aW9uIHRpbWluZyByZWZcbiAgY29uc3QgYW5pbWF0aW9uUmVmID0gdXNlUmVmPHtcbiAgICB0aW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsO1xuICAgIHJ1bm5pbmc6IGJvb2xlYW47XG4gICAgY3VycmVudEluZGV4OiBudW1iZXI7XG4gICAgY3VycmVudFNpZGU6ICdsZWZ0JyB8ICdyaWdodCc7XG4gICAgaXNQYXVzZWQ6IGJvb2xlYW47XG4gICAgY3ljbGVDb3VudDogbnVtYmVyO1xuICB9Pih7XG4gICAgdGltZXI6IG51bGwsXG4gICAgcnVubmluZzogZmFsc2UsXG4gICAgY3VycmVudEluZGV4OiAwLFxuICAgIGN1cnJlbnRTaWRlOiAnbGVmdCcsXG4gICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgIGN5Y2xlQ291bnQ6IDBcbiAgfSk7XG5cbiAgLy8gU2Vjb25kYXJ5IGNob3JkIGFuaW1hdGlvbiB0aW1pbmcgcmVmXG4gIGNvbnN0IHNlY29uZGFyeUFuaW1hdGlvblJlZiA9IHVzZVJlZjx7XG4gICAgdGltZXI6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbDtcbiAgICBydW5uaW5nOiBib29sZWFuO1xuICAgIGN1cnJlbnRJbmRleDogbnVtYmVyO1xuICAgIGN1cnJlbnRTaWRlOiAnbGVmdCcgfCAncmlnaHQnO1xuICAgIGlzUGF1c2VkOiBib29sZWFuO1xuICB9Pih7XG4gICAgdGltZXI6IG51bGwsXG4gICAgcnVubmluZzogZmFsc2UsXG4gICAgY3VycmVudEluZGV4OiAwLFxuICAgIGN1cnJlbnRTaWRlOiAnbGVmdCcsXG4gICAgaXNQYXVzZWQ6IGZhbHNlXG4gIH0pO1xuXG4gIC8vIERlZmluZSBhdmFpbGFibGUgZmllbGRzIGZvciB0aGUgc2VsZWN0b3JcbiAgY29uc3QgYXZhaWxhYmxlRmllbGRzID0gW1xuICAgIHsgdmFsdWU6ICd5ZWFyc19hdF9tZWR0cm9uaWMnLCBsYWJlbDogJ1llYXJzIGF0IE1lZHRyb25pYycgfSxcbiAgICB7IHZhbHVlOiAncGVha19wZXJmb3JtYW5jZScsIGxhYmVsOiAnUGVhayBQZXJmb3JtYW5jZScgfSxcbiAgICB7IHZhbHVlOiAnbGVhcm5pbmdfc3R5bGUnLCBsYWJlbDogJ0xlYXJuaW5nIFN0eWxlJyB9LFxuICAgIHsgdmFsdWU6ICdtb3RpdmF0aW9uJywgbGFiZWw6ICdNb3RpdmF0aW9uJyB9LFxuICAgIHsgdmFsdWU6ICdzaGFwZWRfYnknLCBsYWJlbDogJ1NoYXBlZCBCeScgfVxuICBdO1xuXG4gIC8vIFR5cG9ncmFwaHkgY29uc3RhbnRzICh0aGVtZS1hd2FyZSlcbiAgY29uc3QgbGFiZWxGb250U2l6ZSA9IDIwO1xuICBjb25zdCBsYWJlbEZvbnRXZWlnaHQgPSA3MDA7XG4gIGNvbnN0IGxhYmVsQ29sb3IgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJyNmZmZmZmYnIDogJyMxNzBGNUYnO1xuICBjb25zdCBsYWJlbEZvbnRGYW1pbHkgPSAnQXZlbmlyIE5leHQgV29ybGQsIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTRiBQcm9cIiwgXCJSb2JvdG9cIiwgc2Fucy1zZXJpZic7XG5cbiAgLy8gQ2hlY2sgaWYgcGVhayBwZXJmb3JtYW5jZSBpcyBpbnZvbHZlZCBhbmQgc2hvdyBzZWNvbmRhcnkgY2hvcmRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpc1BlYWtQZXJmb3JtYW5jZUludm9sdmVkID0gY3VycmVudFNvdXJjZSA9PT0gJ3BlYWtfcGVyZm9ybWFuY2UnIHx8IGN1cnJlbnRUYXJnZXQgPT09ICdwZWFrX3BlcmZvcm1hbmNlJztcbiAgICBzZXRTaG93U2Vjb25kYXJ5Q2hvcmQoaXNQZWFrUGVyZm9ybWFuY2VJbnZvbHZlZCk7XG4gIH0sIFtjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0XSk7XG5cbiAgLy8gU2Vjb25kYXJ5IGNob3JkIGRpYWdyYW0gZm9yIHBlYWsgcGVyZm9ybWFuY2UgYnJlYWtkb3duXG4gIGNvbnN0IHJlbmRlclNlY29uZGFyeUNob3JkID0gKCkgPT4ge1xuICAgIGlmICghc2Vjb25kYXJ5U3ZnUmVmLmN1cnJlbnQgfHwgIWRhdGEubGVuZ3RoIHx8IGlzTG9hZGluZykgcmV0dXJuO1xuXG4gICAgY29uc3Qgc3ZnID0gZDMuc2VsZWN0KHNlY29uZGFyeVN2Z1JlZi5jdXJyZW50KTtcbiAgICBzdmcuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG5cbiAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBzZXR0aW5ncy51c2VUZXN0RGF0YSBcbiAgICAgID8gZGF0YSBcbiAgICAgIDogZGF0YS5maWx0ZXIoaXRlbSA9PiAhKGl0ZW0gYXMgYW55KS50ZXN0X2RhdGEpO1xuXG4gICAgLy8gR2V0IGFsbCBkYXRhIGZvciBzZWNvbmRhcnkgY2hvcmQgKFllYXJzIGF0IE1lZHRyb25pYyB2cyBQZWFrIFBlcmZvcm1hbmNlIGNhdGVnb3JpZXMpXG4gICAgY29uc3Qgc2Vjb25kYXJ5RGF0YSA9IGZpbHRlcmVkRGF0YS5maWx0ZXIoZCA9PiAoZCBhcyBhbnkpLnBlYWtfcGVyZm9ybWFuY2UpO1xuICAgIFxuICAgIGlmIChzZWNvbmRhcnlEYXRhLmxlbmd0aCA8IDUpIHJldHVybjtcblxuICAgIC8vIFVzZSBzYW1lIGRpbWVuc2lvbnMgYXMgbWFpbiBjaG9yZCBmb3IgY29uc2lzdGVuY3lcbiAgICBjb25zdCBzZWNvbmRhcnlXaWR0aCA9IHNob3dTZWNvbmRhcnlDaG9yZCA/IHdpZHRoICogMC40NSA6IHdpZHRoO1xuICAgIGNvbnN0IHNlY29uZGFyeUhlaWdodCA9IHNob3dTZWNvbmRhcnlDaG9yZCA/IGhlaWdodCAqIDAuOCA6IGhlaWdodCAqIDAuODU7XG4gICAgY29uc3Qgc2Vjb25kYXJ5TWFyZ2luID0geyB0b3A6IDgwLCByaWdodDogODAsIGJvdHRvbTogMTAwLCBsZWZ0OiA4MCB9O1xuICAgIGNvbnN0IHNlY29uZGFyeUNoYXJ0V2lkdGggPSBzZWNvbmRhcnlXaWR0aCAtIHNlY29uZGFyeU1hcmdpbi5sZWZ0IC0gc2Vjb25kYXJ5TWFyZ2luLnJpZ2h0O1xuICAgIGNvbnN0IHNlY29uZGFyeUNoYXJ0SGVpZ2h0ID0gc2Vjb25kYXJ5SGVpZ2h0IC0gc2Vjb25kYXJ5TWFyZ2luLnRvcCAtIHNlY29uZGFyeU1hcmdpbi5ib3R0b207XG4gICAgY29uc3Qgc2Vjb25kYXJ5UmFkaXVzID0gTWF0aC5tYXgoMTIwLCBNYXRoLm1pbihzZWNvbmRhcnlDaGFydFdpZHRoLCBzZWNvbmRhcnlDaGFydEhlaWdodCkgLyAyIC0gNjApO1xuXG4gICAgLy8gWWVhcnMgY2F0ZWdvcmllcyBhbmQgUGVhayBQZXJmb3JtYW5jZSBjYXRlZ29yaWVzXG4gICAgY29uc3QgeWVhcnNDYXRlZ29yaWVzID0gWycwLTUnLCAnNi0xMCcsICcxMS0xNScsICcxNi0yMCcsICcyMCsnXTtcbiAgICBjb25zdCBwZWFrUGVyZkNhdGVnb3JpZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoc2Vjb25kYXJ5RGF0YS5tYXAoZCA9PiAoZCBhcyBhbnkpLnBlYWtfcGVyZm9ybWFuY2UpKSkuZmlsdGVyKEJvb2xlYW4pLnNvcnQoKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYmlwYXJ0aXRlIG1hdHJpeDogWWVhcnMgdnMgUGVhayBQZXJmb3JtYW5jZVxuICAgIGNvbnN0IGFsbENhdGVnb3JpZXMgPSBbLi4ueWVhcnNDYXRlZ29yaWVzLCAuLi5wZWFrUGVyZkNhdGVnb3JpZXNdO1xuICAgIGNvbnN0IG1hdHJpeCA9IGFsbENhdGVnb3JpZXMubWFwKChzb3VyY2VDYXRlZ29yeSwgc291cmNlSW5kZXgpID0+IFxuICAgICAgYWxsQ2F0ZWdvcmllcy5tYXAoKHRhcmdldENhdGVnb3J5LCB0YXJnZXRJbmRleCkgPT4ge1xuICAgICAgICAvLyBPbmx5IGNyZWF0ZSBjb25uZWN0aW9ucyBiZXR3ZWVuIHllYXJzIGFuZCBwZWFrIHBlcmZvcm1hbmNlIChub3Qgd2l0aGluIHNhbWUgdHlwZSlcbiAgICAgICAgY29uc3Qgc291cmNlSXNZZWFycyA9IHNvdXJjZUluZGV4IDwgeWVhcnNDYXRlZ29yaWVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNZZWFycyA9IHRhcmdldEluZGV4IDwgeWVhcnNDYXRlZ29yaWVzLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIC8vIE9ubHkgY29ubmVjdCB5ZWFycyB0byBwZWFrIHBlcmZvcm1hbmNlXG4gICAgICAgIGlmIChzb3VyY2VJc1llYXJzID09PSB0YXJnZXRJc1llYXJzKSByZXR1cm4gMDtcbiAgICAgICAgXG4gICAgICAgIC8vIENvdW50IHBlb3BsZSB3aG8gbWF0Y2ggdGhpcyB5ZWFyICsgcGVyZm9ybWFuY2UgY29tYmluYXRpb25cbiAgICAgICAgY29uc3QgeWVhcnNDYXQgPSBzb3VyY2VJc1llYXJzID8gc291cmNlQ2F0ZWdvcnkgOiB0YXJnZXRDYXRlZ29yeTtcbiAgICAgICAgY29uc3QgcGVyZkNhdCA9IHNvdXJjZUlzWWVhcnMgPyB0YXJnZXRDYXRlZ29yeSA6IHNvdXJjZUNhdGVnb3J5O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlY29uZGFyeURhdGEuZmlsdGVyKGQgPT4ge1xuICAgICAgICAgIGNvbnN0IHllYXJzID0gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKTtcbiAgICAgICAgICBjb25zdCBwZXJmID0gKGQgYXMgYW55KS5wZWFrX3BlcmZvcm1hbmNlO1xuICAgICAgICAgIHJldHVybiB5ZWFycyA9PT0geWVhcnNDYXQgJiYgcGVyZiA9PT0gcGVyZkNhdDtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gQ3JlYXRlIGNob3JkIGxheW91dFxuICAgIGNvbnN0IGNob3JkTGF5b3V0ID0gZDMuY2hvcmQoKS5wYWRBbmdsZSgwLjA1KTtcbiAgICBjb25zdCBjaG9yZERhdGEgPSBjaG9yZExheW91dChtYXRyaXgpO1xuXG4gICAgY29uc3QgZyA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7c2Vjb25kYXJ5TWFyZ2luLmxlZnQgKyBzZWNvbmRhcnlDaGFydFdpZHRoIC8gMn0sICR7c2Vjb25kYXJ5TWFyZ2luLnRvcCArIHNlY29uZGFyeUNoYXJ0SGVpZ2h0IC8gMn0pYCk7XG5cbiAgICAvLyBEcmF3IGFyY3NcbiAgICBjb25zdCBhcmMgPSBkMy5hcmMoKVxuICAgICAgLmlubmVyUmFkaXVzKHNlY29uZGFyeVJhZGl1cyAqIDAuNzUpXG4gICAgICAub3V0ZXJSYWRpdXMoc2Vjb25kYXJ5UmFkaXVzICogMC45NSk7XG5cbiAgICBjb25zdCByaWJib24gPSBkMy5yaWJib24oKS5yYWRpdXMoc2Vjb25kYXJ5UmFkaXVzICogMC43NSk7XG5cbiAgICAvLyBDb2xvcnM6IGRpZmZlcmVudCBodWVzIGZvciB5ZWFycyB2cyBwZWFrIHBlcmZvcm1hbmNlIHR5cGVzXG4gICAgY29uc3QgeWVhcnNDb2xvcnMgPSBbJyMwMDc3Q0MnLCAnIzAwQTNFMCcsICcjNEZDM0Y3JywgJyM4MUM3ODQnLCAnI0FFRDU4MSddOyAvLyBCbHVlcy9HcmVlbnMgZm9yIHllYXJzXG4gICAgY29uc3QgcGVyZkNvbG9ycyA9IFsnI0ZGNkI2QicsICcjRkZEMTY2JywgJyMwNkQ2QTAnLCAnIzExOEFCMicsICcjRkY5RjFDJywgJyM0RUNEQzQnXTsgLy8gVmFyaW91cyBjb2xvcnMgZm9yIHBlcmZvcm1hbmNlIHR5cGVzXG4gICAgY29uc3QgY29sb3JzID0gWy4uLnllYXJzQ29sb3JzLCAuLi5wZXJmQ29sb3JzLnNsaWNlKDAsIHBlYWtQZXJmQ2F0ZWdvcmllcy5sZW5ndGgpXTtcblxuICAgIC8vIERyYXcgZ3JvdXBzIChhcmNzKSB3aXRoIGFuaW1hdGlvbiBhbmQgaG92ZXIgZWZmZWN0c1xuICAgIGNvbnN0IGdyb3VwU2VsZWN0aW9uID0gZy5zZWxlY3RBbGwoJy5jaG9yZC1ncm91cCcpXG4gICAgICAuZGF0YShjaG9yZERhdGEuZ3JvdXBzKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Nob3JkLWdyb3VwJylcbiAgICAgIC5hdHRyKCdkJywgYXJjIGFzIGFueSlcbiAgICAgIC5zdHlsZSgnZmlsbCcsIChkLCBpKSA9PiBjb2xvcnNbaSAlIGNvbG9ycy5sZW5ndGhdKVxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcbiAgICAgIC5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKGV2ZW50LCBkOiBhbnkpIHtcbiAgICAgICAgcGF1c2VBbmltYXRpb24oJ3NlY29uZGFyeSBhcmMgaG92ZXInKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyaWdnZXIgaGlnaGxpZ2h0aW5nIGZvciBzZWNvbmRhcnkgY2hvcmRcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gU2Vjb25kYXJ5IGNob3JkIGFyYyBob3ZlcjonLCB7XG4gICAgICAgICAgZ3JvdXBJbmRleDogZC5pbmRleCxcbiAgICAgICAgICBjYXRlZ29yeTogYWxsQ2F0ZWdvcmllc1tkLmluZGV4XVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHNldFNlY29uZGFyeUFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleChkLmluZGV4KTtcbiAgICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRTaWRlKGQuaW5kZXggPCB5ZWFyc0NhdGVnb3JpZXMubGVuZ3RoID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgICAgIFxuICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICB4OiBldmVudC5wYWdlWCxcbiAgICAgICAgICB5OiBldmVudC5wYWdlWSxcbiAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdib2xkJywgbWFyZ2luQm90dG9tOiA0IH19PnthbGxDYXRlZ29yaWVzW2QuaW5kZXhdPy50b1N0cmluZygpLnJlcGxhY2UoL18vZywgJyAnKSB8fCAnJ308L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdj57ZC5pbmRleCA8IHllYXJzQ2F0ZWdvcmllcy5sZW5ndGggPyAnWWVhcnMgYXQgTWVkdHJvbmljJyA6ICdQZWFrIFBlcmZvcm1hbmNlIFR5cGUnfTwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2PlZhbHVlOiB7ZC52YWx1ZX08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLm9uKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgICAgICByZXN1bWVBbmltYXRpb24oJ3NlY29uZGFyeSBhcmMgaG92ZXIgZW5kJyk7XG4gICAgICAgIHNldFRvb2x0aXAobnVsbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXNldCBoaWdobGlnaHRpbmcgd2hlbiBhbmltYXRpb24gcmVzdW1lc1xuICAgICAgICBzZXRTZWNvbmRhcnlBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4KG51bGwpO1xuICAgICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZFNpZGUobnVsbCk7XG4gICAgICB9KTtcblxuICAgIC8vIEFwcGx5IHRyYW5zaXRpb24gYW5pbWF0aW9ucyB0byBncm91cHNcbiAgICBncm91cFNlbGVjdGlvblxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDc1MClcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIChkLCBpKSA9PiB7XG4gICAgICAgIC8vIEFwcGx5IGZ1bGwgcmVsYXRpb25zaGlwIGNoYWluIGhpZ2hsaWdodGluZ1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGkpIHtcbiAgICAgICAgICAgIHJldHVybiAxLjA7IC8vIFNvdXJjZSBhcmMgaXMgZnVsbHkgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBhcmMgaXMgY29ubmVjdGVkIHRvIHRoZSBoaWdobGlnaHRlZCBhcmNcbiAgICAgICAgICBpZiAoc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBjaG9yZERhdGEuc29tZShjaG9yZCA9PiBcbiAgICAgICAgICAgICAgKGNob3JkLnNvdXJjZS5pbmRleCA9PT0gaSAmJiBjaG9yZC50YXJnZXQuaW5kZXggPT09IHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXgpIHx8XG4gICAgICAgICAgICAgIChjaG9yZC5zb3VyY2UuaW5kZXggPT09IHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggJiYgY2hvcmQudGFyZ2V0LmluZGV4ID09PSBpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBpc0Nvbm5lY3RlZCA/IDAuOTUgOiAwLjM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwLjg7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAoZCwgaSkgPT4ge1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnICYmIHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGkpIHtcbiAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoJ3N0cm9rZScsIChkLCBpKSA9PiB7XG4gICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycgJiYgc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gaSkge1xuICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScgOiAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgfSk7XG5cbiAgICAvLyBEcmF3IGNob3JkcyAocmliYm9ucykgd2l0aCBhbmltYXRpb24gYW5kIGhvdmVyIGVmZmVjdHNcbiAgICBjb25zdCBjaG9yZFNlbGVjdGlvbiA9IGcuc2VsZWN0QWxsKCcuY2hvcmQnKVxuICAgICAgLmRhdGEoY2hvcmREYXRhKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Nob3JkJylcbiAgICAgIC5hdHRyKCdkJywgcmliYm9uIGFzIGFueSlcbiAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gY29sb3JzW2Quc291cmNlLmluZGV4ICUgY29sb3JzLmxlbmd0aF0pXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxuICAgICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZXZlbnQ6IGFueSwgZDogYW55KSB7XG4gICAgICAgIHBhdXNlQW5pbWF0aW9uKCdzZWNvbmRhcnkgcmliYm9uIGhvdmVyJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmlnZ2VyIGhpZ2hsaWdodGluZyBmb3IgdGhlIHNvdXJjZSBzaWRlIG9mIHRoaXMgcmliYm9uXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn46vIFNlY29uZGFyeSByaWJib24gaG92ZXI6Jywge1xuICAgICAgICAgIHNvdXJjZUluZGV4OiBkLnNvdXJjZS5pbmRleCxcbiAgICAgICAgICB0YXJnZXRJbmRleDogZC50YXJnZXQuaW5kZXgsXG4gICAgICAgICAgc291cmNlQ2F0ZWdvcnk6IGFsbENhdGVnb3JpZXNbZC5zb3VyY2UuaW5kZXhdLFxuICAgICAgICAgIHRhcmdldENhdGVnb3J5OiBhbGxDYXRlZ29yaWVzW2QudGFyZ2V0LmluZGV4XVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHNldFNlY29uZGFyeUFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleChkLnNvdXJjZS5pbmRleCk7XG4gICAgICAgIHNldFNlY29uZGFyeUhpZ2hsaWdodGVkU2lkZShkLnNvdXJjZS5pbmRleCA8IHllYXJzQ2F0ZWdvcmllcy5sZW5ndGggPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgXG4gICAgICAgIHNldFRvb2x0aXAoe1xuICAgICAgICAgIHg6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgIHk6IGV2ZW50LnBhZ2VZLFxuICAgICAgICAgIGNvbnRlbnQ6IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5Cb3R0b206IDQgfX0+XG4gICAgICAgICAgICAgICAge2FsbENhdGVnb3JpZXNbZC5zb3VyY2UuaW5kZXhdfSDihpQge2FsbENhdGVnb3JpZXNbZC50YXJnZXQuaW5kZXhdfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdj5Db25uZWN0aW9uczoge2Quc291cmNlLnZhbHVlfTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzdW1lQW5pbWF0aW9uKCdzZWNvbmRhcnkgcmliYm9uIGhvdmVyIGVuZCcpO1xuICAgICAgICBzZXRUb29sdGlwKG51bGwpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgaGlnaGxpZ2h0aW5nIHdoZW4gYW5pbWF0aW9uIHJlc3VtZXNcbiAgICAgICAgc2V0U2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleChudWxsKTtcbiAgICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRTaWRlKG51bGwpO1xuICAgICAgfSk7XG5cbiAgICAvLyBBcHBseSB0cmFuc2l0aW9uIGFuaW1hdGlvbnMgdG8gY2hvcmRzXG4gICAgY2hvcmRTZWxlY3Rpb25cbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbig3NTApXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCBkID0+IHtcbiAgICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnNvdXJjZS5pbmRleCB8fCBzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnRhcmdldC5pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDAuOTU7IC8vIE1ha2UgY29ubmVjdGVkIHJpYmJvbnMgdmVyeSBwcm9taW5lbnRcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDAuMjsgLy8gRGltIG5vbi1jb25uZWN0ZWQgcmliYm9uc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMC43IDogMC42O1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgKGQ6IGFueSkgPT4ge1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQuc291cmNlLmluZGV4IHx8IHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQudGFyZ2V0LmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gMi41O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMC41O1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZCA9PiB7XG4gICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXggfHwgc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScgOiAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG4gICAgLy8gQWRkIGxhYmVscyB3aXRoIHByb3BlciBzcGFjaW5nIGFuZCByb3RhdGlvblxuICAgIGNvbnN0IHNlY29uZGFyeUxhYmVsUmFkaXVzID0gTWF0aC5tYXgoMTIwLCBzZWNvbmRhcnlSYWRpdXMgKiAxLjQ1KTtcbiAgICBnLnNlbGVjdEFsbCgnLmNob3JkLWxhYmVsJylcbiAgICAgIC5kYXRhKGNob3JkRGF0YS5ncm91cHMpXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAnY2hvcmQtbGFiZWwnKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgY29uc3QgeCA9IHNlY29uZGFyeUxhYmVsUmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBjb25zdCB5ID0gc2Vjb25kYXJ5TGFiZWxSYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gYW5nbGUgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICBcbiAgICAgICAgLy8gUm90YXRlIHRleHQgZm9yIGJldHRlciByZWFkYWJpbGl0eVxuICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiB8fCBhbmdsZSA8IC1NYXRoLlBJIC8gMikge1xuICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pIHJvdGF0ZSgke3JvdGF0aW9uICsgMTgwfSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pIHJvdGF0ZSgke3JvdGF0aW9ufSlgO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgZCA9PiB7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gKGQuc3RhcnRBbmdsZSArIGQuZW5kQW5nbGUpIC8gMiAtIE1hdGguUEkgLyAyO1xuICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiB8fCBhbmdsZSA8IC1NYXRoLlBJIC8gMikge1xuICAgICAgICAgIHJldHVybiAnZW5kJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcbiAgICAgIC5zdHlsZSgnZm9udC1mYW1pbHknLCBsYWJlbEZvbnRGYW1pbHkpXG4gICAgICAuc3R5bGUoJ2ZvbnQtd2VpZ2h0JywgbGFiZWxGb250V2VpZ2h0KVxuICAgICAgLnN0eWxlKCdmb250LXNpemUnLCBkID0+IHtcbiAgICAgICAgLy8gRHluYW1pYyBmb250IHNpemUgYmFzZWQgb24gbnVtYmVyIG9mIGxhYmVsc1xuICAgICAgICBjb25zdCB0b3RhbExhYmVscyA9IGFsbENhdGVnb3JpZXMubGVuZ3RoO1xuICAgICAgICBpZiAodG90YWxMYWJlbHMgPiAxMikgcmV0dXJuICcxM3B4JztcbiAgICAgICAgaWYgKHRvdGFsTGFiZWxzID4gMTApIHJldHVybiAnMTRweCc7XG4gICAgICAgIGlmICh0b3RhbExhYmVscyA+IDgpIHJldHVybiAnMTVweCc7XG4gICAgICAgIHJldHVybiAnMTZweCc7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdmaWxsJywgbGFiZWxDb2xvcilcbiAgICAgIC5zdHlsZSgndGV4dC10cmFuc2Zvcm0nLCAndXBwZXJjYXNlJylcbiAgICAgIC50ZXh0KChkLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBhbGxDYXRlZ29yaWVzW2ldPy50b1N0cmluZygpLnJlcGxhY2UoL18vZywgJyAnKSB8fCAnJztcbiAgICAgICAgLy8gU2hvdyBmdWxsIHRleHQgZm9yIHNlY29uZGFyeSBjaG9yZCBsYWJlbHNcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9KVxuICAgICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZXZlbnQsIGQpIHtcbiAgICAgICAgY29uc3QgZnVsbFRleHQgPSBhbGxDYXRlZ29yaWVzW2QuaW5kZXhdPy50b1N0cmluZygpLnJlcGxhY2UoL18vZywgJyAnKSB8fCAnJztcbiAgICAgICAgc2V0VG9vbHRpcCh7XG4gICAgICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgeTogZXZlbnQucGFnZVksXG4gICAgICAgICAgY29udGVudDogKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcsIG1hcmdpbkJvdHRvbTogNCB9fT57ZnVsbFRleHR9PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXY+e2QuaW5kZXggPCB5ZWFyc0NhdGVnb3JpZXMubGVuZ3RoID8gJ1llYXJzIGF0IE1lZHRyb25pYycgOiAnUGVhayBQZXJmb3JtYW5jZSBUeXBlJ308L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLm9uKCdtb3VzZWxlYXZlJywgKCkgPT4gc2V0VG9vbHRpcChudWxsKSk7XG5cblxuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBlbnN1cmUgc291cmNlIGFuZCB0YXJnZXQgYXJlIGRpZmZlcmVudFxuICBjb25zdCBlbnN1cmVEaWZmZXJlbnRDYXRlZ29yaWVzID0gKHNvdXJjZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZyk6IHsgc291cmNlOiBzdHJpbmc7IHRhcmdldDogc3RyaW5nIH0gPT4ge1xuICAgIGlmIChzb3VyY2UgPT09IHRhcmdldCkge1xuICAgICAgLy8gRmluZCBhIGRpZmZlcmVudCB0YXJnZXRcbiAgICAgIGNvbnN0IGRpZmZlcmVudE9wdGlvbiA9IGF2YWlsYWJsZUZpZWxkcy5maW5kKGZpZWxkID0+IGZpZWxkLnZhbHVlICE9PSBzb3VyY2UpO1xuICAgICAgcmV0dXJuIHsgc291cmNlLCB0YXJnZXQ6IGRpZmZlcmVudE9wdGlvbiA/IGRpZmZlcmVudE9wdGlvbi52YWx1ZSA6ICdsZWFybmluZ19zdHlsZScgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc291cmNlLCB0YXJnZXQgfTtcbiAgfTtcblxuICAvLyBFbnN1cmUgaW5pdGlhbCBzdGF0ZSBkb2Vzbid0IGhhdmUgc2FtZSBjYXRlZ29yaWVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29ycmVjdGVkID0gZW5zdXJlRGlmZmVyZW50Q2F0ZWdvcmllcyhjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0KTtcbiAgICBpZiAoY29ycmVjdGVkLnNvdXJjZSAhPT0gY3VycmVudFNvdXJjZSB8fCBjb3JyZWN0ZWQudGFyZ2V0ICE9PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICBzZXRDdXJyZW50U291cmNlKGNvcnJlY3RlZC5zb3VyY2UpO1xuICAgICAgc2V0Q3VycmVudFRhcmdldChjb3JyZWN0ZWQudGFyZ2V0KTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBUcmFjayBjdXJyZW50IG1vZGUgaW5kZXggd2l0aCBzdGF0ZVxuICBjb25zdCBbY3VycmVudE1vZGVJbmRleCwgc2V0Q3VycmVudE1vZGVJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgXG4gIC8vIFVwZGF0ZSBtb2RlIGluZGV4IHdoZW4gc291cmNlL3RhcmdldCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbW9kZUluZGV4ID0gY3ljbGluZ01vZGVzLmZpbmRJbmRleChcbiAgICAgIG1vZGUgPT4gbW9kZS5zb3VyY2UgPT09IGN1cnJlbnRTb3VyY2UgJiYgbW9kZS50YXJnZXQgPT09IGN1cnJlbnRUYXJnZXRcbiAgICApO1xuICAgIGlmIChtb2RlSW5kZXggIT09IC0xKSB7XG4gICAgICBzZXRDdXJyZW50TW9kZUluZGV4KG1vZGVJbmRleCk7XG4gICAgfVxuICB9LCBbY3VycmVudFNvdXJjZSwgY3VycmVudFRhcmdldF0pO1xuXG4gIC8vIFJlbW92ZSBwdWxzaW5nIGFuaW1hdGlvbiB0byBlbGltaW5hdGUgZmxpY2tlcmluZyAtIHdpbGwgdXNlIENTUyBhbmltYXRpb25zIGluc3RlYWQgaWYgbmVlZGVkXG5cbiAgLy8gQXJjIGhpZ2hsaWdodGluZyBhbmltYXRpb24gd2l0aCBjb25uZWN0ZWQgcmliYm9uc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5SEIENob3JkRGlhZ3JhbSBhcmMgaGlnaGxpZ2h0aW5nIGVmZmVjdDonLCB7XG4gICAgICBhdXRvUGxheSxcbiAgICAgIGlzQXV0b1BsYXlFbmFibGVkOiBzZXR0aW5ncy5pc0F1dG9QbGF5RW5hYmxlZCxcbiAgICAgIGRhdGFMZW5ndGg6IGRhdGEubGVuZ3RoXG4gICAgfSk7XG5cbiAgICBpZiAoIWF1dG9QbGF5IHx8ICFzZXR0aW5ncy5pc0F1dG9QbGF5RW5hYmxlZCB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgQXJjIGhpZ2hsaWdodGluZyBkaXNhYmxlZCcpO1xuICAgICAgLy8gUmVzZXQgdG8gZnVsbCBvcGFjaXR5IHdoZW4gYW5pbWF0aW9uIGlzIGRpc2FibGVkXG4gICAgICBzZXRBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgc2V0SGlnaGxpZ2h0ZWRBcmNJbmRleChudWxsKTtcbiAgICAgIHNldEhpZ2hsaWdodGVkU2lkZShudWxsKTtcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpO1xuICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgIGlmICghYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyB8fCBhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBTYWZldHkgY2hlY2s6IHByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5jeWNsZUNvdW50ID4gMTAwMCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+bkSBDaG9yZCBhbmltYXRpb24gY3ljbGUgbGltaXQgcmVhY2hlZCwgcmVzZXR0aW5nJyk7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN5Y2xlQ291bnQgPSAwO1xuICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdsZWZ0JztcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGN1cnJlbnQgZGF0YSBjb250ZXh0ICh0aGlzIHdpbGwgYWRhcHQgdG8gbW9kZSBjaGFuZ2VzKVxuICAgICAgY29uc3QgZmlsdGVyZWREYXRhID0gc2V0dGluZ3MudXNlVGVzdERhdGEgPyBkYXRhIDogZGF0YS5maWx0ZXIoaXRlbSA9PiAhKGl0ZW0gYXMgYW55KS50ZXN0X2RhdGEpO1xuICAgICAgXG4gICAgICAvLyBEZWZpbmUgYWxsIHBvc3NpYmxlIGNhdGVnb3JpZXMgZm9yIGVhY2ggZmllbGQgKG5vdCBqdXN0IHRob3NlIHdpdGggZGF0YSlcbiAgICAgIGNvbnN0IGFsbENhdGVnb3JpZXMgPSB7XG4gICAgICAgIHllYXJzX2F0X21lZHRyb25pYzogWycwLTUnLCAnNi0xMCcsICcxMS0xNScsICcxNi0yMCcsICcyMCsnXSxcbiAgICAgICAgbGVhcm5pbmdfc3R5bGU6IFsndmlzdWFsJywgJ2F1ZGl0b3J5JywgJ2tpbmVzdGhldGljJywgJ3JlYWRpbmdfd3JpdGluZyddLFxuICAgICAgICBzaGFwZWRfYnk6IFsnbWVudG9yJywgJ2NoYWxsZW5nZScsICdmYWlsdXJlJywgJ3N1Y2Nlc3MnLCAndGVhbScsICdvdGhlciddLFxuICAgICAgICBwZWFrX3BlcmZvcm1hbmNlOiBbJ0V4dHJvdmVydCwgTW9ybmluZycsICdFeHRyb3ZlcnQsIEV2ZW5pbmcnLCAnSW50cm92ZXJ0LCBNb3JuaW5nJywgJ0ludHJvdmVydCwgTmlnaHQnLCAnQW1iaXZlcnQsIE1vcm5pbmcnLCAnQW1iaXZlcnQsIE5pZ2h0J10sXG4gICAgICAgIG1vdGl2YXRpb246IFsnaW1wYWN0JywgJ2dyb3d0aCcsICdyZWNvZ25pdGlvbicsICdhdXRvbm9teScsICdwdXJwb3NlJ11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGxlZnRWYWx1ZXMgPSBhbGxDYXRlZ29yaWVzW2N1cnJlbnRTb3VyY2UgYXMga2V5b2YgdHlwZW9mIGFsbENhdGVnb3JpZXNdIHx8IFtdO1xuICAgICAgY29uc3QgcmlnaHRWYWx1ZXMgPSBhbGxDYXRlZ29yaWVzW2N1cnJlbnRUYXJnZXQgYXMga2V5b2YgdHlwZW9mIGFsbENhdGVnb3JpZXNdIHx8IFtdO1xuXG4gICAgICBjb25zdCBjdXJyZW50U2lkZUxlbmd0aCA9IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcgPyBsZWZ0VmFsdWVzLmxlbmd0aCA6IHJpZ2h0VmFsdWVzLmxlbmd0aDtcblxuICAgICAgLy8gU2FmZXR5IGNoZWNrOiBpZiBjdXJyZW50IGluZGV4IGlzIG91dCBvZiBib3VuZHMgZm9yIG5ldyBtb2RlLCByZXNldCB0byAwXG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4ID49IGN1cnJlbnRTaWRlTGVuZ3RoKSB7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIERlYnVnOiBMb2cgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlIGZvciBkZXYgdG9vbHNcbiAgICAgIGNvbnNvbGUubG9nKCdbQ2hvcmRBbmltYXRpb25dIFNpZGU6JywgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUsICdJbmRleDonLCBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXgsICdUb3RhbCBvbiBzaWRlOicsIGN1cnJlbnRTaWRlTGVuZ3RoLCAnTW9kZTonLCBjdXJyZW50U291cmNlICsgJyDihpIgJyArIGN1cnJlbnRUYXJnZXQpO1xuXG4gICAgICBzZXRBbmltYXRpb25QaGFzZSgnaGlnaGxpZ2h0aW5nJyk7XG4gICAgICBzZXRIaWdobGlnaHRlZEFyY0luZGV4KGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCk7XG4gICAgICBzZXRIaWdobGlnaHRlZFNpZGUoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUpO1xuICAgICAgXG4gICAgICBjb25zdCBoaWdobGlnaHRlZENhdGVnb3J5ID0gYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUgPT09ICdsZWZ0JyBcbiAgICAgICAgPyBsZWZ0VmFsdWVzW2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleF1cbiAgICAgICAgOiByaWdodFZhbHVlc1thbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXhdO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGNhdGVnb3J5IGhhcyBkYXRhXG4gICAgICBjb25zdCBoYXNEYXRhID0gZmlsdGVyZWREYXRhLnNvbWUoZCA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSA9PT0gaGlnaGxpZ2h0ZWRDYXRlZ29yeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChkIGFzIGFueSlbY3VycmVudFNvdXJjZV0gPT09IGhpZ2hsaWdodGVkQ2F0ZWdvcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSA9PT0gaGlnaGxpZ2h0ZWRDYXRlZ29yeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChkIGFzIGFueSlbY3VycmVudFRhcmdldF0gPT09IGhpZ2hsaWdodGVkQ2F0ZWdvcnk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn4pyoIEhpZ2hsaWdodGluZyBmdWxsIHJlbGF0aW9uc2hpcCBjaGFpbiBmb3I6Jywge1xuICAgICAgICBzb3VyY2VDYXRlZ29yeTogaGlnaGxpZ2h0ZWRDYXRlZ29yeSxcbiAgICAgICAgc291cmNlU2lkZTogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUsXG4gICAgICAgIHNvdXJjZUluZGV4OiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXgsXG4gICAgICAgIGhhc0RhdGE6IGhhc0RhdGEsXG4gICAgICAgIHRvdGFsQ2F0ZWdvcmllczogY3VycmVudFNpZGVMZW5ndGhcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGltaW5nIGJhc2VkIG9uIGdsb2JhbCBzZXR0aW5ncyAtIHNsb3dlciBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgIGNvbnN0IHN0ZXBEdXJhdGlvbiA9IE1hdGgubWF4KDE1MDAsIChzZXR0aW5ncy5hdXRvUGxheVNwZWVkIHx8IDMwMDApIC8gMyk7XG4gICAgICBjb25zdCBwYXVzZUR1cmF0aW9uID0gTWF0aC5tYXgoMzAwLCBzdGVwRHVyYXRpb24gLyA1KTtcblxuICAgICAgLy8gTW92ZSB0byBuZXh0IHBvc2l0aW9uIC0gaW5jbHVkZSB0aGUgbGFzdCBpbmRleCBiZWZvcmUgc3dpdGNoaW5nXG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4IDwgY3VycmVudFNpZGVMZW5ndGggLSAxKSB7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgIGFuaW1hdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHN0ZXBEdXJhdGlvbiArIHBhdXNlRHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2hvdyB0aGUgbGFzdCBpbmRleCBmb3IgdGhlIGZ1bGwgZHVyYXRpb24gYmVmb3JlIHN3aXRjaGluZ1xuICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nICYmICFhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgICAgICAgLy8gTm93IHN3aXRjaCBzaWRlcyBvciBjb21wbGV0ZSBjeWNsZVxuICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID0gJ3JpZ2h0JztcbiAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgICBhbmltYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ29tcGxldGUgY3ljbGUgLSBzaG93IGZ1bGwgZGlhZ3JhbSBicmllZmx5LCB0aGVuIHJlc3RhcnRcbiAgICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3ljbGVDb3VudCsrO1xuICAgICAgICAgICAgICBjb25zdCBuZXh0TW9kZUluZGV4ID0gKGN1cnJlbnRNb2RlSW5kZXggKyAxKSAlIGN5Y2xpbmdNb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46JIENob3JkQW5pbWF0aW9uIGNvbXBsZXRlZCBmdWxsIGN5Y2xlICMnICsgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3ljbGVDb3VudCArICchIEFkdmFuY2luZyB0byBtb2RlJywgbmV4dE1vZGVJbmRleCwgY3ljbGluZ01vZGVzW25leHRNb2RlSW5kZXhdKTtcbiAgICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgICAgIHNldEhpZ2hsaWdodGVkQXJjSW5kZXgobnVsbCk7XG4gICAgICAgICAgc2V0SGlnaGxpZ2h0ZWRTaWRlKG51bGwpO1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50TW9kZUluZGV4KG5leHRNb2RlSW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRTb3VyY2UoY3ljbGluZ01vZGVzW25leHRNb2RlSW5kZXhdLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFRhcmdldChjeWNsaW5nTW9kZXNbbmV4dE1vZGVJbmRleF0udGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBzZXRMYXN0Q2F0ZWdvcnlDaGFuZ2UoeyBzb3VyY2U6IGN5Y2xpbmdNb2Rlc1tuZXh0TW9kZUluZGV4XS5zb3VyY2UsIHRhcmdldDogY3ljbGluZ01vZGVzW25leHRNb2RlSW5kZXhdLnRhcmdldCB9KTtcbiAgICAgICAgICAgICAgICBvblJlbGF0aW9uc2hpcENoYW5nZT8uKGN5Y2xpbmdNb2Rlc1tuZXh0TW9kZUluZGV4XS5zb3VyY2UsIGN5Y2xpbmdNb2Rlc1tuZXh0TW9kZUluZGV4XS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIC8vIEFuaW1hdGlvbiB3aWxsIHJlc3RhcnQgZHVlIHRvIGRlcGVuZGVuY3kgb24gY3VycmVudFNvdXJjZS9jdXJyZW50VGFyZ2V0XG4gICAgICAgICAgfSwgc3RlcER1cmF0aW9uICogMik7XG4gICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHN0ZXBEdXJhdGlvbiArIHBhdXNlRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTdGFydCBhbmltYXRpb24gaWYgbm90IGFscmVhZHkgcnVubmluZ1xuICAgIGlmICghYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZykge1xuICAgICAgY29uc29sZS5sb2coJ+KchSBTdGFydGluZyBDaG9yZERpYWdyYW0gYXJjIGhpZ2hsaWdodGluZyBhbmltYXRpb24nKTtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4ID0gMDtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID0gJ2xlZnQnO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgIGFuaW1hdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBBcmMgaGlnaGxpZ2h0aW5nIGFuaW1hdGlvbiBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ/Cfp7kgQ2xlYW5pbmcgdXAgQ2hvcmREaWFncmFtIGFyYyBoaWdobGlnaHRpbmcgYW5pbWF0aW9uJyk7XG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKTtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyA9IGZhbHNlO1xuICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgIHNldEhpZ2hsaWdodGVkQXJjSW5kZXgobnVsbCk7XG4gICAgICBzZXRIaWdobGlnaHRlZFNpZGUobnVsbCk7XG4gICAgfTtcbiAgfSwgW2F1dG9QbGF5LCBzZXR0aW5ncy5pc0F1dG9QbGF5RW5hYmxlZCwgZGF0YS5sZW5ndGgsIHNldHRpbmdzLmF1dG9QbGF5U3BlZWQsIHNldHRpbmdzLnVzZVRlc3REYXRhXSk7IC8vIFJlbW92ZWQgY3VycmVudFNvdXJjZSwgY3VycmVudFRhcmdldCB0byBwcmV2ZW50IHJlc3RhcnRpbmdcblxuICAvLyBSZXN0YXJ0IGFuaW1hdGlvbiB3aGVuIG1vZGUgY2hhbmdlcyAoYnV0IG9ubHkgaWYgbm90IHBhdXNlZClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYXV0b1BsYXkgJiYgc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQgJiYgZGF0YS5sZW5ndGggJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBNb2RlIGNoYW5nZWQsIHJlc3RhcnRpbmcgYW5pbWF0aW9uIHdpdGggbmV3IG1vZGU6JywgY3VycmVudFNvdXJjZSArICcg4oaSICcgKyBjdXJyZW50VGFyZ2V0KTtcbiAgICAgIFxuICAgICAgLy8gUmVzZXQgYW5pbWF0aW9uIHN0YXRlIGZvciBuZXcgbW9kZVxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4ID0gMDtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID0gJ2xlZnQnO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3ljbGVDb3VudCA9IDA7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lclxuICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmVzdGFydCBhbmltYXRpb24gaWYgaXQgd2FzIHJ1bm5pbmdcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nKSB7XG4gICAgICAgIC8vIENhbGwgYW5pbWF0ZSBmdW5jdGlvbiBkaXJlY3RseSB0byByZXN0YXJ0IHdpdGggbmV3IG1vZGVcbiAgICAgICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIWFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgfHwgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHJldHVybjtcblxuICAgICAgICAgIC8vIFNhZmV0eSBjaGVjazogcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5jeWNsZUNvdW50ID4gMTAwMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfm5EgQ2hvcmQgYW5pbWF0aW9uIGN5Y2xlIGxpbWl0IHJlYWNoZWQsIHJlc2V0dGluZycpO1xuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3ljbGVDb3VudCA9IDA7XG4gICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUgPSAnbGVmdCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZGF0YSBjb250ZXh0ICh0aGlzIHdpbGwgYWRhcHQgdG8gbW9kZSBjaGFuZ2VzKVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IHNldHRpbmdzLnVzZVRlc3REYXRhID8gZGF0YSA6IGRhdGEuZmlsdGVyKGl0ZW0gPT4gIShpdGVtIGFzIGFueSkudGVzdF9kYXRhKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZWZpbmUgYWxsIHBvc3NpYmxlIGNhdGVnb3JpZXMgZm9yIGVhY2ggZmllbGQgKG5vdCBqdXN0IHRob3NlIHdpdGggZGF0YSlcbiAgICAgICAgICBjb25zdCBhbGxDYXRlZ29yaWVzID0ge1xuICAgICAgICAgICAgeWVhcnNfYXRfbWVkdHJvbmljOiBbJzAtNScsICc2LTEwJywgJzExLTE1JywgJzE2LTIwJywgJzIwKyddLFxuICAgICAgICAgICAgbGVhcm5pbmdfc3R5bGU6IFsndmlzdWFsJywgJ2F1ZGl0b3J5JywgJ2tpbmVzdGhldGljJywgJ3JlYWRpbmdfd3JpdGluZyddLFxuICAgICAgICAgICAgc2hhcGVkX2J5OiBbJ21lbnRvcicsICdjaGFsbGVuZ2UnLCAnZmFpbHVyZScsICdzdWNjZXNzJywgJ3RlYW0nLCAnb3RoZXInXSxcbiAgICAgICAgICAgIHBlYWtfcGVyZm9ybWFuY2U6IFsnRXh0cm92ZXJ0LCBNb3JuaW5nJywgJ0V4dHJvdmVydCwgRXZlbmluZycsICdJbnRyb3ZlcnQsIE1vcm5pbmcnLCAnSW50cm92ZXJ0LCBOaWdodCcsICdBbWJpdmVydCwgTW9ybmluZycsICdBbWJpdmVydCwgTmlnaHQnXSxcbiAgICAgICAgICAgIG1vdGl2YXRpb246IFsnaW1wYWN0JywgJ2dyb3d0aCcsICdyZWNvZ25pdGlvbicsICdhdXRvbm9teScsICdwdXJwb3NlJ11cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGxlZnRWYWx1ZXMgPSBhbGxDYXRlZ29yaWVzW2N1cnJlbnRTb3VyY2UgYXMga2V5b2YgdHlwZW9mIGFsbENhdGVnb3JpZXNdIHx8IFtdO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0VmFsdWVzID0gYWxsQ2F0ZWdvcmllc1tjdXJyZW50VGFyZ2V0IGFzIGtleW9mIHR5cGVvZiBhbGxDYXRlZ29yaWVzXSB8fCBbXTtcblxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTaWRlTGVuZ3RoID0gYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUgPT09ICdsZWZ0JyA/IGxlZnRWYWx1ZXMubGVuZ3RoIDogcmlnaHRWYWx1ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgLy8gU2FmZXR5IGNoZWNrOiBpZiBjdXJyZW50IGluZGV4IGlzIG91dCBvZiBib3VuZHMgZm9yIG5ldyBtb2RlLCByZXNldCB0byAwXG4gICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCA+PSBjdXJyZW50U2lkZUxlbmd0aCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWJ1ZzogTG9nIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSBmb3IgZGV2IHRvb2xzXG4gICAgICAgICAgY29uc29sZS5sb2coJ1tDaG9yZEFuaW1hdGlvbl0gU2lkZTonLCBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSwgJ0luZGV4OicsIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCwgJ1RvdGFsIG9uIHNpZGU6JywgY3VycmVudFNpZGVMZW5ndGgsICdNb2RlOicsIGN1cnJlbnRTb3VyY2UgKyAnIOKGkiAnICsgY3VycmVudFRhcmdldCk7XG5cbiAgICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnaGlnaGxpZ2h0aW5nJyk7XG4gICAgICAgICAgc2V0SGlnaGxpZ2h0ZWRBcmNJbmRleChhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXgpO1xuICAgICAgICAgIHNldEhpZ2hsaWdodGVkU2lkZShhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZWRDYXRlZ29yeSA9IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcgXG4gICAgICAgICAgICA/IGxlZnRWYWx1ZXNbYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4XVxuICAgICAgICAgICAgOiByaWdodFZhbHVlc1thbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXhdO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgY2F0ZWdvcnkgaGFzIGRhdGFcbiAgICAgICAgICBjb25zdCBoYXNEYXRhID0gZmlsdGVyZWREYXRhLnNvbWUoZCA9PiB7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICBpZiAoY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSA9PT0gaGlnaGxpZ2h0ZWRDYXRlZ29yeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKGQgYXMgYW55KVtjdXJyZW50U291cmNlXSA9PT0gaGlnaGxpZ2h0ZWRDYXRlZ29yeTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApID09PSBoaWdobGlnaHRlZENhdGVnb3J5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAoZCBhcyBhbnkpW2N1cnJlbnRUYXJnZXRdID09PSBoaWdobGlnaHRlZENhdGVnb3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinKggSGlnaGxpZ2h0aW5nIGZ1bGwgcmVsYXRpb25zaGlwIGNoYWluIGZvcjonLCB7XG4gICAgICAgICAgICBzb3VyY2VDYXRlZ29yeTogaGlnaGxpZ2h0ZWRDYXRlZ29yeSxcbiAgICAgICAgICAgIHNvdXJjZVNpZGU6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlLFxuICAgICAgICAgICAgc291cmNlSW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgIGhhc0RhdGE6IGhhc0RhdGEsXG4gICAgICAgICAgICB0b3RhbENhdGVnb3JpZXM6IGN1cnJlbnRTaWRlTGVuZ3RoXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGltaW5nIGJhc2VkIG9uIGdsb2JhbCBzZXR0aW5ncyAtIHNsb3dlciBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgICBjb25zdCBzdGVwRHVyYXRpb24gPSBNYXRoLm1heCgxNTAwLCAoc2V0dGluZ3MuYXV0b1BsYXlTcGVlZCB8fCAzMDAwKSAvIDMpO1xuICAgICAgICAgIGNvbnN0IHBhdXNlRHVyYXRpb24gPSBNYXRoLm1heCgzMDAsIHN0ZXBEdXJhdGlvbiAvIDUpO1xuXG4gICAgICAgICAgLy8gTW92ZSB0byBuZXh0IHBvc2l0aW9uIC0gaW5jbHVkZSB0aGUgbGFzdCBpbmRleCBiZWZvcmUgc3dpdGNoaW5nXG4gICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCA8IGN1cnJlbnRTaWRlTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzdGVwRHVyYXRpb24gKyBwYXVzZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2hvdyB0aGUgbGFzdCBpbmRleCBmb3IgdGhlIGZ1bGwgZHVyYXRpb24gYmVmb3JlIHN3aXRjaGluZ1xuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gTm93IHN3aXRjaCBzaWRlcyBvciBjb21wbGV0ZSBjeWNsZVxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBDb21wbGV0ZSBjeWNsZSAtIHNob3cgZnVsbCBkaWFncmFtIGJyaWVmbHksIHRoZW4gcmVzdGFydFxuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3ljbGVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dE1vZGVJbmRleCA9IChjdXJyZW50TW9kZUluZGV4ICsgMSkgJSBjeWNsaW5nTW9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CfjokgQ2hvcmRBbmltYXRpb24gY29tcGxldGVkIGZ1bGwgY3ljbGUgIycgKyBhbmltYXRpb25SZWYuY3VycmVudC5jeWNsZUNvdW50ICsgJyEgQWR2YW5jaW5nIHRvIG1vZGUnLCBuZXh0TW9kZUluZGV4LCBjeWNsaW5nTW9kZXNbbmV4dE1vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgICAgICAgICAgICAgIHNldEhpZ2hsaWdodGVkQXJjSW5kZXgobnVsbCk7XG4gICAgICAgICAgICAgICAgICBzZXRIaWdobGlnaHRlZFNpZGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudE1vZGVJbmRleChuZXh0TW9kZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFNvdXJjZShjeWNsaW5nTW9kZXNbbmV4dE1vZGVJbmRleF0uc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFRhcmdldChjeWNsaW5nTW9kZXNbbmV4dE1vZGVJbmRleF0udGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0TGFzdENhdGVnb3J5Q2hhbmdlKHsgc291cmNlOiBjeWNsaW5nTW9kZXNbbmV4dE1vZGVJbmRleF0uc291cmNlLCB0YXJnZXQ6IGN5Y2xpbmdNb2Rlc1tuZXh0TW9kZUluZGV4XS50YXJnZXQgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVsYXRpb25zaGlwQ2hhbmdlPy4oY3ljbGluZ01vZGVzW25leHRNb2RlSW5kZXhdLnNvdXJjZSwgY3ljbGluZ01vZGVzW25leHRNb2RlSW5kZXhdLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuaW1hdGlvbiB3aWxsIHJlc3RhcnQgZHVlIHRvIGRlcGVuZGVuY3kgb24gY3VycmVudFNvdXJjZS9jdXJyZW50VGFyZ2V0XG4gICAgICAgICAgICAgICAgICB9LCBzdGVwRHVyYXRpb24gKiAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHN0ZXBEdXJhdGlvbiArIHBhdXNlRHVyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGFuaW1hdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0LCBhdXRvUGxheSwgc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQsIGRhdGEubGVuZ3RoLCBzZXR0aW5ncy5hdXRvUGxheVNwZWVkLCBzZXR0aW5ncy51c2VUZXN0RGF0YSwgY3VycmVudE1vZGVJbmRleF0pO1xuXG4gIC8vIFNlY29uZGFyeSBjaG9yZCBhbmltYXRpb24gc3lzdGVtXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFhdXRvUGxheSB8fCAhc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQgfHwgIWRhdGEubGVuZ3RoIHx8ICFzaG93U2Vjb25kYXJ5Q2hvcmQpIHtcbiAgICAgIC8vIFN0b3AgYW5pbWF0aW9uIGlmIGNvbmRpdGlvbnMgbm90IG1ldFxuICAgICAgY29uc29sZS5sb2coJ/Cfm5EgU3RvcHBpbmcgc2Vjb25kYXJ5IGNob3JkIGFuaW1hdGlvbjonLCB7XG4gICAgICAgIGF1dG9QbGF5LFxuICAgICAgICBpc0F1dG9QbGF5RW5hYmxlZDogc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQsXG4gICAgICAgIGhhc0RhdGE6IGRhdGEubGVuZ3RoID4gMCxcbiAgICAgICAgc2hvd1NlY29uZGFyeUNob3JkXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRlU2Vjb25kYXJ5ID0gKCkgPT4ge1xuICAgICAgaWYgKCFzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nIHx8IHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSByZXR1cm47XG5cbiAgICAgIC8vIEdldCBzZWNvbmRhcnkgY2hvcmQgZGF0YSBjb250ZXh0IGZpcnN0XG4gICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBzZXR0aW5ncy51c2VUZXN0RGF0YSA/IGRhdGEgOiBkYXRhLmZpbHRlcihpdGVtID0+ICEoaXRlbSBhcyBhbnkpLnRlc3RfZGF0YSk7XG4gICAgICBjb25zdCBzZWNvbmRhcnlEYXRhID0gZmlsdGVyZWREYXRhLmZpbHRlcihkID0+IChkIGFzIGFueSkucGVha19wZXJmb3JtYW5jZSk7XG4gICAgICBjb25zdCB5ZWFyc0NhdGVnb3JpZXMgPSBbJzAtNScsICc2LTEwJywgJzExLTE1JywgJzE2LTIwJywgJzIwKyddO1xuICAgICAgY29uc3QgcGVha1BlcmZDYXRlZ29yaWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHNlY29uZGFyeURhdGEubWFwKGQgPT4gKGQgYXMgYW55KS5wZWFrX3BlcmZvcm1hbmNlKSkpLmZpbHRlcihCb29sZWFuKS5zb3J0KCk7XG4gICAgICBjb25zdCBhbGxDYXRlZ29yaWVzID0gWy4uLnllYXJzQ2F0ZWdvcmllcywgLi4ucGVha1BlcmZDYXRlZ29yaWVzXTtcblxuICAgICAgY29uc3QgY3VycmVudFNpZGVMZW5ndGggPSBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9PT0gJ2xlZnQnID8geWVhcnNDYXRlZ29yaWVzLmxlbmd0aCA6IHBlYWtQZXJmQ2F0ZWdvcmllcy5sZW5ndGg7XG5cbiAgICAgIC8vIFNhZmV0eSBjaGVjazogaWYgY3VycmVudCBpbmRleCBpcyBvdXQgb2YgYm91bmRzLCByZXNldCB0byAwXG4gICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4ID49IGN1cnJlbnRTaWRlTGVuZ3RoKSB7XG4gICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn46vIFNlY29uZGFyeUNob3JkIGFyYyBhbmltYXRpb246Jywge1xuICAgICAgICBzaWRlOiBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSxcbiAgICAgICAgaW5kZXg6IHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleFxuICAgICAgfSk7XG5cbiAgICAgIHNldFNlY29uZGFyeUFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBhY3R1YWwgYXJjIGluZGV4IGJhc2VkIG9uIHNpZGUgYW5kIHBvc2l0aW9uXG4gICAgICBjb25zdCBhY3R1YWxBcmNJbmRleCA9IHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcgXG4gICAgICAgID8gc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4IC8vIExlZnQgc2lkZTogZGlyZWN0IGluZGV4ICgwLTQpXG4gICAgICAgIDogeWVhcnNDYXRlZ29yaWVzLmxlbmd0aCArIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleDsgLy8gUmlnaHQgc2lkZTogb2Zmc2V0IGJ5IHllYXJzIGNvdW50XG4gICAgICBcbiAgICAgIHNldFNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXgoYWN0dWFsQXJjSW5kZXgpO1xuICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRTaWRlKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRpbWluZyBiYXNlZCBvbiBnbG9iYWwgc2V0dGluZ3MgLSBzbG93ZXIgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgICBjb25zdCBzdGVwRHVyYXRpb24gPSBNYXRoLm1heCgxNTAwLCAoc2V0dGluZ3MuYXV0b1BsYXlTcGVlZCB8fCAzMDAwKSAvIDMpO1xuICAgICAgY29uc3QgcGF1c2VEdXJhdGlvbiA9IE1hdGgubWF4KDMwMCwgc3RlcER1cmF0aW9uIC8gNSk7XG5cbiAgICAgIC8vIE1vdmUgdG8gbmV4dCBwb3NpdGlvbiAtIGluY2x1ZGUgdGhlIGxhc3QgaW5kZXggYmVmb3JlIHN3aXRjaGluZ1xuICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCA8IGN1cnJlbnRTaWRlTGVuZ3RoIC0gMSkge1xuICAgICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nICYmICFzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICBhbmltYXRlU2Vjb25kYXJ5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBzdGVwRHVyYXRpb24gKyBwYXVzZUR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNob3cgdGhlIGxhc3QgaW5kZXggZm9yIHRoZSBmdWxsIGR1cmF0aW9uIGJlZm9yZSBzd2l0Y2hpbmdcbiAgICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyAmJiAhc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIC8vIE5vdyBzd2l0Y2ggc2lkZXMgb3IgY29tcGxldGUgY3ljbGVcbiAgICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdyaWdodCc7XG4gICAgICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgYW5pbWF0ZVNlY29uZGFyeSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENvbXBsZXRlIGN5Y2xlIC0gc2hvdyBmdWxsIGRpYWdyYW0gYnJpZWZseSwgdGhlbiByZXN0YXJ0XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46JIFNlY29uZGFyeUNob3JkQW5pbWF0aW9uIGNvbXBsZXRlZCBmdWxsIGN5Y2xlISBSZXN0YXJ0aW5nLi4uJyk7XG4gICAgICAgICAgc2V0U2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4KG51bGwpO1xuICAgICAgICAgIHNldFNlY29uZGFyeUhpZ2hsaWdodGVkU2lkZShudWxsKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIXNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID0gJ2xlZnQnO1xuICAgICAgICAgICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgICBhbmltYXRlU2Vjb25kYXJ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgc3RlcER1cmF0aW9uICogMik7XG4gICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHN0ZXBEdXJhdGlvbiArIHBhdXNlRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTdGFydCBhbmltYXRpb24gaWYgbm90IGFscmVhZHkgcnVubmluZ1xuICAgIGlmICghc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZykge1xuICAgICAgY29uc29sZS5sb2coJ+KchSBTdGFydGluZyBTZWNvbmRhcnlDaG9yZCBhcmMgaGlnaGxpZ2h0aW5nIGFuaW1hdGlvbicpO1xuICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyA9IHRydWU7XG4gICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUgPSAnbGVmdCc7XG4gICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgYW5pbWF0ZVNlY29uZGFyeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqg77iPIFNlY29uZGFyeSBhcmMgaGlnaGxpZ2h0aW5nIGFuaW1hdGlvbiBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ/Cfp7kgQ2xlYW5pbmcgdXAgU2Vjb25kYXJ5Q2hvcmQgYXJjIGhpZ2hsaWdodGluZyBhbmltYXRpb24nKTtcbiAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC50aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpO1xuICAgICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBzZXRTZWNvbmRhcnlBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleChudWxsKTtcbiAgICAgIHNldFNlY29uZGFyeUhpZ2hsaWdodGVkU2lkZShudWxsKTtcbiAgICB9O1xuICB9LCBbYXV0b1BsYXksIHNldHRpbmdzLmlzQXV0b1BsYXlFbmFibGVkLCBkYXRhLmxlbmd0aCwgc2hvd1NlY29uZGFyeUNob3JkLCBzZXR0aW5ncy5hdXRvUGxheVNwZWVkLCBzZXR0aW5ncy51c2VUZXN0RGF0YV0pOyAvLyBSZW1vdmVkIGN1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXQgdG8gcHJldmVudCByZXN0YXJ0aW5nXG5cbiAgLy8gUmUtcmVuZGVyIHNlY29uZGFyeSBjaG9yZCB3aGVuIGl0cyBhbmltYXRpb24gc3RhdGUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzaG93U2Vjb25kYXJ5Q2hvcmQpIHtcbiAgICAgIHJlbmRlclNlY29uZGFyeUNob3JkKCk7XG4gICAgfVxuICB9LCBbc2hvd1NlY29uZGFyeUNob3JkLCBkYXRhLCBzZXR0aW5ncy51c2VUZXN0RGF0YSwgc2V0dGluZ3MuaXNEYXJrTW9kZV0pO1xuXG4gIC8vIFVwZGF0ZSB2aXN1YWwgc3R5bGluZyBvZiBleGlzdGluZyBtYWluIGNob3JkIGVsZW1lbnRzIHdoZW4gYW5pbWF0aW9uIHN0YXRlIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN2Z1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3Qoc3ZnUmVmLmN1cnJlbnQpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBsZWZ0IGFyY3Mgb3BhY2l0eSBhbmQgc3Ryb2tlIGJhc2VkIG9uIGFuaW1hdGlvbiBzdGF0ZVxuICAgIHN2Zy5zZWxlY3RBbGwoJ3BhdGgubGVmdC1hcmMnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDMwMClcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIChkOiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gMS4wOyAvLyBTb3VyY2UgYXJjIGlzIGZ1bGx5IGhpZ2hsaWdodGVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC40OyAvLyBEaW0gb3RoZXIgbGVmdCBhcmNzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwLjg7IC8vIERlZmF1bHQgb3BhY2l0eVxuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgKGQ6IGFueSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlJywgKGQ6IGFueSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJyA6ICdyZ2JhKDAsMCwwLDAuMyknO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgcmlnaHQgYXJjcyBvcGFjaXR5IGFuZCBzdHJva2UgYmFzZWQgb24gYW5pbWF0aW9uIHN0YXRlXG4gICAgc3ZnLnNlbGVjdEFsbCgncGF0aC5yaWdodC1hcmMnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDMwMClcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIChkOiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgaWYgKGkgPT09IGhpZ2hsaWdodGVkQXJjSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDEuMDsgLy8gU291cmNlIGFyYyBpcyBmdWxseSBoaWdobGlnaHRlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNDsgLy8gRGltIG90aGVyIHJpZ2h0IGFyY3NcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuODsgLy8gRGVmYXVsdCBvcGFjaXR5XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAoZDogYW55LCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlJywgKGQ6IGFueSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAncmlnaHQnICYmIGkgPT09IGhpZ2hsaWdodGVkQXJjSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScgOiAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHJpYmJvbnMgb3BhY2l0eSBhbmQgc3Ryb2tlIGJhc2VkIG9uIGFuaW1hdGlvbiBzdGF0ZVxuICAgIHN2Zy5zZWxlY3RBbGwoJ3BhdGgucmliYm9uJylcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbigzMDApXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCAoZDogYW55KSA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjk1OyAvLyBNYWtlIGNvbm5lY3RlZCByaWJib25zIHZlcnkgcHJvbWluZW50XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjk1OyAvLyBNYWtlIGNvbm5lY3RlZCByaWJib25zIHZlcnkgcHJvbWluZW50XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwLjI7IC8vIERpbSBub24tY29ubmVjdGVkIHJpYmJvbnNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuNyA6IDAuNjtcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIChkOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmICgoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXgpIHx8XG4gICAgICAgICAgICAgIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMi41O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMC41O1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlJywgKGQ6IGFueSkgPT4ge1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKChoaWdobGlnaHRlZFNpZGUgPT09ICdsZWZ0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnNvdXJjZS5pbmRleCkgfHxcbiAgICAgICAgICAgICAgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ3JpZ2h0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnRhcmdldC5pbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScgOiAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG5cbiAgfSwgW2FuaW1hdGlvblBoYXNlLCBoaWdobGlnaHRlZEFyY0luZGV4LCBoaWdobGlnaHRlZFNpZGUsIHNldHRpbmdzLmlzRGFya01vZGVdKTtcblxuICAvLyBVcGRhdGUgdmlzdWFsIHN0eWxpbmcgb2YgZXhpc3Rpbmcgc2Vjb25kYXJ5IGNob3JkIGVsZW1lbnRzIHdoZW4gYW5pbWF0aW9uIHN0YXRlIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNlY29uZGFyeVN2Z1JlZi5jdXJyZW50IHx8ICFzaG93U2Vjb25kYXJ5Q2hvcmQpIHJldHVybjtcblxuICAgIGNvbnN0IHN2ZyA9IGQzLnNlbGVjdChzZWNvbmRhcnlTdmdSZWYuY3VycmVudCk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHNlY29uZGFyeSBjaG9yZCBlbGVtZW50cyBiYXNlZCBvbiB0aGVpciBhbmltYXRpb24gc3RhdGVcbiAgICBzdmcuc2VsZWN0QWxsKCdwYXRoLmNob3JkLWdyb3VwJylcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbigzMDApXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCAoZDogYW55LCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4ID09PSBpKSB7XG4gICAgICAgICAgICByZXR1cm4gMS4wOyAvLyBTb3VyY2UgYXJjIGlzIGZ1bGx5IGhpZ2hsaWdodGVkXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwLjQ7IC8vIERpbSBvdGhlciBhcmNzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuODtcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIChkOiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnICYmIHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGkpIHtcbiAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoJ3N0cm9rZScsIChkOiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnICYmIHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGkpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknIDogJ3JnYmEoMCwwLDAsMC4zKSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG4gICAgc3ZnLnNlbGVjdEFsbCgncGF0aC5jaG9yZCcpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMzAwKVxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgKGQ6IGFueSkgPT4ge1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQuc291cmNlLmluZGV4IHx8IHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQudGFyZ2V0LmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gMC45NTsgLy8gTWFrZSBjb25uZWN0ZWQgcmliYm9ucyB2ZXJ5IHByb21pbmVudFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMC4yOyAvLyBEaW0gbm9uLWNvbm5lY3RlZCByaWJib25zXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjcgOiAwLjY7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAoZDogYW55KSA9PiB7XG4gICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXggfHwgc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAyLjU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwLjU7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdzdHJva2UnLCAoZDogYW55KSA9PiB7XG4gICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXggfHwgc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScgOiAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG5cbiAgfSwgW3NlY29uZGFyeUFuaW1hdGlvblBoYXNlLCBzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4LCBzZWNvbmRhcnlIaWdobGlnaHRlZFNpZGUsIHNldHRpbmdzLmlzRGFya01vZGUsIHNob3dTZWNvbmRhcnlDaG9yZF0pO1xuXG4gIC8vIFJlbW92ZSBjb25mbGljdGluZyBvcGFjaXR5IHVwZGF0ZSBzeXN0ZW0gLSBvcGFjaXR5IHdpbGwgYmUgaGFuZGxlZCBpbiBtYWluIHJlbmRlcmluZ1xuXG4gIC8vIEFkZCBwYXVzZS9yZXN1bWUgZnVuY3Rpb25hbGl0eVxuICBjb25zdCBwYXVzZUFuaW1hdGlvbiA9IChyZWFzb246IHN0cmluZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKCfij7jvuI8gUGF1c2luZyBhbmltYXRpb246JywgcmVhc29uKTtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkID0gdHJ1ZTtcbiAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCA9IHRydWU7XG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKTtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgfTtcblxuICBjb25zdCByZXN1bWVBbmltYXRpb24gPSAocmVhc29uOiBzdHJpbmcpID0+IHtcbiAgICBjb25zb2xlLmxvZygn4pa277iPIFJlc3VtaW5nIGFuaW1hdGlvbjonLCByZWFzb24pO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICBcbiAgICAvLyBFbnN1cmUgYW5pbWF0aW9uIHN0YXRlIGlzIHByb3Blcmx5IHJlc2V0XG4gICAgaWYgKCFhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBSZXN0YXJ0aW5nIGNob3JkIGFuaW1hdGlvbiBhZnRlciByZXN1bWUnKTtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUgPSAnbGVmdCc7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jeWNsZUNvdW50ID0gMDtcbiAgICB9XG4gICAgXG4gICAgLy8gVGhlIG1vZGUgY2hhbmdlIHVzZUVmZmVjdCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVzdGFydCB0aGUgYW5pbWF0aW9uXG4gICAgLy8gd2hlbiBpc1BhdXNlZCBiZWNvbWVzIGZhbHNlIGFuZCBtb2RlIGNoYW5nZXNcbiAgfTtcblxuICAvLyBDaGVjayBpZiBjb250YWluZXIgaXMgdG9vIHNtYWxsIC0gcmVkdWNlZCBtaW5pbXVtIHNpemUgZm9yIGJldHRlciBjb21wYXRpYmlsaXR5XG4gIGNvbnN0IG1hcmdpbiA9IHsgdG9wOiA4MCwgcmlnaHQ6IDgwLCBib3R0b206IDEwMCwgbGVmdDogODAgfTtcbiAgY29uc3QgY2hhcnRXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XG4gIGNvbnN0IGNoYXJ0SGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gIGNvbnN0IGlzQ29udGFpbmVyVG9vU21hbGwgPSBjaGFydFdpZHRoIDwgMTAwIHx8IGNoYXJ0SGVpZ2h0IDwgMTAwOyAvLyBSZWR1Y2VkIGZyb20gMjAweDIwMCB0byAxMDB4MTAwXG5cbiAgLy8gUmVuZGVyIGNpcmN1bGFyIGNob3JkIGRpYWdyYW1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN2Z1JlZi5jdXJyZW50IHx8ICFkYXRhLmxlbmd0aCB8fCBpc0xvYWRpbmcgfHwgaXNDb250YWluZXJUb29TbWFsbCkgcmV0dXJuO1xuXG4gICAgLy8gQ2xlYXIgcHJldmlvdXMgY29udGVudFxuICAgIGQzLnNlbGVjdChzdmdSZWYuY3VycmVudCkuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG5cbiAgICAvLyBGaWx0ZXIgZGF0YSBiYXNlZCBvbiBnbG9iYWwgc2V0dGluZ3NcbiAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBzZXR0aW5ncy51c2VUZXN0RGF0YSBcbiAgICAgID8gZGF0YSBcbiAgICAgIDogZGF0YS5maWx0ZXIoaXRlbSA9PiAhKGl0ZW0gYXMgYW55KS50ZXN0X2RhdGEpO1xuXG4gICAgY29uc3Qgc3ZnID0gZDMuc2VsZWN0KHN2Z1JlZi5jdXJyZW50KTtcbiAgICBcbiAgICAvLyBBZGp1c3Qgc2l6ZSBiYXNlZCBvbiB3aGV0aGVyIHdlJ3JlIHNob3dpbmcgdHdvIGNob3Jkc1xuICAgIGNvbnN0IGVmZmVjdGl2ZVdpZHRoID0gc2hvd1NlY29uZGFyeUNob3JkID8gd2lkdGggKiAwLjQ1IDogd2lkdGg7XG4gICAgY29uc3QgZWZmZWN0aXZlSGVpZ2h0ID0gc2hvd1NlY29uZGFyeUNob3JkID8gaGVpZ2h0ICogMC44IDogaGVpZ2h0ICogMC44NTtcbiAgICBjb25zdCBlZmZlY3RpdmVDaGFydFdpZHRoID0gZWZmZWN0aXZlV2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICBjb25zdCBlZmZlY3RpdmVDaGFydEhlaWdodCA9IGVmZmVjdGl2ZUhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgIFxuICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KDEyMCwgTWF0aC5taW4oZWZmZWN0aXZlQ2hhcnRXaWR0aCwgZWZmZWN0aXZlQ2hhcnRIZWlnaHQpIC8gMiAtIDYwKTtcblxuICAgIC8vIENyZWF0ZSBkZWZpbml0aW9ucyBmb3IgZ3JhZGllbnRzXG4gICAgY29uc3QgZGVmcyA9IHN2Zy5hcHBlbmQoJ2RlZnMnKTtcblxuICAgIC8vIERlZmluZSBmaXhlZCBvcmRlciBmb3IgeWVhcnMgYXQgTWVkdHJvbmljXG4gICAgY29uc3QgWUVBUlNfR1JPVVBTID0gWycwLTUnLCAnNi0xMCcsICcxMS0xNScsICcxNi0yMCcsICcyMCsnXTtcblxuICAgIC8vIEdldCB1bmlxdWUgdmFsdWVzIGZvciBsZWZ0IGFuZCByaWdodCBzaWRlcywgdXNpbmcgZml4ZWQgb3JkZXIgZm9yIHllYXJzXG4gICAgY29uc3QgbGVmdFZhbHVlcyA9IGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICA/IFlFQVJTX0dST1VQU1xuICAgICAgOiBBcnJheS5mcm9tKG5ldyBTZXQoZmlsdGVyZWREYXRhLm1hcChkID0+IChkIGFzIGFueSlbY3VycmVudFNvdXJjZV0pKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWVzID0gY3VycmVudFRhcmdldCA9PT0gJ3llYXJzX2F0X21lZHRyb25pYydcbiAgICAgID8gWUVBUlNfR1JPVVBTXG4gICAgICA6IEFycmF5LmZyb20obmV3IFNldChmaWx0ZXJlZERhdGEubWFwKGQgPT4gKGQgYXMgYW55KVtjdXJyZW50VGFyZ2V0XSkpKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICAvLyBQcm9jZXNzIGRhdGEgZm9yIGNob3JkIGxheW91dFxuICAgIGNvbnN0IGNob3JkRGF0YSA9IHByb2Nlc3NDaG9yZERhdGEoZmlsdGVyZWREYXRhLCBjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0KTtcbiAgICBcbiAgICAvLyBTZXBhcmF0ZSBzb3VyY2UgYW5kIHRhcmdldCBjYXRlZ29yaWVzXG4gICAgY29uc3Qgc291cmNlQ2F0ZWdvcmllcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IHRhcmdldENhdGVnb3JpZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBcbiAgICBmaWx0ZXJlZERhdGEuZm9yRWFjaCgoZDogYW55KSA9PiB7XG4gICAgICBpZiAoY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycpIHtcbiAgICAgICAgc291cmNlQ2F0ZWdvcmllcy5hZGQoZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VDYXRlZ29yaWVzLmFkZChkW2N1cnJlbnRTb3VyY2VdIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgICAgICB0YXJnZXRDYXRlZ29yaWVzLmFkZChnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldENhdGVnb3JpZXMuYWRkKGRbY3VycmVudFRhcmdldF0gfHwgJ1Vua25vd24nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENvbnZlcnQgdG8gYXJyYXlzIGFuZCBzb3J0XG4gICAgY29uc3Qgc291cmNlQXJyYXkgPSBBcnJheS5mcm9tKHNvdXJjZUNhdGVnb3JpZXMpLnNvcnQoKSBhcyBzdHJpbmdbXTtcbiAgICBjb25zdCB0YXJnZXRBcnJheSA9IEFycmF5LmZyb20odGFyZ2V0Q2F0ZWdvcmllcykuc29ydCgpIGFzIHN0cmluZ1tdO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFscyBmb3IgZWFjaCBjYXRlZ29yeVxuICAgIGNvbnN0IGxlZnRUb3RhbHMgPSBzb3VyY2VBcnJheS5tYXAoY2F0ID0+IFxuICAgICAgZmlsdGVyZWREYXRhLmZpbHRlcigoZDogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycgXG4gICAgICAgICAgPyBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApIFxuICAgICAgICAgIDogZFtjdXJyZW50U291cmNlXTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBjYXQ7XG4gICAgICB9KS5sZW5ndGhcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHJpZ2h0VG90YWxzID0gdGFyZ2V0QXJyYXkubWFwKGNhdCA9PiBcbiAgICAgIGZpbHRlcmVkRGF0YS5maWx0ZXIoKGQ6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnIFxuICAgICAgICAgID8gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSBcbiAgICAgICAgICA6IGRbY3VycmVudFRhcmdldF07XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gY2F0O1xuICAgICAgfSkubGVuZ3RoXG4gICAgKTtcblxuICAgIGNvbnN0IGxlZnRUb3RhbFN1bSA9IGxlZnRUb3RhbHMucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKTtcbiAgICBjb25zdCByaWdodFRvdGFsU3VtID0gcmlnaHRUb3RhbHMucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKTtcblxuICAgIC8vIENyZWF0ZSBjb25uZWN0aW9uIG1hdHJpeFxuICAgIGNvbnN0IGNvbm5lY3Rpb25NYXRyaXggPSBzb3VyY2VBcnJheS5tYXAoc291cmNlQ2F0ID0+IFxuICAgICAgdGFyZ2V0QXJyYXkubWFwKHRhcmdldENhdCA9PiB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZERhdGEuZmlsdGVyKChkOiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSBjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJyBcbiAgICAgICAgICAgID8gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSBcbiAgICAgICAgICAgIDogZFtjdXJyZW50U291cmNlXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJyBcbiAgICAgICAgICAgID8gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSBcbiAgICAgICAgICAgIDogZFtjdXJyZW50VGFyZ2V0XTtcbiAgICAgICAgICByZXR1cm4gc291cmNlID09PSBzb3VyY2VDYXQgJiYgdGFyZ2V0ID09PSB0YXJnZXRDYXQ7XG4gICAgICAgIH0pLmxlbmd0aDtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjYXRlZ29yeSBjaGFuZ2UgdGhhdCBzaG91bGQgdHJpZ2dlciBhbmltYXRpb25cbiAgICBjb25zdCBpc0NhdGVnb3J5Q2hhbmdlID0gbGFzdENhdGVnb3J5Q2hhbmdlLnNvdXJjZSAhPT0gY3VycmVudFNvdXJjZSB8fCBsYXN0Q2F0ZWdvcnlDaGFuZ2UudGFyZ2V0ICE9PSBjdXJyZW50VGFyZ2V0O1xuICAgIFxuICAgIC8vIEFkZCBzbW9vdGggdHJhbnNpdGlvbnMgLSBmYXN0ZXIgZm9yIGhvdmVyIGludGVyYWN0aW9uc1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSBkMy50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbihpc0NhdGVnb3J5Q2hhbmdlID8gNzUwIDogMTAwKVxuICAgICAgLmVhc2UoZDMuZWFzZUN1YmljSW5PdXQpO1xuXG4gICAgLy8gLS0tIFRydWUgbGVmdC9yaWdodCBiaXBhcnRpdGUgbGF5b3V0IHdpdGggYmV0dGVyIHNwYWNpbmcgLS0tXG4gICAgLy8gTGVmdCBhcmNzOiAxODDCsCtnYXAgdG8gMzYwwrAtZ2FwIChNYXRoLlBJK2dhcCB0byAyKk1hdGguUEktZ2FwKVxuICAgIC8vIFJpZ2h0IGFyY3M6IDArZ2FwIHRvIDE4MMKwLWdhcCAoMCtnYXAgdG8gTWF0aC5QSS1nYXApXG4gICAgY29uc3QgYXJjR2FwID0gTWF0aC5QSSAqIDAuMTI7IC8vIExhcmdlciBnYXAgZm9yIGJldHRlciBsYWJlbCBzcGFjaW5nXG4gICAgY29uc3QgbGVmdFN0YXJ0ID0gTWF0aC5QSSArIGFyY0dhcDsgICAgICAvLyAxODDCsCArIGdhcFxuICAgIGNvbnN0IGxlZnRFbmQgPSAyICogTWF0aC5QSSAtIGFyY0dhcDsgICAgLy8gMzYwwrAgLSBnYXBcbiAgICBjb25zdCByaWdodFN0YXJ0ID0gMCArIGFyY0dhcDsgICAgICAgICAgIC8vIDDCsCArIGdhcFxuICAgIGNvbnN0IHJpZ2h0RW5kID0gTWF0aC5QSSAtIGFyY0dhcDsgICAgICAgLy8gMTgwwrAgLSBnYXBcbiAgICBjb25zdCBsZWZ0QXJjU3BhbiA9IGxlZnRFbmQgLSBsZWZ0U3RhcnQ7ICAgICAvLyAxODDCsCAtIDIqZ2FwXG4gICAgY29uc3QgcmlnaHRBcmNTcGFuID0gcmlnaHRFbmQgLSByaWdodFN0YXJ0OyAgLy8gMTgwwrAgLSAyKmdhcFxuXG4gICAgLy8gQWRkIG1pbmltdW0gc3BhY2luZyBiZXR3ZWVuIGFyY3MgdG8gcHJldmVudCBsYWJlbCBvdmVybGFwXG4gICAgY29uc3QgbWluQXJjU3BhY2luZyA9IE1hdGguUEkgKiAwLjAyOyAvLyBNaW5pbXVtIDLCsCBiZXR3ZWVuIGFyY3NcblxuICAgIC8vIEFzc2lnbiBhcmMgYW5nbGVzIGZvciBsZWZ0IGFyY3Mgd2l0aCBwcm9wZXIgc3BhY2luZ1xuICAgIGxldCBsZWZ0QW5nbGUgPSBsZWZ0U3RhcnQ7XG4gICAgY29uc3QgbGVmdEFyY3MgPSBsZWZ0VmFsdWVzLm1hcCgodmFsdWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGNvdW50ID0gZmlsdGVyZWREYXRhLmZpbHRlcihkID0+XG4gICAgICAgIGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICAgICAgPyBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApID09PSB2YWx1ZVxuICAgICAgICAgIDogKGQgYXMgYW55KVtjdXJyZW50U291cmNlXSA9PT0gdmFsdWVcbiAgICAgICkubGVuZ3RoO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgYXJjIHNwYW4gd2l0aCBzcGFjaW5nIGNvbnNpZGVyYXRpb25cbiAgICAgIGNvbnN0IGF2YWlsYWJsZVNwYW4gPSBsZWZ0QXJjU3BhbiAtIChtaW5BcmNTcGFjaW5nICogKGxlZnRWYWx1ZXMubGVuZ3RoIC0gMSkpO1xuICAgICAgY29uc3QgYXJjU3BhbiA9IGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICAgID8gYXZhaWxhYmxlU3BhbiAvIGxlZnRWYWx1ZXMubGVuZ3RoXG4gICAgICAgIDogTWF0aC5tYXgobWluQXJjU3BhY2luZywgYXZhaWxhYmxlU3BhbiAqIChjb3VudCAvIChsZWZ0VG90YWxTdW0gfHwgMSkpKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IGxlZnRBbmdsZTtcbiAgICAgIGNvbnN0IGVuZEFuZ2xlID0gbGVmdEFuZ2xlICsgYXJjU3BhbjtcbiAgICAgIGxlZnRBbmdsZSA9IGVuZEFuZ2xlICsgbWluQXJjU3BhY2luZzsgLy8gQWRkIHNwYWNpbmcgYmV0d2VlbiBhcmNzXG4gICAgICBcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Tm9kZUNvbG9yKHZhbHVlLCBjdXJyZW50U291cmNlLCBzZXR0aW5ncy5jYXRlZ29yeUNvbG9ycywgc2V0dGluZ3MuaXNEYXJrTW9kZSk7XG4gICAgICBjb25zdCBvcGFjaXR5ID0gY291bnQgPT09IDAgPyAwLjE1IDogMC44O1xuICAgICAgcmV0dXJuIHsgbmFtZTogdmFsdWUsIHZhbHVlOiBjb3VudCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvbG9yLCBvcGFjaXR5IH07XG4gICAgfSk7XG5cbiAgICAvLyBBc3NpZ24gYXJjIGFuZ2xlcyBmb3IgcmlnaHQgYXJjcyB3aXRoIHByb3BlciBzcGFjaW5nXG4gICAgbGV0IHJpZ2h0QW5nbGUgPSByaWdodFN0YXJ0O1xuICAgIGNvbnN0IHJpZ2h0QXJjcyA9IHJpZ2h0VmFsdWVzLm1hcCgodmFsdWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGNvdW50ID0gZmlsdGVyZWREYXRhLmZpbHRlcihkID0+XG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICAgICAgPyBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApID09PSB2YWx1ZVxuICAgICAgICAgIDogKGQgYXMgYW55KVtjdXJyZW50VGFyZ2V0XSA9PT0gdmFsdWVcbiAgICAgICkubGVuZ3RoO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgYXJjIHNwYW4gd2l0aCBzcGFjaW5nIGNvbnNpZGVyYXRpb25cbiAgICAgIGNvbnN0IGF2YWlsYWJsZVNwYW4gPSByaWdodEFyY1NwYW4gLSAobWluQXJjU3BhY2luZyAqIChyaWdodFZhbHVlcy5sZW5ndGggLSAxKSk7XG4gICAgICBjb25zdCBhcmNTcGFuID0gY3VycmVudFRhcmdldCA9PT0gJ3llYXJzX2F0X21lZHRyb25pYydcbiAgICAgICAgPyBhdmFpbGFibGVTcGFuIC8gcmlnaHRWYWx1ZXMubGVuZ3RoXG4gICAgICAgIDogTWF0aC5tYXgobWluQXJjU3BhY2luZywgYXZhaWxhYmxlU3BhbiAqIChjb3VudCAvIChyaWdodFRvdGFsU3VtIHx8IDEpKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSByaWdodEFuZ2xlO1xuICAgICAgY29uc3QgZW5kQW5nbGUgPSByaWdodEFuZ2xlICsgYXJjU3BhbjtcbiAgICAgIHJpZ2h0QW5nbGUgPSBlbmRBbmdsZSArIG1pbkFyY1NwYWNpbmc7IC8vIEFkZCBzcGFjaW5nIGJldHdlZW4gYXJjc1xuICAgICAgXG4gICAgICBjb25zdCBjb2xvciA9IGdldE5vZGVDb2xvcih2YWx1ZSwgY3VycmVudFRhcmdldCwgc2V0dGluZ3MuY2F0ZWdvcnlDb2xvcnMsIHNldHRpbmdzLmlzRGFya01vZGUpO1xuICAgICAgY29uc3Qgb3BhY2l0eSA9IGNvdW50ID09PSAwID8gMC4xNSA6IDAuODtcbiAgICAgIHJldHVybiB7IG5hbWU6IHZhbHVlLCB2YWx1ZTogY291bnQsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb2xvciwgb3BhY2l0eSB9O1xuICAgIH0pO1xuXG4gICAgLy8gRHJhdyBhcmNzICh1c2UgcGVyLWFyYyBvcGFjaXR5KVxuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgoNjAsIHJhZGl1cyAqIDAuNzUpO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoODAsIHJhZGl1cyAqIDAuOTUpO1xuICAgIGNvbnN0IGFyY0dlbiA9IGQzLmFyYygpXG4gICAgICAuaW5uZXJSYWRpdXMoaW5uZXJSYWRpdXMpXG4gICAgICAub3V0ZXJSYWRpdXMob3V0ZXJSYWRpdXMpXG4gICAgICAuY29ybmVyUmFkaXVzKChkOiBhbnkpID0+IHtcbiAgICAgICAgLy8gT25seSByb3VuZCB0aGUgb3V0ZXIgY29ybmVycyAob3V0ZXJSYWRpdXMpLCBub3QgdGhlIGlubmVyXG4gICAgICAgIC8vIEQzIHY3KyBzdXBwb3J0cyBjb3JuZXJSYWRpdXMgYXMgYSBmdW5jdGlvblxuICAgICAgICAvLyBXZSdsbCByZXR1cm4gMCBmb3IgaW5uZXIsIDggZm9yIG91dGVyXG4gICAgICAgIC8vIEJ1dCBkMy5hcmMoKSBvbmx5IHN1cHBvcnRzIG9uZSB2YWx1ZSwgc28gd2UgbmVlZCB0byB1c2UgY3VzdG9tIHBhdGggaWYgd2Ugd2FudCB0cnVlIHNxdWFyZWQgaW5uZXIgY29ybmVyc1xuICAgICAgICAvLyBBcyBhIHdvcmthcm91bmQsIHNldCBjb3JuZXJSYWRpdXMgdG8gMCBpZiB0aGUgYXJjIGlzIHNtYWxsLCBlbHNlIDhcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9KTtcbiAgICBcbiAgICAvLyBQb3NpdGlvbiB0aGUgY2hhcnQgZ3JvdXAgd2l0aCBtYXJnaW5zIHRvIHByZXZlbnQgY3JvcHBpbmdcbiAgICBjb25zdCBnID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdCArIGVmZmVjdGl2ZUNoYXJ0V2lkdGggLyAyfSwgJHttYXJnaW4udG9wICsgZWZmZWN0aXZlQ2hhcnRIZWlnaHQgLyAyfSlgKTtcblxuICAgIC8vIEFkZCBncmFkaWVudHMgZm9yIGFyY3NcbiAgICBsZWZ0QXJjcy5mb3JFYWNoKChhcmMsIGkpID0+IHtcbiAgICAgIGNvbnN0IGJhc2VDb2xvciA9IGFyYy5jb2xvcjtcbiAgICAgIGNvbnN0IGxpZ2h0ZXJDb2xvciA9IGQzLmNvbG9yKGJhc2VDb2xvcik/LmJyaWdodGVyKDAuMykudG9TdHJpbmcoKSB8fCBiYXNlQ29sb3I7XG4gICAgICBkZWZzLmFwcGVuZCgnbGluZWFyR3JhZGllbnQnKVxuICAgICAgICAuYXR0cignaWQnLCBgbGVmdC1hcmMtZ3JhZGllbnQtJHtpfWApXG4gICAgICAgIC5hdHRyKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJylcbiAgICAgICAgLmF0dHIoJ3gxJywgMClcbiAgICAgICAgLmF0dHIoJ3kxJywgMClcbiAgICAgICAgLmF0dHIoJ3gyJywgMClcbiAgICAgICAgLmF0dHIoJ3kyJywgMSlcbiAgICAgICAgLnNlbGVjdEFsbCgnc3RvcCcpXG4gICAgICAgIC5kYXRhKFtcbiAgICAgICAgICB7IG9mZnNldDogJzAlJywgY29sb3I6IGJhc2VDb2xvciB9LFxuICAgICAgICAgIHsgb2Zmc2V0OiAnMTAwJScsIGNvbG9yOiBsaWdodGVyQ29sb3IgfVxuICAgICAgICBdKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdzdG9wJylcbiAgICAgICAgLmF0dHIoJ29mZnNldCcsIGQgPT4gZC5vZmZzZXQpXG4gICAgICAgIC5hdHRyKCdzdG9wLWNvbG9yJywgZCA9PiBkLmNvbG9yKTtcbiAgICB9KTtcbiAgICByaWdodEFyY3MuZm9yRWFjaCgoYXJjLCBpKSA9PiB7XG4gICAgICBjb25zdCBiYXNlQ29sb3IgPSBhcmMuY29sb3I7XG4gICAgICBjb25zdCBsaWdodGVyQ29sb3IgPSBkMy5jb2xvcihiYXNlQ29sb3IpPy5icmlnaHRlcigwLjMpLnRvU3RyaW5nKCkgfHwgYmFzZUNvbG9yO1xuICAgICAgZGVmcy5hcHBlbmQoJ2xpbmVhckdyYWRpZW50JylcbiAgICAgICAgLmF0dHIoJ2lkJywgYHJpZ2h0LWFyYy1ncmFkaWVudC0ke2l9YClcbiAgICAgICAgLmF0dHIoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKVxuICAgICAgICAuYXR0cigneDEnLCAwKVxuICAgICAgICAuYXR0cigneTEnLCAwKVxuICAgICAgICAuYXR0cigneDInLCAwKVxuICAgICAgICAuYXR0cigneTInLCAxKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdG9wJylcbiAgICAgICAgLmRhdGEoW1xuICAgICAgICAgIHsgb2Zmc2V0OiAnMCUnLCBjb2xvcjogYmFzZUNvbG9yIH0sXG4gICAgICAgICAgeyBvZmZzZXQ6ICcxMDAlJywgY29sb3I6IGxpZ2h0ZXJDb2xvciB9XG4gICAgICAgIF0pXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3N0b3AnKVxuICAgICAgICAuYXR0cignb2Zmc2V0JywgZCA9PiBkLm9mZnNldClcbiAgICAgICAgLmF0dHIoJ3N0b3AtY29sb3InLCBkID0+IGQuY29sb3IpO1xuICAgIH0pO1xuICAgIC8vIENyZWF0ZSBsZWZ0IGFyY3Mgd2l0aCBldmVudCBoYW5kbGVycyBmaXJzdFxuICAgIGNvbnN0IGxlZnRBcmNTZWxlY3Rpb24gPSBnLnNlbGVjdEFsbCgncGF0aC5sZWZ0LWFyYycpXG4gICAgICAuZGF0YShsZWZ0QXJjcylcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdwYXRoJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdsZWZ0LWFyYycpXG4gICAgICAuYXR0cignZCcsIGQgPT4gYXJjR2VuKHsgc3RhcnRBbmdsZTogZC5zdGFydEFuZ2xlLCBlbmRBbmdsZTogZC5lbmRBbmdsZSB9IGFzIGFueSkpXG4gICAgICAuYXR0cignZmlsbCcsIChkLCBpKSA9PiBgdXJsKCNsZWZ0LWFyYy1ncmFkaWVudC0ke2l9KWApXG4gICAgICAuYXR0cignb3BhY2l0eScsIDApXG4gICAgICAub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbihldmVudCwgZDogYW55KSB7XG4gICAgICAgIHBhdXNlQW5pbWF0aW9uKCdsZWZ0IGFyYyBob3ZlcicpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgc2FtZSBoaWdobGlnaHRpbmcgYXMgYXV0by1jeWNsZSBhbmltYXRpb25cbiAgICAgICAgY29uc3QgYXJjSW5kZXggPSBsZWZ0QXJjcy5maW5kSW5kZXgoYXJjID0+IGFyYy5uYW1lID09PSBkLm5hbWUpO1xuICAgICAgICBcbiAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgICBzZXRIaWdobGlnaHRlZEFyY0luZGV4KGFyY0luZGV4KTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRTaWRlKCdsZWZ0Jyk7XG4gICAgICAgIFxuICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICB4OiBldmVudC5wYWdlWCxcbiAgICAgICAgICB5OiBldmVudC5wYWdlWSxcbiAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdib2xkJywgbWFyZ2luQm90dG9tOiA0IH19PnsoZC5uYW1lIHx8ICdVbmtub3duJykudG9TdHJpbmcoKS5yZXBsYWNlKC9fL2csICcgJyl9PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXY+Q291bnQ6IHtkLnZhbHVlfTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgIHJlc3VtZUFuaW1hdGlvbignbGVmdCBhcmMgaG92ZXIgZW5kJyk7XG4gICAgICAgIHNldFRvb2x0aXAobnVsbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXNldCBoaWdobGlnaHRpbmcgd2hlbiBhbmltYXRpb24gcmVzdW1lc1xuICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgICBzZXRIaWdobGlnaHRlZEFyY0luZGV4KG51bGwpO1xuICAgICAgICBzZXRIaWdobGlnaHRlZFNpZGUobnVsbCk7XG4gICAgICB9KTtcbiAgICBcbiAgICAvLyBBcHBseSB0cmFuc2l0aW9uIGFuaW1hdGlvbnMgc2VwYXJhdGVseVxuICAgIGxlZnRBcmNTZWxlY3Rpb25cbiAgICAgIC50cmFuc2l0aW9uKHRyYW5zaXRpb24pXG4gICAgICAuYXR0cignb3BhY2l0eScsIChkLCBpKSA9PiB7XG4gICAgICAgIC8vIEFwcGx5IGZ1bGwgcmVsYXRpb25zaGlwIGNoYWluIGhpZ2hsaWdodGluZ1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAvLyBIaWdobGlnaHQgdGhlIHNvdXJjZSBhcmNcbiAgICAgICAgICAgIGlmIChpID09PSBoaWdobGlnaHRlZEFyY0luZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiAxLjA7IC8vIFNvdXJjZSBhcmMgaXMgZnVsbHkgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgYXJjIGlzIGNvbm5lY3RlZCB0byB0aGUgaGlnaGxpZ2h0ZWQgcmlnaHQgYXJjXG4gICAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gMC40OyAvLyBEaW0gb3RoZXIgbGVmdCBhcmNzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2hlbiByaWdodCBhcmMgaXMgaGlnaGxpZ2h0ZWQsIGhpZ2hsaWdodCBsZWZ0IGFyY3MgY29ubmVjdGVkIHRvIGl0XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhWYWx1ZSA9IGNvbm5lY3Rpb25NYXRyaXhbaV0gJiYgY29ubmVjdGlvbk1hdHJpeFtpXVtoaWdobGlnaHRlZEFyY0luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkVG9IaWdobGlnaHRlZFJpZ2h0ID0gbWF0cml4VmFsdWUgPiAwO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflJcgTGVmdCBhcmMgJHtpfSAoJHtsZWZ0QXJjc1tpXT8ubmFtZX0pIGNvbm5lY3RlZCB0byByaWdodCBhcmMgJHtoaWdobGlnaHRlZEFyY0luZGV4fSAoJHtyaWdodEFyY3NbaGlnaGxpZ2h0ZWRBcmNJbmRleF0/Lm5hbWV9KT9gLCBcbiAgICAgICAgICAgICAgaXNDb25uZWN0ZWRUb0hpZ2hsaWdodGVkUmlnaHQsICdNYXRyaXggdmFsdWU6JywgbWF0cml4VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkVG9IaWdobGlnaHRlZFJpZ2h0ID8gMC45NSA6IDAuMzsgLy8gSGlnaGVyIGNvbnRyYXN0XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBzdGFibGUgYmFzZSBvcGFjaXR5IHdpdGhvdXQgcHVsc2luZyB0byBwcmV2ZW50IGZsaWNrZXJpbmdcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAuOCwgZC5vcGFjaXR5KTtcbiAgICAgIH0pXG4gICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgLy8gRW5oYW5jZWQgc3Ryb2tlIGZvciByZWxhdGlvbnNoaXAgY2hhaW5cbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdsZWZ0JyAmJiBpID09PSBoaWdobGlnaHRlZEFyY0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gMzsgLy8gVGhpY2tlc3Qgc3Ryb2tlIGZvciBzb3VyY2UgYXJjXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFN0cm9rZSBmb3IgY29ubmVjdGVkIGFyY3Mgd2hlbiByaWdodCBzaWRlIGlzIGhpZ2hsaWdodGVkXG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ3JpZ2h0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhWYWx1ZSA9IGNvbm5lY3Rpb25NYXRyaXhbaV0gJiYgY29ubmVjdGlvbk1hdHJpeFtpXVtoaWdobGlnaHRlZEFyY0luZGV4XTtcbiAgICAgICAgICAgIGlmIChtYXRyaXhWYWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDI7IC8vIE1lZGl1bSBzdHJva2UgZm9yIGNvbm5lY3RlZCBhcmNzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdzdHJva2UnLCAoZCwgaSkgPT4ge1xuICAgICAgICAvLyBFbmhhbmNlZCBzdHJva2UgY29sb3IgZm9yIHJlbGF0aW9uc2hpcCBjaGFpblxuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ2xlZnQnICYmIGkgPT09IGhpZ2hsaWdodGVkQXJjSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScgOiAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU3Ryb2tlIGZvciBjb25uZWN0ZWQgYXJjcyB3aGVuIHJpZ2h0IHNpZGUgaXMgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAncmlnaHQnICYmIGhpZ2hsaWdodGVkQXJjSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeFZhbHVlID0gY29ubmVjdGlvbk1hdHJpeFtpXSAmJiBjb25uZWN0aW9uTWF0cml4W2ldW2hpZ2hsaWdodGVkQXJjSW5kZXhdO1xuICAgICAgICAgICAgaWYgKG1hdHJpeFZhbHVlID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMyknIDogJ3JnYmEoMCwwLDAsMC4yKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICB9KTtcbiAgICAvLyBDcmVhdGUgcmlnaHQgYXJjcyB3aXRoIGV2ZW50IGhhbmRsZXJzIGZpcnN0XG4gICAgY29uc3QgcmlnaHRBcmNTZWxlY3Rpb24gPSBnLnNlbGVjdEFsbCgncGF0aC5yaWdodC1hcmMnKVxuICAgICAgLmRhdGEocmlnaHRBcmNzKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ3JpZ2h0LWFyYycpXG4gICAgICAuYXR0cignZCcsIGQgPT4gYXJjR2VuKHsgc3RhcnRBbmdsZTogZC5zdGFydEFuZ2xlLCBlbmRBbmdsZTogZC5lbmRBbmdsZSB9IGFzIGFueSkpXG4gICAgICAuYXR0cignZmlsbCcsIChkLCBpKSA9PiBgdXJsKCNyaWdodC1hcmMtZ3JhZGllbnQtJHtpfSlgKVxuICAgICAgLmF0dHIoJ29wYWNpdHknLCAwKVxuICAgICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZXZlbnQsIGQ6IGFueSkge1xuICAgICAgICBwYXVzZUFuaW1hdGlvbignYXJjIGhvdmVyJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBzYW1lIGhpZ2hsaWdodGluZyBhcyBhdXRvLWN5Y2xlIGFuaW1hdGlvblxuICAgICAgICBjb25zdCBhcmNJbmRleCA9IHJpZ2h0QXJjcy5maW5kSW5kZXgoYXJjID0+IGFyYy5uYW1lID09PSBkLm5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZygn8J+OryBIb3ZlciB0cmlnZ2VyaW5nIHJpZ2h0IGFyYyBoaWdobGlnaHRpbmc6Jywge1xuICAgICAgICAgIGFyY05hbWU6IGQubmFtZSxcbiAgICAgICAgICBhcmNJbmRleDogYXJjSW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnaGlnaGxpZ2h0aW5nJyk7XG4gICAgICAgIHNldEhpZ2hsaWdodGVkQXJjSW5kZXgoYXJjSW5kZXgpO1xuICAgICAgICBzZXRIaWdobGlnaHRlZFNpZGUoJ3JpZ2h0Jyk7XG4gICAgICAgIFxuICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICB4OiBldmVudC5wYWdlWCxcbiAgICAgICAgICB5OiBldmVudC5wYWdlWSxcbiAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdib2xkJywgbWFyZ2luQm90dG9tOiA0IH19PnsoZC5uYW1lIHx8ICdVbmtub3duJykudG9TdHJpbmcoKS5yZXBsYWNlKC9fL2csICcgJyl9PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXY+Q291bnQ6IHtkLnZhbHVlfTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgIHJlc3VtZUFuaW1hdGlvbignYXJjIGhvdmVyIGVuZCcpO1xuICAgICAgICBzZXRUb29sdGlwKG51bGwpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgaGlnaGxpZ2h0aW5nIHdoZW4gYW5pbWF0aW9uIHJlc3VtZXNcbiAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRBcmNJbmRleChudWxsKTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRTaWRlKG51bGwpO1xuICAgICAgfSk7XG4gICAgXG4gICAgLy8gQXBwbHkgdHJhbnNpdGlvbiBhbmltYXRpb25zIHNlcGFyYXRlbHlcbiAgICByaWdodEFyY1NlbGVjdGlvblxuICAgICAgLnRyYW5zaXRpb24odHJhbnNpdGlvbilcbiAgICAgIC5hdHRyKCdvcGFjaXR5JywgKGQsIGkpID0+IHtcbiAgICAgICAgLy8gQXBwbHkgZnVsbCByZWxhdGlvbnNoaXAgY2hhaW4gaGlnaGxpZ2h0aW5nXG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAvLyBIaWdobGlnaHQgdGhlIHNvdXJjZSBhcmNcbiAgICAgICAgICAgIGlmIChpID09PSBoaWdobGlnaHRlZEFyY0luZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiAxLjA7IC8vIFNvdXJjZSBhcmMgaXMgZnVsbHkgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjQ7IC8vIERpbSBvdGhlciByaWdodCBhcmNzXG4gICAgICAgICAgfSBlbHNlIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdsZWZ0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGxlZnQgYXJjIGlzIGhpZ2hsaWdodGVkLCBoaWdobGlnaHQgcmlnaHQgYXJjcyBjb25uZWN0ZWQgdG8gaXRcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeFZhbHVlID0gY29ubmVjdGlvbk1hdHJpeFtoaWdobGlnaHRlZEFyY0luZGV4XSAmJiBjb25uZWN0aW9uTWF0cml4W2hpZ2hsaWdodGVkQXJjSW5kZXhdW2ldO1xuICAgICAgICAgICAgY29uc3QgaXNDb25uZWN0ZWRUb0hpZ2hsaWdodGVkTGVmdCA9IG1hdHJpeFZhbHVlID4gMDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SXIFJpZ2h0IGFyYyAke2l9ICgke3JpZ2h0QXJjc1tpXT8ubmFtZX0pIGNvbm5lY3RlZCB0byBsZWZ0IGFyYyAke2hpZ2hsaWdodGVkQXJjSW5kZXh9ICgke2xlZnRBcmNzW2hpZ2hsaWdodGVkQXJjSW5kZXhdPy5uYW1lfSk/YCwgXG4gICAgICAgICAgICAgIGlzQ29ubmVjdGVkVG9IaWdobGlnaHRlZExlZnQsICdNYXRyaXggdmFsdWU6JywgbWF0cml4VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkVG9IaWdobGlnaHRlZExlZnQgPyAwLjk1IDogMC4zOyAvLyBIaWdoZXIgY29udHJhc3RcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHN0YWJsZSBiYXNlIG9wYWNpdHkgd2l0aG91dCBwdWxzaW5nIHRvIHByZXZlbnQgZmxpY2tlcmluZ1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMC44LCBkLm9wYWNpdHkpO1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAoZCwgaSkgPT4ge1xuICAgICAgICAvLyBFbmhhbmNlZCBzdHJva2UgZm9yIHJlbGF0aW9uc2hpcCBjaGFpblxuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ3JpZ2h0JyAmJiBpID09PSBoaWdobGlnaHRlZEFyY0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gMzsgLy8gVGhpY2tlc3Qgc3Ryb2tlIGZvciBzb3VyY2UgYXJjXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFN0cm9rZSBmb3IgY29ubmVjdGVkIGFyY3Mgd2hlbiBsZWZ0IHNpZGUgaXMgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbWF0cml4VmFsdWUgPSBjb25uZWN0aW9uTWF0cml4W2hpZ2hsaWdodGVkQXJjSW5kZXhdICYmIGNvbm5lY3Rpb25NYXRyaXhbaGlnaGxpZ2h0ZWRBcmNJbmRleF1baV07XG4gICAgICAgICAgICBpZiAobWF0cml4VmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiAyOyAvLyBNZWRpdW0gc3Ryb2tlIGZvciBjb25uZWN0ZWQgYXJjc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pXG4gICAgICAuYXR0cignc3Ryb2tlJywgKGQsIGkpID0+IHtcbiAgICAgICAgLy8gRW5oYW5jZWQgc3Ryb2tlIGNvbG9yIGZvciByZWxhdGlvbnNoaXAgY2hhaW5cbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJyA6ICdyZ2JhKDAsMCwwLDAuMyknO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTdHJva2UgZm9yIGNvbm5lY3RlZCBhcmNzIHdoZW4gbGVmdCBzaWRlIGlzIGhpZ2hsaWdodGVkXG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ2xlZnQnICYmIGhpZ2hsaWdodGVkQXJjSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeFZhbHVlID0gY29ubmVjdGlvbk1hdHJpeFtoaWdobGlnaHRlZEFyY0luZGV4XSAmJiBjb25uZWN0aW9uTWF0cml4W2hpZ2hsaWdodGVkQXJjSW5kZXhdW2ldO1xuICAgICAgICAgICAgaWYgKG1hdHJpeFZhbHVlID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMyknIDogJ3JnYmEoMCwwLDAsMC4yKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICB9KTtcblxuICAgIC8vIERyYXcgcmliYm9ucyBmb3IgY29ubmVjdGlvbnMgKGRpc3RyaWJ1dGVkIGFsb25nIGFyYywgcHJvcG9ydGlvbmFsIHRoaWNrbmVzcylcbiAgICAvLyBVc2UgZDMucmliYm9uKCkgZm9yIGVhY2ggY29ubmVjdGlvbiwgYnV0IHNldCB0aGUgd2lkdGggYnkgdXNpbmcgdGhlIGZ1bGwgc2VnbWVudCBmb3IgZWFjaCBjb25uZWN0aW9uXG4gICAgY29uc3QgcmliYm9uUmFkaXVzID0gTWF0aC5tYXgoNjAsIHJhZGl1cyAqIDAuNzUpOyAvLyBFbnN1cmUgbWluaW11bSByYWRpdXMgZm9yIHJpYmJvbnNcbiAgICBjb25zdCByaWJib25HZW4gPSBkMy5yaWJib24oKS5yYWRpdXMocmliYm9uUmFkaXVzKTtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFyZ2V0QXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb25uZWN0aW9uTWF0cml4W2ldW2pdO1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgc2VnbWVudCBmb3IgdGhpcyBjb25uZWN0aW9uIG9uIGJvdGggYXJjc1xuICAgICAgICAgIGNvbnN0IGxlZnRTZWcgPSBsZWZ0QXJjc1tpXTtcbiAgICAgICAgICBjb25zdCByaWdodFNlZyA9IHJpZ2h0QXJjc1tqXTtcbiAgICAgICAgICAvLyBDb21wdXRlIGFyYyBtaWRwb2ludHMgZm9yIGdyYWRpZW50IGRpcmVjdGlvblxuICAgICAgICAgIGNvbnN0IGxlZnRNaWRBbmdsZSA9IChsZWZ0U2VnLnN0YXJ0QW5nbGUgKyBsZWZ0U2VnLmVuZEFuZ2xlKSAvIDIgLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgICBjb25zdCByaWdodE1pZEFuZ2xlID0gKHJpZ2h0U2VnLnN0YXJ0QW5nbGUgKyByaWdodFNlZy5lbmRBbmdsZSkgLyAyIC0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgY29uc3QgbGVmdFggPSBNYXRoLmNvcyhsZWZ0TWlkQW5nbGUpICogcmliYm9uUmFkaXVzO1xuICAgICAgICAgIGNvbnN0IGxlZnRZID0gTWF0aC5zaW4obGVmdE1pZEFuZ2xlKSAqIHJpYmJvblJhZGl1cztcbiAgICAgICAgICBjb25zdCByaWdodFggPSBNYXRoLmNvcyhyaWdodE1pZEFuZ2xlKSAqIHJpYmJvblJhZGl1cztcbiAgICAgICAgICBjb25zdCByaWdodFkgPSBNYXRoLnNpbihyaWdodE1pZEFuZ2xlKSAqIHJpYmJvblJhZGl1cztcbiAgICAgICAgICAvLyBBZGQgZ3JhZGllbnQgZm9yIHRoaXMgcmliYm9uXG4gICAgICAgICAgY29uc3QgbGVmdENvbG9yID0gbGVmdEFyY3NbaV0uY29sb3IgfHwgZDMuc2NoZW1lQ2F0ZWdvcnkxMFtpICUgMTBdO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0Q29sb3IgPSByaWdodEFyY3Nbal0uY29sb3IgfHwgZDMuc2NoZW1lQ2F0ZWdvcnkxMFsoaiArIDUpICUgMTBdO1xuICAgICAgICAgIGRlZnMuYXBwZW5kKCdsaW5lYXJHcmFkaWVudCcpXG4gICAgICAgICAgICAuYXR0cignaWQnLCBgcmliYm9uLWdyYWRpZW50LSR7aX0tJHtqfWApXG4gICAgICAgICAgICAuYXR0cignZ3JhZGllbnRVbml0cycsICd1c2VyU3BhY2VPblVzZScpXG4gICAgICAgICAgICAuYXR0cigneDEnLCBsZWZ0WClcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIGxlZnRZKVxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgcmlnaHRYKVxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgcmlnaHRZKVxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnc3RvcCcpXG4gICAgICAgICAgICAuZGF0YShbXG4gICAgICAgICAgICAgIHsgb2Zmc2V0OiAnMCUnLCBjb2xvcjogbGVmdENvbG9yIH0sXG4gICAgICAgICAgICAgIHsgb2Zmc2V0OiAnMTAwJScsIGNvbG9yOiByaWdodENvbG9yIH1cbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3RvcCcpXG4gICAgICAgICAgICAuYXR0cignb2Zmc2V0JywgZCA9PiBkLm9mZnNldClcbiAgICAgICAgICAgIC5hdHRyKCdzdG9wLWNvbG9yJywgZCA9PiBkLmNvbG9yKTtcbiAgICAgICAgICBjb25uZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBsZWZ0U2VnLnN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgIGVuZEFuZ2xlOiBsZWZ0U2VnLmVuZEFuZ2xlLFxuICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICBzdGFydEFuZ2xlOiByaWdodFNlZy5zdGFydEFuZ2xlLFxuICAgICAgICAgICAgICBlbmRBbmdsZTogcmlnaHRTZWcuZW5kQW5nbGUsXG4gICAgICAgICAgICAgIGluZGV4OiBqXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0QXJjc1tpXSxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodEFyY3Nbal0sXG4gICAgICAgICAgICBncmFkaWVudElkOiBgcmliYm9uLWdyYWRpZW50LSR7aX0tJHtqfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBDcmVhdGUgcmliYm9ucyB3aXRoIGV2ZW50IGhhbmRsZXJzIGZpcnN0XG4gICAgY29uc3QgcmliYm9uU2VsZWN0aW9uID0gZy5zZWxlY3RBbGwoJ3BhdGgucmliYm9uJylcbiAgICAgIC5kYXRhKGNvbm5lY3Rpb25zKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ3JpYmJvbicpXG4gICAgICAuYXR0cignZCcsIGZ1bmN0aW9uKGQpIHsgY29uc3QgcGF0aCA9IHJpYmJvbkdlbih7IHNvdXJjZTogZC5zb3VyY2UsIHRhcmdldDogZC50YXJnZXQgfSBhcyBhbnkpOyByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnID8gcGF0aCA6ICcnOyB9KVxuICAgICAgLmF0dHIoJ2ZpbGwnLCBkID0+IGB1cmwoIyR7ZC5ncmFkaWVudElkfSlgKVxuICAgICAgLmF0dHIoJ29wYWNpdHknLCAwKVxuICAgICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZXZlbnQ6IGFueSwgZDogYW55KSB7XG4gICAgICAgIHBhdXNlQW5pbWF0aW9uKCdyaWJib24gaG92ZXInKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyaWdnZXIgaGlnaGxpZ2h0aW5nIGZvciB0aGUgc291cmNlIHNpZGUgb2YgdGhpcyByaWJib24gKHNhbWUgYXMgYXV0by1jeWNsZSlcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gSG92ZXIgdHJpZ2dlcmluZyByaWJib24gaGlnaGxpZ2h0aW5nOicsIHtcbiAgICAgICAgICBsZWZ0QXJjTmFtZTogZC5sZWZ0Lm5hbWUsXG4gICAgICAgICAgcmlnaHRBcmNOYW1lOiBkLnJpZ2h0Lm5hbWUsXG4gICAgICAgICAgc291cmNlSW5kZXg6IGQuc291cmNlLmluZGV4LFxuICAgICAgICAgIHRhcmdldEluZGV4OiBkLnRhcmdldC5pbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRBcmNJbmRleChkLnNvdXJjZS5pbmRleCk7XG4gICAgICAgIHNldEhpZ2hsaWdodGVkU2lkZSgnbGVmdCcpO1xuICAgICAgICBcbiAgICAgICAgc2V0VG9vbHRpcCh7XG4gICAgICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgeTogZXZlbnQucGFnZVksXG4gICAgICAgICAgY29udGVudDogKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcsIG1hcmdpbkJvdHRvbTogNCB9fT5cbiAgICAgICAgICAgICAgICB7KGQubGVmdC5uYW1lIHx8ICdVbmtub3duJykudG9TdHJpbmcoKS5yZXBsYWNlKC9fL2csICcgJyl9IOKGlCB7KGQucmlnaHQubmFtZSB8fCAnVW5rbm93bicpLnRvU3RyaW5nKCkucmVwbGFjZSgvXy9nLCAnICcpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdj5Db25uZWN0aW9uczoge2QudmFsdWV9PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKGV2ZW50LCBkKSB7XG4gICAgICAgIHJlc3VtZUFuaW1hdGlvbigncmliYm9uIGhvdmVyIGVuZCcpO1xuICAgICAgICBzZXRUb29sdGlwKG51bGwpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgaGlnaGxpZ2h0aW5nIHdoZW4gYW5pbWF0aW9uIHJlc3VtZXNcbiAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRBcmNJbmRleChudWxsKTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRTaWRlKG51bGwpO1xuICAgICAgfSk7XG4gICAgXG4gICAgLy8gQXBwbHkgdHJhbnNpdGlvbiBhbmltYXRpb25zIHNlcGFyYXRlbHlcbiAgICByaWJib25TZWxlY3Rpb25cbiAgICAgIC50cmFuc2l0aW9uKHRyYW5zaXRpb24pXG4gICAgICAuYXR0cignb3BhY2l0eScsIGQgPT4ge1xuICAgICAgICAvLyBIaWdobGlnaHQgcmliYm9ucyBjb25uZWN0ZWQgdG8gaGlnaGxpZ2h0ZWQgYXJjcyB3aXRoIGVuaGFuY2VkIHZpc2liaWxpdHlcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdsZWZ0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnNvdXJjZS5pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDAuOTU7IC8vIE1ha2UgY29ubmVjdGVkIHJpYmJvbnMgdmVyeSBwcm9taW5lbnRcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ3JpZ2h0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnRhcmdldC5pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDAuOTU7IC8vIE1ha2UgY29ubmVjdGVkIHJpYmJvbnMgdmVyeSBwcm9taW5lbnRcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDAuMjsgLy8gRGltIG5vbi1jb25uZWN0ZWQgcmliYm9ucyBtb3JlIGZvciBiZXR0ZXIgY29udHJhc3RcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2Ugc3RhYmxlIGJhc2Ugb3BhY2l0eSB3aXRob3V0IHB1bHNpbmdcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjcgOiAwLjY7XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGQgPT4ge1xuICAgICAgICAvLyBFbmhhbmNlZCBzdHJva2UgZm9yIGhpZ2hsaWdodGVkIHJpYmJvbnMgdG8gc2hvdyBjb25uZWN0aW9ucyBjbGVhcmx5XG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ2xlZnQnICYmIGhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQuc291cmNlLmluZGV4KSB8fFxuICAgICAgICAgICAgICAoaGlnaGxpZ2h0ZWRTaWRlID09PSAncmlnaHQnICYmIGhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQudGFyZ2V0LmluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIDIuNTsgLy8gU2xpZ2h0bHkgdGhpY2tlciBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgIH0pXG4gICAgICAuYXR0cignc3Ryb2tlJywgZCA9PiB7XG4gICAgICAgIC8vIEVuaGFuY2VkIHN0cm9rZSBjb2xvciBmb3IgaGlnaGxpZ2h0ZWQgY29ubmVjdGlvbnNcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmICgoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXgpIHx8XG4gICAgICAgICAgICAgIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknIDogJ3JnYmEoMCwwLDAsMC4zKSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICB9KTtcblxuICAgIC8vIC0tLSBMYWJlbCBwbGFjZW1lbnQ6IHByb3Blcmx5IHNwYWNlZCBhcm91bmQgY2lyY2xlIC0tLVxuICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gTWF0aC5tYXgoMTIwLCByYWRpdXMgKiAxLjQ1KTsgLy8gRXZlbiBtb3JlIHNwYWNlIGZvciBmdWxsIHRleHQgbGFiZWxzXG4gICAgY29uc3QgbGFiZWxHcm91cCA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnQgKyBlZmZlY3RpdmVDaGFydFdpZHRoIC8gMn0sICR7bWFyZ2luLnRvcCArIGVmZmVjdGl2ZUNoYXJ0SGVpZ2h0IC8gMn0pYCk7XG4gICAgXG4gICAgLy8gQ29tYmluZSBhbGwgYXJjcyBmb3IgdW5pZmllZCBsYWJlbCBwbGFjZW1lbnRcbiAgICBjb25zdCBhbGxBcmNzID0gWy4uLmxlZnRBcmNzLm1hcChhcmMgPT4gKHsuLi5hcmMsIHNpZGU6ICdsZWZ0J30pKSwgLi4ucmlnaHRBcmNzLm1hcChhcmMgPT4gKHsuLi5hcmMsIHNpZGU6ICdyaWdodCd9KSldO1xuICAgIFxuICAgIC8vIEFkZCBsYWJlbHMgd2l0aCBzbWFydCBwb3NpdGlvbmluZyB0byBhdm9pZCBvdmVybGFwXG4gICAgbGFiZWxHcm91cC5zZWxlY3RBbGwoJ3RleHQuYXJjLWxhYmVsJylcbiAgICAgIC5kYXRhKGFsbEFyY3MpXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAnYXJjLWxhYmVsJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoZC5zdGFydEFuZ2xlICsgZC5lbmRBbmdsZSkgLyAyIC0gTWF0aC5QSSAvIDI7XG4gICAgICAgIGNvbnN0IHggPSBsYWJlbFJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgY29uc3QgeSA9IGxhYmVsUmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGFuZ2xlICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJvdGF0ZSB0ZXh0IGZvciBiZXR0ZXIgcmVhZGFiaWxpdHlcbiAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgfHwgYW5nbGUgPCAtTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCAke3l9KSByb3RhdGUoJHtyb3RhdGlvbiArIDE4MH0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCAke3l9KSByb3RhdGUoJHtyb3RhdGlvbn0pYDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIGQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgfHwgYW5nbGUgPCAtTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpXG4gICAgICAuc3R5bGUoJ2ZvbnQtZmFtaWx5JywgbGFiZWxGb250RmFtaWx5KVxuICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsIGxhYmVsRm9udFdlaWdodClcbiAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIGQgPT4ge1xuICAgICAgICAgLy8gRHluYW1pYyBmb250IHNpemUgYmFzZWQgb24gbnVtYmVyIG9mIGxhYmVscyAtIGxhcmdlciBzaW5jZSB3ZSdyZSBzaG93aW5nIGZ1bGwgdGV4dFxuICAgICAgICAgY29uc3QgdG90YWxMYWJlbHMgPSBhbGxBcmNzLmxlbmd0aDtcbiAgICAgICAgIGlmICh0b3RhbExhYmVscyA+IDEyKSByZXR1cm4gJzEzcHgnO1xuICAgICAgICAgaWYgKHRvdGFsTGFiZWxzID4gMTApIHJldHVybiAnMTRweCc7XG4gICAgICAgICBpZiAodG90YWxMYWJlbHMgPiA4KSByZXR1cm4gJzE1cHgnO1xuICAgICAgICAgcmV0dXJuIGAke01hdGgubWF4KDE2LCBsYWJlbEZvbnRTaXplKX1weGA7XG4gICAgICAgfSlcbiAgICAgICAuc3R5bGUoJ2ZpbGwnLCBsYWJlbENvbG9yKVxuICAgICAgIC5zdHlsZSgndGV4dC10cmFuc2Zvcm0nLCAndXBwZXJjYXNlJylcbiAgICAgICAudGV4dChkID0+IHtcbiAgICAgICAgIGNvbnN0IHRleHQgPSAoZC5uYW1lIHx8ICdVbmtub3duJykudG9TdHJpbmcoKS5yZXBsYWNlKC9fL2csICcgJyk7XG4gICAgICAgICAvLyBTaG93IGZ1bGwgdGV4dCAtIG5vIHRydW5jYXRpb25cbiAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgIH0pXG4gICAgICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZXZlbnQsIGQpIHtcbiAgICAgICAgIHBhdXNlQW5pbWF0aW9uKCdsYWJlbCBob3ZlcicpO1xuICAgICAgICAgY29uc3QgZnVsbFRleHQgPSAoZC5uYW1lIHx8ICdVbmtub3duJykudG9TdHJpbmcoKS5yZXBsYWNlKC9fL2csICcgJyk7XG4gICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgIHk6IGV2ZW50LnBhZ2VZLFxuICAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5Cb3R0b206IDQgfX0+e2Z1bGxUZXh0fTwvZGl2PlxuICAgICAgICAgICAgICAgPGRpdj5Db3VudDoge2QudmFsdWV9PC9kaXY+XG4gICAgICAgICAgICAgICA8ZGl2PlNpZGU6IHtkLnNpZGV9PC9kaXY+XG4gICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgIClcbiAgICAgICAgIH0pO1xuICAgICAgIH0pXG4gICAgICAgLm9uKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgICAgICAgcmVzdW1lQW5pbWF0aW9uKCdsYWJlbCBob3ZlciBlbmQnKTtcbiAgICAgICAgIHNldFRvb2x0aXAobnVsbCk7XG4gICAgICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgaW5zaWdodHNcbiAgICBjb25zdCB0b3RhbENvbm5lY3Rpb25zID0gY29ubmVjdGlvbnMucmVkdWNlKChzdW0sIGQpID0+IHN1bSArIGQudmFsdWUsIDApO1xuICAgIGNvbnN0IHN0cm9uZ2VzdENvbm5lY3Rpb24gPSBjb25uZWN0aW9ucy5sZW5ndGggPiAwIFxuICAgICAgPyBjb25uZWN0aW9ucy5yZWR1Y2UoKG1heCwgZCkgPT4gZC52YWx1ZSA+IG1heC52YWx1ZSA/IGQgOiBtYXgsIGNvbm5lY3Rpb25zWzBdKVxuICAgICAgOiBudWxsO1xuICAgIHNldEluc2lnaHRzKFtcbiAgICAgIHsgdGl0bGU6ICdUb3RhbCBSZXNwb25zZXMnLCB2YWx1ZTogZmlsdGVyZWREYXRhLmxlbmd0aC50b1N0cmluZygpIH0sXG4gICAgICB7IHRpdGxlOiAnQ3VycmVudCBWaWV3JywgdmFsdWU6IGAke2N1cnJlbnRTb3VyY2V9IOKGlCAke2N1cnJlbnRUYXJnZXR9YCB9LFxuICAgICAgc3Ryb25nZXN0Q29ubmVjdGlvblxuICAgICAgICA/IHsgXG4gICAgICAgICAgICB0aXRsZTogJ1N0cm9uZ2VzdCBDb25uZWN0aW9uJywgXG4gICAgICAgICAgICB2YWx1ZTogYCR7c3Ryb25nZXN0Q29ubmVjdGlvbi5sZWZ0Lm5hbWUgfHwgJ1Vua25vd24nfSDihpQgJHtzdHJvbmdlc3RDb25uZWN0aW9uLnJpZ2h0Lm5hbWUgfHwgJ1Vua25vd24nfWAsIFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke3N0cm9uZ2VzdENvbm5lY3Rpb24udmFsdWV9IGNvbm5lY3Rpb25zYCBcbiAgICAgICAgICB9XG4gICAgICAgIDogeyB0aXRsZTogJ1N0cm9uZ2VzdCBDb25uZWN0aW9uJywgdmFsdWU6ICdObyBjb25uZWN0aW9ucyBmb3VuZCcsIGRlc2NyaXB0aW9uOiAnJyB9LFxuICAgICAgeyB0aXRsZTogJ1RvdGFsIENvbm5lY3Rpb25zJywgdmFsdWU6IHRvdGFsQ29ubmVjdGlvbnMudG9TdHJpbmcoKSB9LFxuICAgIF0pO1xuXG4gIH0sIFtkYXRhLCBjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0LCBzZXR0aW5ncy51c2VUZXN0RGF0YSwgc2V0dGluZ3MuY2F0ZWdvcnlDb2xvcnMsIGlzTG9hZGluZywgbGFzdENhdGVnb3J5Q2hhbmdlLCBpc0NvbnRhaW5lclRvb1NtYWxsLCBjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgc2hvd1NlY29uZGFyeUNob3JkLCBzZXR0aW5ncy5pc0RhcmtNb2RlXSk7XG5cbiAgLy8gUmVuZGVyIHNlY29uZGFyeSBjaG9yZCB3aGVuIHBlYWsgcGVyZm9ybWFuY2UgaXMgaW52b2x2ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2hvd1NlY29uZGFyeUNob3JkKSB7XG4gICAgICByZW5kZXJTZWNvbmRhcnlDaG9yZCgpO1xuICAgIH1cbiAgfSwgW3Nob3dTZWNvbmRhcnlDaG9yZCwgZGF0YSwgc2V0dGluZ3MudXNlVGVzdERhdGEsIHNldHRpbmdzLmlzRGFya01vZGUsIGxhYmVsQ29sb3JdKTtcblxuICAvLyBUb29sdGlwIHJlbmRlcmluZ1xuICBjb25zdCB0b29sdGlwRWwgPSB0b29sdGlwID8gKFxuICAgIDxkaXZcbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBsZWZ0OiB0b29sdGlwLnggKyAxNixcbiAgICAgICAgdG9wOiB0b29sdGlwLnkgKyAxNixcbiAgICAgICAgYmFja2dyb3VuZDogJ3JnYmEoMjAsMjAsMzAsMC45OCknLFxuICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICBwYWRkaW5nOiAnMTBweCAxNnB4JyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiA4LFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgIHpJbmRleDogMTAwLFxuICAgICAgICBmb250RmFtaWx5OiAnQXZlbmlyIE5leHQgV29ybGQsIHNhbnMtc2VyaWYnLFxuICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgIGZvbnRTaXplOiAxNixcbiAgICAgICAgYm94U2hhZG93OiAnMCA0cHggMjRweCAwIHJnYmEoMTYsIDE2LCAyMzUsIDAuMTIpJyxcbiAgICAgICAgbWF4V2lkdGg6IDMyMCxcbiAgICAgIH19XG4gICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICBhcmlhLWxpdmU9XCJwb2xpdGVcIlxuICAgID5cbiAgICAgIHt0b29sdGlwLmNvbnRlbnR9XG4gICAgPC9kaXY+XG4gICkgOiBudWxsO1xuXG4gIC8vIEFwcGx5IHRoZW1lIGJhc2VkIG9uIGdsb2JhbCBzZXR0aW5nc1xuICBjb25zdCB0aGVtZUNsYXNzID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdkYXJrJyA6ICcnO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJyMxYTFhMWEnIDogJyNmZmZmZmYnO1xuICBjb25zdCB0ZXh0Q29sb3IgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJyNmZmZmZmYnIDogJyMwQTBBMEYnO1xuXG4gIC8vIEhhbmRsZSBjYXNlIHdoZXJlIGNvbnRhaW5lciBpcyB0b28gc21hbGxcbiAgaWYgKGlzQ29udGFpbmVyVG9vU21hbGwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e2B3LWZ1bGwgaC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyICR7dGhlbWVDbGFzc31gfSBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3IgfX0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIiBzdHlsZT17eyBjb2xvcjogdGV4dENvbG9yIH19PlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtbGcgbWItMlwiPkNvbnRhaW5lciB0b28gc21hbGw8L3A+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSBvcGFjaXR5LTcwXCI+TWluaW11bSBzaXplOiAxMDB4MTAwcHg8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2B3LWZ1bGwgaC1mdWxsIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyICR7dGhlbWVDbGFzc31gfSBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3IgfX0+XG4gICAgICA8R2xvYmFsQ29udHJvbHNOYXYgLz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtYi00XCI+XG4gICAgICAgICAgPFF1ZXN0aW9uU2VsZWN0b3JcbiAgICAgICAgICAgIGF2YWlsYWJsZUZpZWxkcz17YXZhaWxhYmxlRmllbGRzfVxuICAgICAgICAgICAgY3VycmVudFNvdXJjZT17Y3VycmVudFNvdXJjZX1cbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ9e2N1cnJlbnRUYXJnZXR9XG4gICAgICAgICAgICBvbkNoYW5nZT17KHNvdXJjZSwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RlZCA9IGVuc3VyZURpZmZlcmVudENhdGVnb3JpZXMoc291cmNlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICBzZXRDdXJyZW50U291cmNlKGNvcnJlY3RlZC5zb3VyY2UpO1xuICAgICAgICAgICAgICBzZXRDdXJyZW50VGFyZ2V0KGNvcnJlY3RlZC50YXJnZXQpO1xuICAgICAgICAgICAgICBzZXRMYXN0Q2F0ZWdvcnlDaGFuZ2UoY29ycmVjdGVkKTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHJlbGF0aXZlXCJcbiAgICAgICAgICBzdHlsZT17eyBoZWlnaHQ6IGhlaWdodCAqIDAuODUgfX0gLy8gVXNlIDg1JSBvZiBhdmFpbGFibGUgaGVpZ2h0IGZvciB0aGUgY2hhcnQgdG8gYWNjb3VudCBmb3IgbGFiZWxzXG4gICAgICAgID5cbiAgICAgICAgICB7c2hvd1NlY29uZGFyeUNob3JkID8gKFxuICAgICAgICAgICAgLy8gVHdvLWNob3JkIGxheW91dCB3aGVuIHBlYWsgcGVyZm9ybWFuY2UgaXMgaW52b2x2ZWRcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGdhcC0xNlwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTRcIiBzdHlsZT17eyBjb2xvcjogdGV4dENvbG9yIH19PlxuICAgICAgICAgICAgICAgICAgTWFpbiBSZWxhdGlvbnNoaXBzXG4gICAgICAgICAgICAgICAgPC9oMz5cbiAgICAgICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgICAgICByZWY9e3N2Z1JlZn1cbiAgICAgICAgICAgICAgICAgIHdpZHRoPXt3aWR0aCAqIDAuNDV9XG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodCAqIDAuOH1cbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdibG9jaycsIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsIGNvbG9yOiB0ZXh0Q29sb3IgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi00XCIgc3R5bGU9e3sgY29sb3I6IHRleHRDb2xvciB9fT5cbiAgICAgICAgICAgICAgICAgIFllYXJzIMOXIFBlcmZvcm1hbmNlIFR5cGVzXG4gICAgICAgICAgICAgICAgPC9oMz5cbiAgICAgICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgICAgICByZWY9e3NlY29uZGFyeVN2Z1JlZn1cbiAgICAgICAgICAgICAgICAgIHdpZHRoPXt3aWR0aCAqIDAuNDV9XG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodCAqIDAuOH1cbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdibG9jaycsIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsIGNvbG9yOiB0ZXh0Q29sb3IgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAvLyBTaW5nbGUgY2hvcmQgbGF5b3V0IHdoZW4gcGVhayBwZXJmb3JtYW5jZSBpcyBub3QgaW52b2x2ZWRcbiAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgcmVmPXtzdmdSZWZ9XG4gICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgICAgaGVpZ2h0PXtoZWlnaHQgKiAwLjg1fVxuICAgICAgICAgICAgICBzdHlsZT17eyBkaXNwbGF5OiAnYmxvY2snLCBtYXJnaW46ICcwIGF1dG8nLCBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLCBjb2xvcjogdGV4dENvbG9yIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAge3Rvb2x0aXBFbH1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hvcmREaWFncmFtKHByb3BzOiBDaG9yZERpYWdyYW1Qcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxFcnJvckJvdW5kYXJ5PlxuICAgICAgPENob3JkRGlhZ3JhbUludGVybmFsIHsuLi5wcm9wc30gLz5cbiAgICA8L0Vycm9yQm91bmRhcnk+XG4gICk7XG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiQ29tcG9uZW50IiwiZDMiLCJ1c2VWaXN1YWxpemF0aW9uRGF0YSIsIlF1ZXN0aW9uU2VsZWN0b3IiLCJwcm9jZXNzQ2hvcmREYXRhIiwiY3ljbGluZ01vZGVzIiwidXNlQXBwQ29udGV4dCIsIkdsb2JhbENvbnRyb2xzTmF2IiwiZ2V0WWVhcnNDYXRlZ29yeSIsImdldE5vZGVDb2xvciIsIm5vZGVOYW1lIiwiY2F0ZWdvcnkiLCJnbG9iYWxDb2xvcnMiLCJpc0RhcmtNb2RlIiwidGhlbWVDb2xvcnMiLCJkYXJrIiwibGlnaHQiLCJ5ZWFyc19hdF9tZWR0cm9uaWMiLCJsZWFybmluZ19zdHlsZSIsInBlYWtfcGVyZm9ybWFuY2UiLCJtb3RpdmF0aW9uIiwic2hhcGVkX2J5IiwiRXJyb3JCb3VuZGFyeSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIl8iLCJoYXNFcnJvciIsImNvbXBvbmVudERpZENhdGNoIiwiZXJyb3IiLCJlcnJvckluZm8iLCJjb25zb2xlIiwicmVuZGVyIiwic3RhdGUiLCJkaXYiLCJzdHlsZSIsImNvbG9yIiwicGFkZGluZyIsInByb3BzIiwiY2hpbGRyZW4iLCJjb25zdHJ1Y3RvciIsIkNob3JkRGlhZ3JhbUludGVybmFsIiwid2lkdGgiLCJoZWlnaHQiLCJhdXRvUGxheSIsIm9uUmVsYXRpb25zaGlwQ2hhbmdlIiwiZW5hYmxlUm90YXRpb24iLCJzaG93QWxsQ29ubmVjdGlvbnMiLCJzdmdSZWYiLCJzZWNvbmRhcnlTdmdSZWYiLCJkYXRhIiwiaXNMb2FkaW5nIiwiY3VycmVudFNvdXJjZSIsInNldEN1cnJlbnRTb3VyY2UiLCJzb3VyY2UiLCJjdXJyZW50VGFyZ2V0Iiwic2V0Q3VycmVudFRhcmdldCIsInRhcmdldCIsImluc2lnaHRzIiwic2V0SW5zaWdodHMiLCJ0b29sdGlwIiwic2V0VG9vbHRpcCIsInNldHRpbmdzIiwibGFzdENhdGVnb3J5Q2hhbmdlIiwic2V0TGFzdENhdGVnb3J5Q2hhbmdlIiwic2hvd1NlY29uZGFyeUNob3JkIiwic2V0U2hvd1NlY29uZGFyeUNob3JkIiwiYW5pbWF0aW9uUGhhc2UiLCJzZXRBbmltYXRpb25QaGFzZSIsImhpZ2hsaWdodGVkQXJjSW5kZXgiLCJzZXRIaWdobGlnaHRlZEFyY0luZGV4IiwiaGlnaGxpZ2h0ZWRTaWRlIiwic2V0SGlnaGxpZ2h0ZWRTaWRlIiwiaXNBbmltYXRpbmciLCJzZXRJc0FuaW1hdGluZyIsInNlY29uZGFyeUFuaW1hdGlvblBoYXNlIiwic2V0U2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UiLCJzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4Iiwic2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCIsInNlY29uZGFyeUhpZ2hsaWdodGVkU2lkZSIsInNldFNlY29uZGFyeUhpZ2hsaWdodGVkU2lkZSIsImFuaW1hdGlvblJlZiIsInRpbWVyIiwicnVubmluZyIsImN1cnJlbnRJbmRleCIsImN1cnJlbnRTaWRlIiwiaXNQYXVzZWQiLCJjeWNsZUNvdW50Iiwic2Vjb25kYXJ5QW5pbWF0aW9uUmVmIiwiYXZhaWxhYmxlRmllbGRzIiwidmFsdWUiLCJsYWJlbCIsImxhYmVsRm9udFNpemUiLCJsYWJlbEZvbnRXZWlnaHQiLCJsYWJlbENvbG9yIiwibGFiZWxGb250RmFtaWx5IiwiaXNQZWFrUGVyZm9ybWFuY2VJbnZvbHZlZCIsInJlbmRlclNlY29uZGFyeUNob3JkIiwiY3VycmVudCIsImxlbmd0aCIsInN2ZyIsInNlbGVjdCIsInNlbGVjdEFsbCIsInJlbW92ZSIsImZpbHRlcmVkRGF0YSIsInVzZVRlc3REYXRhIiwiZmlsdGVyIiwiaXRlbSIsInRlc3RfZGF0YSIsInNlY29uZGFyeURhdGEiLCJkIiwic2Vjb25kYXJ5V2lkdGgiLCJzZWNvbmRhcnlIZWlnaHQiLCJzZWNvbmRhcnlNYXJnaW4iLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJzZWNvbmRhcnlDaGFydFdpZHRoIiwic2Vjb25kYXJ5Q2hhcnRIZWlnaHQiLCJzZWNvbmRhcnlSYWRpdXMiLCJNYXRoIiwibWF4IiwibWluIiwieWVhcnNDYXRlZ29yaWVzIiwicGVha1BlcmZDYXRlZ29yaWVzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwibWFwIiwiQm9vbGVhbiIsInNvcnQiLCJhbGxDYXRlZ29yaWVzIiwibWF0cml4Iiwic291cmNlQ2F0ZWdvcnkiLCJzb3VyY2VJbmRleCIsInRhcmdldENhdGVnb3J5IiwidGFyZ2V0SW5kZXgiLCJzb3VyY2VJc1llYXJzIiwidGFyZ2V0SXNZZWFycyIsInllYXJzQ2F0IiwicGVyZkNhdCIsInllYXJzIiwicGVyZiIsImNob3JkTGF5b3V0IiwiY2hvcmQiLCJwYWRBbmdsZSIsImNob3JkRGF0YSIsImciLCJhcHBlbmQiLCJhdHRyIiwiYXJjIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsInJpYmJvbiIsInJhZGl1cyIsInllYXJzQ29sb3JzIiwicGVyZkNvbG9ycyIsImNvbG9ycyIsInNsaWNlIiwiZ3JvdXBTZWxlY3Rpb24iLCJncm91cHMiLCJlbnRlciIsImkiLCJvbiIsImV2ZW50IiwicGF1c2VBbmltYXRpb24iLCJsb2ciLCJncm91cEluZGV4IiwiaW5kZXgiLCJ4IiwicGFnZVgiLCJ5IiwicGFnZVkiLCJjb250ZW50IiwiZm9udFdlaWdodCIsIm1hcmdpbkJvdHRvbSIsInRvU3RyaW5nIiwicmVwbGFjZSIsInJlc3VtZUFuaW1hdGlvbiIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImlzQ29ubmVjdGVkIiwic29tZSIsImNob3JkU2VsZWN0aW9uIiwic2Vjb25kYXJ5TGFiZWxSYWRpdXMiLCJhbmdsZSIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsIlBJIiwiY29zIiwic2luIiwicm90YXRpb24iLCJ0b3RhbExhYmVscyIsInRleHQiLCJmdWxsVGV4dCIsImVuc3VyZURpZmZlcmVudENhdGVnb3JpZXMiLCJkaWZmZXJlbnRPcHRpb24iLCJmaW5kIiwiZmllbGQiLCJjb3JyZWN0ZWQiLCJjdXJyZW50TW9kZUluZGV4Iiwic2V0Q3VycmVudE1vZGVJbmRleCIsIm1vZGVJbmRleCIsImZpbmRJbmRleCIsIm1vZGUiLCJpc0F1dG9QbGF5RW5hYmxlZCIsImRhdGFMZW5ndGgiLCJjbGVhclRpbWVvdXQiLCJhbmltYXRlIiwibGVmdFZhbHVlcyIsInJpZ2h0VmFsdWVzIiwiY3VycmVudFNpZGVMZW5ndGgiLCJoaWdobGlnaHRlZENhdGVnb3J5IiwiaGFzRGF0YSIsInNvdXJjZVNpZGUiLCJ0b3RhbENhdGVnb3JpZXMiLCJzdGVwRHVyYXRpb24iLCJhdXRvUGxheVNwZWVkIiwicGF1c2VEdXJhdGlvbiIsInNldFRpbWVvdXQiLCJuZXh0TW9kZUluZGV4IiwiYW5pbWF0ZVNlY29uZGFyeSIsInNpZGUiLCJhY3R1YWxBcmNJbmRleCIsInJlYXNvbiIsIm1hcmdpbiIsImNoYXJ0V2lkdGgiLCJjaGFydEhlaWdodCIsImlzQ29udGFpbmVyVG9vU21hbGwiLCJlZmZlY3RpdmVXaWR0aCIsImVmZmVjdGl2ZUhlaWdodCIsImVmZmVjdGl2ZUNoYXJ0V2lkdGgiLCJlZmZlY3RpdmVDaGFydEhlaWdodCIsImRlZnMiLCJZRUFSU19HUk9VUFMiLCJzb3VyY2VDYXRlZ29yaWVzIiwidGFyZ2V0Q2F0ZWdvcmllcyIsImZvckVhY2giLCJhZGQiLCJzb3VyY2VBcnJheSIsInRhcmdldEFycmF5IiwibGVmdFRvdGFscyIsImNhdCIsInJpZ2h0VG90YWxzIiwibGVmdFRvdGFsU3VtIiwicmVkdWNlIiwic3VtIiwidmFsIiwicmlnaHRUb3RhbFN1bSIsImNvbm5lY3Rpb25NYXRyaXgiLCJzb3VyY2VDYXQiLCJ0YXJnZXRDYXQiLCJpc0NhdGVnb3J5Q2hhbmdlIiwiZWFzZSIsImVhc2VDdWJpY0luT3V0IiwiYXJjR2FwIiwibGVmdFN0YXJ0IiwibGVmdEVuZCIsInJpZ2h0U3RhcnQiLCJyaWdodEVuZCIsImxlZnRBcmNTcGFuIiwicmlnaHRBcmNTcGFuIiwibWluQXJjU3BhY2luZyIsImxlZnRBbmdsZSIsImxlZnRBcmNzIiwiY291bnQiLCJhdmFpbGFibGVTcGFuIiwiYXJjU3BhbiIsImNhdGVnb3J5Q29sb3JzIiwib3BhY2l0eSIsIm5hbWUiLCJyaWdodEFuZ2xlIiwicmlnaHRBcmNzIiwiYXJjR2VuIiwiY29ybmVyUmFkaXVzIiwiYmFzZUNvbG9yIiwibGlnaHRlckNvbG9yIiwiYnJpZ2h0ZXIiLCJvZmZzZXQiLCJsZWZ0QXJjU2VsZWN0aW9uIiwiYXJjSW5kZXgiLCJtYXRyaXhWYWx1ZSIsImlzQ29ubmVjdGVkVG9IaWdobGlnaHRlZFJpZ2h0IiwicmlnaHRBcmNTZWxlY3Rpb24iLCJhcmNOYW1lIiwiaXNDb25uZWN0ZWRUb0hpZ2hsaWdodGVkTGVmdCIsInJpYmJvblJhZGl1cyIsInJpYmJvbkdlbiIsImNvbm5lY3Rpb25zIiwiaiIsImxlZnRTZWciLCJyaWdodFNlZyIsImxlZnRNaWRBbmdsZSIsInJpZ2h0TWlkQW5nbGUiLCJsZWZ0WCIsImxlZnRZIiwicmlnaHRYIiwicmlnaHRZIiwibGVmdENvbG9yIiwic2NoZW1lQ2F0ZWdvcnkxMCIsInJpZ2h0Q29sb3IiLCJwdXNoIiwiZ3JhZGllbnRJZCIsInJpYmJvblNlbGVjdGlvbiIsInBhdGgiLCJsZWZ0QXJjTmFtZSIsInJpZ2h0QXJjTmFtZSIsImxhYmVsUmFkaXVzIiwibGFiZWxHcm91cCIsImFsbEFyY3MiLCJ0b3RhbENvbm5lY3Rpb25zIiwic3Ryb25nZXN0Q29ubmVjdGlvbiIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ0b29sdGlwRWwiLCJwb3NpdGlvbiIsImJhY2tncm91bmQiLCJib3JkZXJSYWRpdXMiLCJwb2ludGVyRXZlbnRzIiwiekluZGV4IiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwiYm94U2hhZG93IiwibWF4V2lkdGgiLCJyb2xlIiwiYXJpYS1saXZlIiwidGhlbWVDbGFzcyIsImJhY2tncm91bmRDb2xvciIsInRleHRDb2xvciIsImNsYXNzTmFtZSIsInAiLCJvbkNoYW5nZSIsImgzIiwicmVmIiwiZGlzcGxheSIsIkNob3JkRGlhZ3JhbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/DataVisualization/ChordDiagram.tsx\n"));

/***/ })

});