"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/visualization/page",{

/***/ "(app-pages-browser)/./src/components/DataVisualization/AlluvialDiagram.tsx":
/*!**************************************************************!*\
  !*** ./src/components/DataVisualization/AlluvialDiagram.tsx ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AlluvialDiagram; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\");\n/* harmony import */ var d3_sankey__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-sankey */ \"(app-pages-browser)/./node_modules/d3-sankey/src/index.js\");\n/* harmony import */ var _shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/useVisualizationData */ \"(app-pages-browser)/./src/components/DataVisualization/shared/useVisualizationData.ts\");\n/* harmony import */ var _shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shared/colorUtils */ \"(app-pages-browser)/./src/components/DataVisualization/shared/colorUtils.ts\");\n/* harmony import */ var _lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/context/AppContext */ \"(app-pages-browser)/./src/lib/context/AppContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst availableFields = [\n    {\n        value: \"years_at_medtronic\",\n        label: \"Years at Medtronic\"\n    },\n    {\n        value: \"learning_style\",\n        label: \"Learning Style\"\n    },\n    {\n        value: \"shaped_by\",\n        label: \"Shaped By\"\n    },\n    {\n        value: \"peak_performance\",\n        label: \"Peak Performance\"\n    },\n    {\n        value: \"motivation\",\n        label: \"Motivation\"\n    }\n];\nconst YEARS_CATEGORIES = [\n    \"0-5\",\n    \"6-10\",\n    \"11-15\",\n    \"16-20\",\n    \"20+\"\n];\n// Move this function up so it is defined before use\nconst getValidYearsCategory = (years)=>{\n    if (typeof years !== \"number\" || isNaN(years) || years < 0) return \"0-5\";\n    if (years <= 5) return \"0-5\";\n    if (years <= 10) return \"6-10\";\n    if (years <= 15) return \"11-15\";\n    if (years <= 20) return \"16-20\";\n    return \"20+\";\n};\n// Custom wave path generator for Sankey links with bounds checking\nfunction sankeyLinkWave(d) {\n    let waveAmplitude = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8, waveFrequency = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.1, chartWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 800, chartHeight = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 600;\n    // d has source/target: {x0, x1, y0, y1}\n    let x0 = d.source.x1;\n    let x1 = d.target.x0;\n    let y0 = d.y0;\n    let y1 = d.y1;\n    // Clamp coordinates to chart bounds to prevent overflow\n    x0 = Math.max(0, Math.min(chartWidth, x0));\n    x1 = Math.max(0, Math.min(chartWidth, x1));\n    y0 = Math.max(0, Math.min(chartHeight, y0));\n    y1 = Math.max(0, Math.min(chartHeight, y1));\n    const midX = (x0 + x1) / 2;\n    // Add a sine wave to the control points, but ensure they stay within bounds\n    const waveY0 = Math.max(0, Math.min(chartHeight, y0 + waveAmplitude * Math.sin(waveFrequency * Math.PI * 0.25)));\n    const waveY1 = Math.max(0, Math.min(chartHeight, y1 + waveAmplitude * Math.sin(waveFrequency * Math.PI * 0.75)));\n    return \"M\".concat(x0, \",\").concat(y0, \"\\n    C\").concat(midX, \",\").concat(waveY0, \" \").concat(midX, \",\").concat(waveY1, \" \").concat(x1, \",\").concat(y1);\n}\n// Custom horizontal link generator that clamps y0/y1 to node bounds\nfunction clampedSankeyLinkHorizontal() {\n    return function(d) {\n        // Clamp y0/y1 to node bounds\n        const sy = Math.max(d.source.y0, Math.min(d.source.y1, d.y0));\n        const ty = Math.max(d.target.y0, Math.min(d.target.y1, d.y1));\n        const x0 = d.source.x1;\n        const x1 = d.target.x0;\n        // Use a cubic Bezier for smoothness\n        const curvature = 0.5;\n        const xi = d3__WEBPACK_IMPORTED_MODULE_2__.interpolateNumber(x0, x1);\n        const x2 = xi(curvature);\n        const x3 = xi(1 - curvature);\n        return \"M\".concat(x0, \",\").concat(sy, \"C\").concat(x2, \",\").concat(sy, \" \").concat(x3, \",\").concat(ty, \" \").concat(x1, \",\").concat(ty);\n    };\n}\n// Note: Using theme-aware getNodeColor function from colorUtils\nfunction AlluvialDiagram(param) {\n    let { width = 800, height = 600, autoPlay = true, onQuestionChange } = param;\n    _s();\n    // Responsive: use state for width/height, fallback to props\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [containerWidth, setContainerWidth] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(width);\n    const [containerHeight, setContainerHeight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(height);\n    // Responsive: observe container size\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!containerRef.current) return;\n        const observer = new window.ResizeObserver((entries)=>{\n            for (let entry of entries){\n                if (entry.contentRect) {\n                    setContainerWidth(entry.contentRect.width);\n                    setContainerHeight(entry.contentRect.height);\n                }\n            }\n        });\n        observer.observe(containerRef.current);\n        return ()=>observer.disconnect();\n    }, []);\n    const svgRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { data, isLoading, error } = (0,_shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_4__.useVisualizationData)();\n    const { settings, getCurrentThemeColors } = (0,_lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__.useAppContext)();\n    const [currentSource, setCurrentSource] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"years_at_medtronic\");\n    const [currentTarget, setCurrentTarget] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"learning_style\");\n    // Filter data based on test data setting\n    const filteredData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!Array.isArray(data) || !data.length) return [];\n        return settings.useTestData ? data : data.filter((item)=>!item.test_data);\n    }, [\n        data,\n        settings.useTestData\n    ]);\n    // Compute sources and targets with validation\n    const sources = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!Array.isArray(filteredData) || !filteredData.length) return [];\n        if (currentSource === \"years_at_medtronic\") {\n            return YEARS_CATEGORIES.filter((cat)=>filteredData.some((d)=>getValidYearsCategory(d.years_at_medtronic || 0) === cat));\n        } else {\n            return Array.from(new Set(filteredData.map((d)=>d[currentSource]))).filter((value)=>typeof value === \"string\" && value.length > 0);\n        }\n    }, [\n        filteredData,\n        currentSource\n    ]);\n    const targets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!Array.isArray(filteredData) || !filteredData.length) return [];\n        if (currentTarget === \"years_at_medtronic\") {\n            return YEARS_CATEGORIES.filter((cat)=>filteredData.some((d)=>getValidYearsCategory(d.years_at_medtronic || 0) === cat));\n        } else {\n            // Sort target nodes consistently to maintain fixed positions\n            return Array.from(new Set(filteredData.map((d)=>currentTarget === \"years_at_medtronic\" ? getValidYearsCategory(d.years_at_medtronic || 0) : d[currentTarget]))).filter((value)=>typeof value === \"string\" && value.length > 0).sort(); // Add consistent sorting\n        }\n    }, [\n        filteredData,\n        currentTarget\n    ]);\n    // --- Responsive chart sizing based on data size ---\n    // Set sensible min/max chart dimensions\n    const MIN_CHART_HEIGHT = 180;\n    const MAX_CHART_HEIGHT = 700;\n    const MIN_CHART_WIDTH = 320;\n    const MAX_CHART_WIDTH = 1400;\n    // Calculate node count for sizing\n    const nodeCount = Math.max(sources.length, targets.length, 1);\n    // --- Sparse Data Tuning ---\n    // For sparse data, shrink chart and cap node/link size\n    let availableHeight = Math.max(MIN_CHART_HEIGHT, Math.min(containerHeight - 40, MAX_CHART_HEIGHT));\n    let availableWidth = Math.max(MIN_CHART_WIDTH, Math.min(containerWidth - margin.left - margin.right, MAX_CHART_WIDTH));\n    let maxNodeHeight = 48;\n    let maxLinkWidth = 32;\n    if (nodeCount <= 3) {\n        availableHeight = Math.max(MIN_CHART_HEIGHT, Math.min(220, availableHeight)); // Shrink chart height\n        availableWidth = Math.max(MIN_CHART_WIDTH, Math.min(420, availableWidth)); // Shrink chart width\n        maxNodeHeight = 28; // Cap node height\n        maxLinkWidth = 16; // Cap link thickness\n    }\n    if (nodeCount >= 10) {\n        availableHeight = Math.min(MAX_CHART_HEIGHT, Math.max(availableHeight, 500));\n        availableWidth = Math.min(MAX_CHART_WIDTH, Math.max(availableWidth, 900));\n    }\n    // Node height and padding logic\n    const minNodeHeight = 16;\n    const minPadding = 8;\n    let nodeHeight = Math.floor((availableHeight - (nodeCount + 1) * minPadding) / nodeCount);\n    nodeHeight = Math.max(minNodeHeight, Math.min(nodeHeight, maxNodeHeight));\n    let nodePadding = (availableHeight - nodeCount * nodeHeight) / (nodeCount + 1);\n    nodePadding = Math.max(nodePadding, minPadding);\n    // Dynamically scale label font size with node height (clamp between 12px and 28px)\n    const labelFontSize = Math.max(12, Math.min(28, Math.floor(nodeHeight * 0.5)));\n    // --- Dynamic margin calculation for full label visibility ---\n    // Helper to measure text width in px\n    function measureTextWidth(text, font) {\n        if (false) {} // fallback for SSR\n        if (!measureTextWidth._canvas) {\n            measureTextWidth._canvas = document.createElement(\"canvas\");\n        }\n        const canvas = measureTextWidth._canvas;\n        const context = canvas.getContext(\"2d\");\n        if (!context) return 100;\n        context.font = font;\n        return context.measureText(text).width;\n    }\n    // Font for measuring\n    const labelFont = \"bold \".concat(labelFontSize, \"px Avenir Next World, -apple-system, BlinkMacSystemFont, 'SF Pro', 'Roboto', sans-serif\");\n    const allLabels = [\n        ...sources,\n        ...targets\n    ];\n    const labelWidths = allLabels.map((label)=>measureTextWidth(label, labelFont));\n    const maxLabelWidth = Math.max(...labelWidths, 80); // fallback min\n    const labelPadding = 24;\n    const margin = {\n        top: 20,\n        right: maxLabelWidth + labelPadding,\n        bottom: 20,\n        left: maxLabelWidth + labelPadding\n    };\n    // Responsive chart width\n    let chartWidth = Math.max(MIN_CHART_WIDTH, Math.min(containerWidth - margin.left - margin.right, MAX_CHART_WIDTH));\n    let chartHeight = availableHeight;\n    // If very sparse, shrink width too\n    if (nodeCount <= 3) {\n        chartWidth = Math.max(MIN_CHART_WIDTH, Math.min(chartWidth, 480));\n    }\n    // If very dense, allow more width\n    if (nodeCount >= 10) {\n        chartWidth = Math.min(MAX_CHART_WIDTH, Math.max(chartWidth, 900));\n    }\n    // Debug logging\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"[AlluvialDiagram Debug]\");\n        console.log(\"  Container:\", containerWidth, \"x\", containerHeight);\n        console.log(\"  Chart:\", chartWidth, \"x\", chartHeight);\n        console.log(\"  Node count (sources/targets):\", sources.length, targets.length);\n        console.log(\"  nodeHeight:\", nodeHeight);\n        console.log(\"  nodePadding:\", nodePadding);\n        console.log(\"  labelFontSize:\", labelFontSize);\n    }, [\n        containerWidth,\n        containerHeight,\n        chartWidth,\n        chartHeight,\n        sources.length,\n        targets.length,\n        nodeHeight,\n        nodePadding,\n        labelFontSize\n    ]);\n    // Use refs to track current values without triggering re-renders\n    const currentSourceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(currentSource);\n    const currentTargetRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(currentTarget);\n    // Update refs when state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentSourceRef.current = currentSource;\n    }, [\n        currentSource\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentTargetRef.current = currentTarget;\n    }, [\n        currentTarget\n    ]);\n    const [insights, setInsights] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [hoveredNode, setHoveredNode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [hoveredLink, setHoveredLink] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [tooltip, setTooltip] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [lastCategoryChange, setLastCategoryChange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        source: currentSource,\n        target: currentTarget\n    });\n    const [currentTargetIndex, setCurrentTargetIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [isAnimating, setIsAnimating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [hoveredSourceIndex, setHoveredSourceIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [hoveredTargetIndex, setHoveredTargetIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isInFullOpacityState, setIsInFullOpacityState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [animationPhase, setAnimationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"full\");\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        timer: null,\n        running: false,\n        currentSourceIndex: 0,\n        currentTargetIndex: 0,\n        isPaused: false,\n        pausedAt: Date.now(),\n        resumeFrom: null,\n        cycleCount: 0\n    });\n    // Check for reduced motion preference\n    const prefersReducedMotion = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (false) {}\n        return window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\n    }, []);\n    // Adjust animation durations based on motion preference\n    const animationDurations = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const baseSpeed = settings.autoPlaySpeed || 3000;\n        const reductionFactor = prefersReducedMotion ? 0.5 : 1;\n        return {\n            stepDuration: Math.max(800, baseSpeed / 8 * reductionFactor),\n            pauseDuration: Math.max(400, baseSpeed / 12 * reductionFactor),\n            categoryPauseDuration: Math.max(1500, baseSpeed / 3 * reductionFactor),\n            linkTransitionDuration: prefersReducedMotion ? 400 : 750\n        };\n    }, [\n        settings.autoPlaySpeed,\n        prefersReducedMotion\n    ]);\n    // Get visual order of source nodes (top-to-bottom as they appear)\n    const sortedSources = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!filteredData.length || !chartWidth || !chartHeight) return sources;\n        const sourcesForNodes = [\n            ...sources\n        ];\n        if (currentSource === \"years_at_medtronic\") {\n            sourcesForNodes.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sourcesForNodes.sort();\n        }\n        // Create Sankey layout to get visual order\n        const nodes = [\n            ...sourcesForNodes.map((name)=>({\n                    id: \"\".concat(currentSource, \":\").concat(name),\n                    name,\n                    category: currentSource\n                })),\n            ...targets.map((name)=>({\n                    id: \"\".concat(currentTarget, \":\").concat(name),\n                    name,\n                    category: currentTarget\n                }))\n        ];\n        const linksMap = new Map();\n        filteredData.forEach((d)=>{\n            const source = currentSource === \"years_at_medtronic\" ? getValidYearsCategory(d.years_at_medtronic || 0) : d[currentSource];\n            const target = currentTarget === \"years_at_medtronic\" ? getValidYearsCategory(d.years_at_medtronic || 0) : d[currentTarget];\n            if (!sourcesForNodes.includes(source) || !targets.includes(target)) return;\n            const sourceId = \"\".concat(currentSource, \":\").concat(source);\n            const targetId = \"\".concat(currentTarget, \":\").concat(target);\n            const key = \"\".concat(sourceId, \"→\").concat(targetId);\n            if (!linksMap.has(key)) {\n                linksMap.set(key, {\n                    source: sourceId,\n                    target: targetId,\n                    value: 0\n                });\n            }\n            linksMap.get(key).value += 1;\n        });\n        const links = Array.from(linksMap.values());\n        const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(nodePadding).extent([\n            [\n                0,\n                0\n            ],\n            [\n                chartWidth,\n                chartHeight\n            ]\n        ]);\n        const sankeyData = sankeyGenerator({\n            nodes: nodes.map((d)=>({\n                    ...d\n                })),\n            links: links.map((d)=>({\n                    ...d\n                }))\n        });\n        // Get source nodes in visual order (top to bottom)\n        const sourceNodes = sankeyData.nodes.filter((d)=>d.category === currentSource).sort((a, b)=>a.y0 - b.y0);\n        return sourceNodes.map((d)=>d.name);\n    }, [\n        filteredData,\n        sources,\n        targets,\n        currentSource,\n        currentTarget,\n        chartWidth,\n        chartHeight,\n        nodePadding\n    ]);\n    // Enhanced animation function with comprehensive debug tracking\n    const animate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        // Check if animation is paused\n        if (animationRef.current.isPaused) {\n            console.log(\"⏸️  Animation is paused, skipping cycle\");\n            return;\n        }\n        if (!animationRef.current.running || !filteredData.length) {\n            console.log(\"❌ Animation stopped:\", {\n                running: animationRef.current.running,\n                dataLength: filteredData.length\n            });\n            return;\n        }\n        // Safety check: prevent infinite loops\n        if (animationRef.current.cycleCount > 1000) {\n            console.log(\"\\uD83D\\uDED1 Animation cycle limit reached, resetting\");\n            animationRef.current.cycleCount = 0;\n            animationRef.current.currentSourceIndex = 0;\n            animationRef.current.currentTargetIndex = 0;\n        }\n        // Increment cycle counter\n        animationRef.current.cycleCount++;\n        // Set animation phase to highlighting\n        setAnimationPhase(\"highlighting\");\n        setIsInFullOpacityState(false);\n        // Set the hovered source index to match the animation\n        setHoveredSourceIndex(animationRef.current.currentSourceIndex);\n        const targetOptions = availableFields.filter((f)=>f.value !== currentSourceRef.current).map((f)=>f.value);\n        // Debug: Log the target options to verify they're correct\n        if (animationRef.current.currentSourceIndex === 0) {\n            console.log(\"\\uD83C\\uDFAF Available target options for\", currentSourceRef.current, \":\", targetOptions);\n        }\n        // COMPREHENSIVE DEBUG: Log current state with full detail\n        console.log(\"\\uD83D\\uDD0D ANIMATION CYCLE DEBUG:\", {\n            \"\\uD83D\\uDCCD Current Position\": {\n                sourceIndex: animationRef.current.currentSourceIndex,\n                targetIndex: animationRef.current.currentTargetIndex,\n                sourceName: sortedSources[animationRef.current.currentSourceIndex],\n                targetName: currentTargetRef.current\n            },\n            \"\\uD83D\\uDCCA Categories\": {\n                currentSource: currentSourceRef.current,\n                currentTarget: currentTargetRef.current,\n                sourceOptions: availableFields.map((f)=>f.value),\n                targetOptions\n            },\n            \"\\uD83D\\uDCC8 Progress\": {\n                sourceProgress: \"\".concat(animationRef.current.currentSourceIndex + 1, \"/\").concat(sortedSources.length),\n                targetProgress: \"\".concat(animationRef.current.currentTargetIndex + 1, \"/\").concat(targetOptions.length),\n                isLastSource: animationRef.current.currentSourceIndex >= sortedSources.length - 1,\n                hasMoreTargets: animationRef.current.currentTargetIndex < targetOptions.length - 1\n            },\n            \"\\uD83C\\uDFAF Sources\": sortedSources,\n            \"\\uD83C\\uDFAF Targets\": targetOptions,\n            \"⏱️  Timings\": animationDurations\n        });\n        if (animationRef.current.currentSourceIndex < sortedSources.length - 1) {\n            // Move to next source\n            const nextTimeout = animationDurations.stepDuration + animationDurations.pauseDuration;\n            const progress = \"\".concat(animationRef.current.currentSourceIndex + 1, \"/\").concat(sortedSources.length);\n            console.log(\"\\uD83C\\uDFAF Source \".concat(progress, \": Highlighting '\").concat(sortedSources[animationRef.current.currentSourceIndex], \"' → '\").concat(currentTargetRef.current, \"' for \").concat(nextTimeout, \"ms\"));\n            animationRef.current.timer = setTimeout(()=>{\n                if (!animationRef.current.running || animationRef.current.isPaused) return;\n                animationRef.current.currentSourceIndex++;\n                animate();\n            }, nextTimeout);\n        } else {\n            // After last source, check if we need to cycle targets or change source category\n            console.log(\"\\uD83D\\uDD0D END OF SOURCES - Checking target cycling:\", {\n                currentTargetIndex: animationRef.current.currentTargetIndex,\n                targetOptionsLength: targetOptions.length,\n                hasMoreTargets: animationRef.current.currentTargetIndex < targetOptions.length - 1,\n                availableTargets: targetOptions\n            });\n            if (animationRef.current.currentTargetIndex < targetOptions.length - 1) {\n                // Still have more target categories to cycle through\n                const targetProgress = \"\".concat(animationRef.current.currentTargetIndex + 2, \"/\").concat(targetOptions.length);\n                console.log(\"\\uD83D\\uDD04 ✅ COMPLETED ALL SOURCES for '\".concat(currentTargetRef.current, \"', moving to next target (\").concat(targetProgress, \")\"));\n                // Clear any existing timer to prevent conflicts\n                if (animationRef.current.timer) {\n                    clearTimeout(animationRef.current.timer);\n                    animationRef.current.timer = null;\n                }\n                animationRef.current.timer = setTimeout(()=>{\n                    if (!animationRef.current.running || animationRef.current.isPaused) return;\n                    setAnimationPhase(\"transitioning\");\n                    // Move to next target category\n                    animationRef.current.currentTargetIndex++;\n                    const nextTarget = targetOptions[animationRef.current.currentTargetIndex];\n                    console.log(\"\\uD83C\\uDFAF ✨ NEW TARGET CATEGORY:\", nextTarget, \"(\".concat(animationRef.current.currentTargetIndex + 1, \"/\").concat(targetOptions.length, \")\"));\n                    console.log(\"\\uD83D\\uDD0D Target progression debug:\", {\n                        previousTarget: currentTargetRef.current,\n                        nextTarget,\n                        currentTargetIndex: animationRef.current.currentTargetIndex,\n                        allTargetOptions: targetOptions\n                    });\n                    setCurrentTarget(nextTarget);\n                    setLastCategoryChange({\n                        source: currentSourceRef.current,\n                        target: nextTarget\n                    });\n                    onQuestionChange === null || onQuestionChange === void 0 ? void 0 : onQuestionChange(currentSourceRef.current, nextTarget);\n                    // Reset source index and restart with new target\n                    animationRef.current.currentSourceIndex = 0;\n                    // Start the next cycle after a brief pause\n                    setTimeout(()=>{\n                        if (animationRef.current.running && !animationRef.current.isPaused) {\n                            animate();\n                        }\n                    }, animationDurations.categoryPauseDuration);\n                }, animationDurations.categoryPauseDuration);\n            } else {\n                // We've cycled through all targets, now change the source category\n                console.log(\"\\uD83D\\uDD04 ✨ COMPLETED ALL TARGETS for '\".concat(currentSourceRef.current, \"' - Moving to next source category! ✨\"));\n                // Clear any existing timer to prevent conflicts\n                if (animationRef.current.timer) {\n                    clearTimeout(animationRef.current.timer);\n                    animationRef.current.timer = null;\n                }\n                animationRef.current.timer = setTimeout(()=>{\n                    if (!animationRef.current.running || animationRef.current.isPaused) return;\n                    setAnimationPhase(\"transitioning\");\n                    // Move to next source category\n                    const sourceOptions = availableFields.map((f)=>f.value);\n                    const currentSourceIndex = sourceOptions.indexOf(currentSourceRef.current);\n                    const nextSourceIndex = (currentSourceIndex + 1) % sourceOptions.length;\n                    const nextSource = sourceOptions[nextSourceIndex];\n                    console.log(\"\\uD83C\\uDFAF \\uD83C\\uDD95 NEW SOURCE CATEGORY:\", nextSource, \"- Starting fresh cycle with all targets\");\n                    // Calculate target options for the NEW source (including years_at_medtronic)\n                    const newTargetOptions = availableFields.filter((f)=>f.value !== nextSource).map((f)=>f.value);\n                    console.log(\"\\uD83D\\uDD0D New target options for\", nextSource, \":\", newTargetOptions);\n                    setCurrentSource(nextSource);\n                    // Reset both indices and start with first target again\n                    animationRef.current.currentSourceIndex = 0;\n                    animationRef.current.currentTargetIndex = 0;\n                    const firstTarget = newTargetOptions[0];\n                    setCurrentTarget(firstTarget);\n                    setLastCategoryChange({\n                        source: nextSource,\n                        target: firstTarget\n                    });\n                    onQuestionChange === null || onQuestionChange === void 0 ? void 0 : onQuestionChange(nextSource, firstTarget);\n                    // Start the next cycle after a longer pause\n                    setTimeout(()=>{\n                        if (animationRef.current.running && !animationRef.current.isPaused) {\n                            animate();\n                        }\n                    }, animationDurations.categoryPauseDuration * 1.5); // Longer pause for source category change\n                }, animationDurations.categoryPauseDuration);\n            }\n        }\n    }, [\n        data.length,\n        sortedSources.length,\n        onQuestionChange,\n        animationDurations,\n        availableFields\n    ]);\n    // Animation effect - restart when settings change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"\\uD83C\\uDFAC Animation useEffect triggered:\", {\n            autoPlay,\n            isAutoPlayEnabled: settings.isAutoPlayEnabled,\n            dataLength: data.length,\n            svgRefExists: !!svgRef.current,\n            currentSource,\n            currentTarget,\n            autoPlaySpeed: settings.autoPlaySpeed,\n            isRunning: animationRef.current.running\n        });\n        if (!autoPlay || !settings.isAutoPlayEnabled) {\n            console.log(\"❌ Animation disabled\");\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n            setAnimationPhase(\"full\");\n            setIsInFullOpacityState(true);\n            return;\n        }\n        if (!filteredData.length) {\n            console.log(\"❌ No data available for animation\");\n            return;\n        }\n        if (!svgRef.current) {\n            console.log(\"❌ SVG ref not available\");\n            return;\n        }\n        // Restart animation when speed changes or on major changes\n        if (animationRef.current.running) {\n            console.log(\"\\uD83D\\uDD04 Restarting animation with new settings:\", {\n                sourceCategory: currentSource,\n                totalSources: sortedSources.length,\n                totalTargets: availableFields.filter((f)=>f.value !== currentSource).length,\n                speed: settings.autoPlaySpeed + \"ms\"\n            });\n            // Stop current animation\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n        }\n        // Start new animation cycle\n        console.log(\"✅ Starting animation cycle:\", {\n            sourceCategory: currentSource,\n            totalSources: sortedSources.length,\n            totalTargets: availableFields.filter((f)=>f.value !== currentSource).length,\n            speed: settings.autoPlaySpeed + \"ms\"\n        });\n        // Initialize animation state\n        animationRef.current.running = true;\n        animationRef.current.currentSourceIndex = 0;\n        animationRef.current.currentTargetIndex = 0;\n        animationRef.current.cycleCount = 0; // Reset cycle counter\n        // Start animation\n        animate();\n        return ()=>{\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n            setAnimationPhase(\"full\");\n            setIsInFullOpacityState(true);\n        };\n    }, [\n        autoPlay,\n        settings.isAutoPlayEnabled,\n        settings.autoPlaySpeed,\n        filteredData.length,\n        currentSource // Only restart on source changes, not target changes\n    ]);\n    const nodeLabelFontSize = 18; // larger for readability\n    const nodeLabelFontWeight = 700;\n    const nodeLabelColor = settings.isDarkMode ? \"#FFFFFF\" : \"#170F5F\";\n    const nodeLabelFontFamily = 'Avenir Next World, -apple-system, BlinkMacSystemFont, \"SF Pro\", \"Roboto\", sans-serif';\n    const nodeLabelOffset = 24;\n    // Local debug toggle for this component if no global admin context\n    const [localDebug, setLocalDebug] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showThemeToggle, setShowThemeToggle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const debugOn = localDebug;\n    // Debug Sankey data for outlines\n    const [debugSankeyData, setDebugSankeyData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!Array.isArray(sources) || !Array.isArray(targets)) return;\n        const nodes = [\n            ...sources.map((name)=>({\n                    id: \"source:\".concat(name),\n                    name,\n                    category: \"source\"\n                })),\n            ...targets.map((name)=>({\n                    id: \"target:\".concat(name),\n                    name,\n                    category: \"target\"\n                }))\n        ];\n        // Only create links if both sides have at least one node\n        const links = sources.length && targets.length ? [\n            {\n                source: \"source:\".concat(sources[0]),\n                target: \"target:\".concat(targets[0]),\n                value: 1\n            }\n        ] : [];\n        if (nodes.length < 2 || links.length < 1) return; // Prevent invalid array length\n        const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(nodePadding).extent([\n            [\n                0,\n                0\n            ],\n            [\n                chartWidth,\n                chartHeight\n            ]\n        ]);\n        const sankeyData = sankeyGenerator({\n            nodes: nodes.map((d)=>({\n                    ...d\n                })),\n            links: links.map((d)=>({\n                    ...d\n                }))\n        });\n        setDebugSankeyData(sankeyData);\n    }, [\n        sources,\n        targets,\n        chartWidth,\n        chartHeight,\n        nodePadding\n    ]);\n    // Render Sankey diagram\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current || !filteredData.length) return;\n        // --- Persistent SVG structure ---\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        svg.selectAll(\"*\").remove(); // Clear previous content\n        svg.attr(\"width\", containerWidth).attr(\"height\", containerHeight);\n        // --- Sankey node/link creation and vertical centering (deduplicated) ---\n        // Sort source nodes to maintain a fixed order (same as animation)\n        const sortedSources = [\n            ...sources\n        ];\n        if (currentSource === \"years_at_medtronic\") {\n            sortedSources.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sortedSources.sort();\n        }\n        // Sort target nodes to maintain a fixed order\n        const sortedTargets = [\n            ...targets\n        ];\n        if (currentTarget === \"years_at_medtronic\") {\n            sortedTargets.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sortedTargets.sort();\n        }\n        // Sankey transformation accessors\n        const sourceAccessor = (d)=>currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentSource];\n        const targetAccessor = (d)=>currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentTarget];\n        // Filter data to only include valid values\n        const validData = filteredData.filter((d)=>(currentSource !== \"years_at_medtronic\" || d.years_at_medtronic !== null) && (currentTarget !== \"years_at_medtronic\" || d.years_at_medtronic !== null));\n        // Build nodes array with unique ids\n        const nodes = [\n            ...sortedSources.map((name)=>({\n                    id: \"\".concat(currentSource, \":\").concat(name),\n                    name,\n                    category: currentSource\n                })),\n            ...sortedTargets.map((name)=>({\n                    id: \"\".concat(currentTarget, \":\").concat(name),\n                    name,\n                    category: currentTarget\n                }))\n        ];\n        // Build links array (aggregate counts for each source-target pair)\n        const linksMap = new Map();\n        // 1. For every possible source-target pair, create a link (dummy if no data)\n        sortedSources.forEach((source)=>{\n            sortedTargets.forEach((target)=>{\n                const sourceId = \"\".concat(currentSource, \":\").concat(source);\n                const targetId = \"\".concat(currentTarget, \":\").concat(target);\n                const key = \"\".concat(sourceId, \"→\").concat(targetId);\n                linksMap.set(key, {\n                    source: sourceId,\n                    target: targetId,\n                    value: 0,\n                    isDummy: true\n                });\n            });\n        });\n        // 2. Fill in real data, marking links as not dummy\n        validData.forEach((d)=>{\n            const source = sourceAccessor(d);\n            const target = targetAccessor(d);\n            if (!sortedSources.includes(source) || !sortedTargets.includes(target)) return;\n            const sourceId = \"\".concat(currentSource, \":\").concat(source);\n            const targetId = \"\".concat(currentTarget, \":\").concat(target);\n            const key = \"\".concat(sourceId, \"→\").concat(targetId);\n            if (!linksMap.has(key)) {\n                linksMap.set(key, {\n                    source: sourceId,\n                    target: targetId,\n                    value: 1,\n                    isDummy: false\n                });\n            } else {\n                const link = linksMap.get(key);\n                link.value += 1;\n                link.isDummy = false;\n            }\n        });\n        // 3. Set dummy links to a very small value if still dummy\n        Array.from(linksMap.values()).forEach((link)=>{\n            if (link.isDummy) link.value = 0.0001;\n        });\n        // --- COLUMN HEIGHT NORMALIZATION ---\n        // Calculate total value for each side\n        const leftTotals = sortedSources.map((source)=>{\n            const sourceId = \"\".concat(currentSource, \":\").concat(source);\n            return Array.from(linksMap.values()).filter((l)=>l.source === sourceId).reduce((sum, l)=>sum + l.value, 0);\n        });\n        const rightTotals = sortedTargets.map((target)=>{\n            const targetId = \"\".concat(currentTarget, \":\").concat(target);\n            return Array.from(linksMap.values()).filter((l)=>l.target === targetId).reduce((sum, l)=>sum + l.value, 0);\n        });\n        const leftSum = leftTotals.reduce((a, b)=>a + b, 0);\n        const rightSum = rightTotals.reduce((a, b)=>a + b, 0);\n        // If sums are different, scale the smaller side's node values and link values\n        let leftScale = 1, rightScale = 1;\n        if (leftSum > 0 && rightSum > 0 && leftSum !== rightSum) {\n            if (leftSum > rightSum) {\n                rightScale = leftSum / rightSum;\n            } else {\n                leftScale = rightSum / leftSum;\n            }\n        }\n        // Scale links\n        Array.from(linksMap.values()).forEach((link)=>{\n            const sourceId = link.source;\n            const targetId = link.target;\n            if (leftScale !== 1 && sortedSources.some((s)=>\"\".concat(currentSource, \":\").concat(s) === sourceId)) {\n                link.value *= leftScale;\n            }\n            if (rightScale !== 1 && sortedTargets.some((t)=>\"\".concat(currentTarget, \":\").concat(t) === targetId)) {\n                link.value *= rightScale;\n            }\n        });\n        const links = Array.from(linksMap.values());\n        // --- DYNAMIC NODE PADDING ---\n        // Reduce nodePadding for sparse data\n        let dynamicNodePadding = nodePadding;\n        if (sortedSources.length <= 4 && sortedTargets.length <= 4) {\n            dynamicNodePadding = Math.max(8, nodePadding / 2);\n        }\n        // Sankey layout\n        const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(dynamicNodePadding).extent([\n            [\n                0,\n                0\n            ],\n            [\n                chartWidth,\n                chartHeight\n            ]\n        ]);\n        const sankeyData = sankeyGenerator({\n            nodes: nodes.map((d)=>({\n                    ...d\n                })),\n            links: links.map((d)=>({\n                    ...d\n                }))\n        });\n        // --- FORCE ROW ALIGNMENT IF NODE SETS MATCH ---\n        // If left and right node sets have the same length and order, align their y0/y1\n        const leftNodes = sankeyData.nodes.filter((n)=>n.category === currentSource);\n        const rightNodes = sankeyData.nodes.filter((n)=>n.category === currentTarget);\n        if (leftNodes.length === rightNodes.length && leftNodes.every((n, i)=>rightNodes[i] && n.name === rightNodes[i].name)) {\n            // Force y0/y1 of right nodes to match left nodes\n            rightNodes.forEach((n, i)=>{\n                n.y0 = leftNodes[i].y0;\n                n.y1 = leftNodes[i].y1;\n            });\n        }\n        // --- VISUAL GUIDES: Render horizontal bands for each row ---\n        svg.selectAll(\"rect.row-guide\").data(leftNodes).enter().append(\"rect\").attr(\"class\", \"row-guide\").attr(\"x\", -margin.left).attr(\"y\", (d)=>d.y0).attr(\"width\", chartWidth + margin.left + margin.right).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"fill\", (d, i)=>settings.isDarkMode ? i % 2 === 0 ? \"#23242a\" : \"#18191d\" // subtle dark bands\n             : i % 2 === 0 ? \"#f5f7fa\" : \"#e9eef5\").attr(\"opacity\", settings.isDarkMode ? 0.5 : 0.25).lower();\n        // Compute vertical offset to center the diagram\n        const nodeYs = sankeyData.nodes.map((d)=>[\n                d.y0,\n                d.y1\n            ]).flat();\n        const minY = Math.min(...nodeYs);\n        const maxY = Math.max(...nodeYs);\n        const usedHeight = maxY - minY;\n        const offsetY = Math.max(0, (chartHeight - usedHeight) / 2 - minY);\n        // Create a group for the chart area with margin translation and vertical centering\n        const g = svg.append(\"g\").attr(\"transform\", \"translate(\".concat(margin.left, \",\").concat(margin.top + offsetY, \")\"));\n        let defs = svg.select(\"defs\");\n        if (defs.empty()) defs = svg.append(\"defs\");\n        let linksG = g.append(\"g\").attr(\"class\", \"links\");\n        let nodesG = g.append(\"g\").attr(\"class\", \"nodes\");\n        // Remove old gradients (no longer needed)\n        defs.selectAll(\"linearGradient.link-gradient\").remove();\n        // --- Add clipPath for links group with tighter bounds ---\n        svg.select(\"defs\").selectAll(\"#link-clip\").remove();\n        defs.append(\"clipPath\").attr(\"id\", \"link-clip\").append(\"rect\").attr(\"x\", margin.left).attr(\"y\", margin.top).attr(\"width\", chartWidth).attr(\"height\", chartHeight);\n        linksG.attr(\"clip-path\", \"url(#link-clip)\");\n        // Add glow filter for dark mode\n        defs.selectAll(\"#dark-mode-glow\").remove();\n        if (settings.isDarkMode) {\n            const glowFilter = defs.append(\"filter\").attr(\"id\", \"dark-mode-glow\").attr(\"x\", \"-50%\").attr(\"y\", \"-50%\").attr(\"width\", \"200%\").attr(\"height\", \"200%\");\n            glowFilter.append(\"feGaussianBlur\").attr(\"stdDeviation\", \"1.5\").attr(\"result\", \"coloredBlur\");\n            const feMerge = glowFilter.append(\"feMerge\");\n            feMerge.append(\"feMergeNode\").attr(\"in\", \"coloredBlur\");\n            feMerge.append(\"feMergeNode\").attr(\"in\", \"SourceGraphic\");\n        }\n        // --- Links update pattern ---\n        // All links are now between real nodes, with isDummy property for visual distinction\n        const filteredLinks = sankeyData.links;\n        // Remove mix-blend-mode in dark mode to prevent color washing out\n        linksG.style(\"mix-blend-mode\", settings.isDarkMode ? \"normal\" : \"multiply\");\n        const linkKey = (d)=>\"\".concat(d.source.id, \"→\").concat(d.target.id);\n        const linkSel = linksG.selectAll(\"path\").data(filteredLinks, linkKey);\n        // EXIT: fade out and remove all old links\n        linkSel.exit().transition().duration(400).attr(\"opacity\", 0).remove();\n        // Check if this is a category change that should trigger animation\n        const isCategoryChange = lastCategoryChange.source !== currentSource || lastCategoryChange.target !== currentTarget;\n        // ENTER: draw in all new links with improved animation\n        const newLinks = linksG.selectAll(\"path\").data(filteredLinks, linkKey).enter().append(\"path\").attr(\"d\", clampedSankeyLinkHorizontal()).attr(\"stroke\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d.source, getCurrentThemeColors(), settings.isDarkMode)).attr(\"stroke-width\", (d)=>Math.min(Math.max(settings.isDarkMode ? 2 : 1, d.width), maxLinkWidth)).attr(\"fill\", \"none\").attr(\"filter\", (d)=>{\n            if (hoveredLink === d) return \"url(#glow)\";\n            return settings.isDarkMode ? \"url(#dark-mode-glow)\" : null;\n        }).attr(\"pointer-events\", \"all\").attr(\"stroke-linecap\", \"round\").attr(\"opacity\", (d)=>{\n            // Dummy links: very low opacity\n            if (d.isDummy) return 0.08;\n            // Adjust opacity based on dark mode for better visibility\n            const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n            const highlightOpacity = settings.isDarkMode ? 1.0 : 0.9;\n            const dimOpacity = settings.isDarkMode ? 0.4 : 0.1;\n            // Default opacity when no highlighting\n            if (animationPhase !== \"highlighting\") return baseOpacity;\n            // Highlight links from the active source\n            if (hoveredSourceIndex !== null) {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n            }\n            // Highlight links to the active target\n            if (hoveredTargetIndex !== null) {\n                const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n            }\n            return baseOpacity;\n        }).attr(\"stroke-dasharray\", (d)=>d.isDummy ? \"4,4\" : null); // Dashed for dummy links\n        // Apply drawing animation only on category changes to prevent flickering\n        if (isCategoryChange) {\n            newLinks.each(function(d) {\n                const path = d3__WEBPACK_IMPORTED_MODULE_2__.select(this);\n                const totalLength = this.getTotalLength();\n                // Start with invisible path\n                path.attr(\"stroke-dasharray\", totalLength).attr(\"stroke-dashoffset\", totalLength).attr(\"opacity\", 0).transition().delay((d, i)=>i * 25) // Reduced stagger delay\n                .duration(600) // Reduced from 1200ms to 600ms\n                .ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut).attr(\"opacity\", (d)=>{\n                    // Adjust opacity based on dark mode for better visibility\n                    const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n                    const highlightOpacity = settings.isDarkMode ? 1.0 : 0.9;\n                    const dimOpacity = settings.isDarkMode ? 0.4 : 0.1;\n                    // Highlight links from the active source or to the active target\n                    if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                        const hoveredSource = sortedSources[hoveredSourceIndex];\n                        return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n                    }\n                    if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                        const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                        return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n                    }\n                    return baseOpacity;\n                }).attr(\"stroke-dashoffset\", 0).on(\"end\", function() {\n                    d3__WEBPACK_IMPORTED_MODULE_2__.select(this).attr(\"stroke-linecap\", \"butt\") // crisp edge after animation\n                    .attr(\"stroke-dasharray\", null).attr(\"stroke-dashoffset\", null);\n                });\n            });\n        } else {\n            // For non-category changes, just set the opacity directly\n            newLinks.attr(\"opacity\", (d)=>{\n                // Adjust opacity based on dark mode for better visibility\n                const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n                const highlightOpacity = settings.isDarkMode ? 1.0 : 0.9;\n                const dimOpacity = settings.isDarkMode ? 0.4 : 0.1;\n                // Highlight links from the active source or to the active target\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredSource = sortedSources[hoveredSourceIndex];\n                    return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n                }\n                if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                    return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n                }\n                return baseOpacity;\n            });\n        }\n        // Add hover interactions\n        newLinks.on(\"mousemove\", function(event, d) {\n            setHoveredLink(d);\n            setTooltip({\n                x: event.offsetX,\n                y: event.offsetY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"font-bold\",\n                            children: [\n                                d.source.name,\n                                \" → \",\n                                d.target.name\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                            lineNumber: 1044,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                d.value,\n                                \" attendees\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                            lineNumber: 1045,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                    lineNumber: 1043,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", function() {\n            setHoveredLink(null);\n            setTooltip(null);\n        });\n        // --- Nodes update pattern (rects) ---\n        const filteredNodes = sankeyData.nodes;\n        const nodeSel = nodesG.selectAll(\"rect\").data(filteredNodes, (d)=>d.id);\n        nodeSel.exit().remove();\n        nodeSel.join((enter)=>enter.append(\"rect\").attr(\"x\", (d)=>d.x0).attr(\"y\", (d)=>d.y0).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"width\", (d)=>d.x1 - d.x0).attr(\"fill\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d, getCurrentThemeColors(), settings.isDarkMode)).attr(\"stroke\", settings.isDarkMode ? \"#444\" : \"#22223b\").attr(\"opacity\", (d)=>{\n                // Source nodes: only the highlighted one is bright\n                if (d.category === currentSource) {\n                    if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                        return d.name === sortedSources[hoveredSourceIndex] ? 1 : 0.3;\n                    }\n                    return 0.9; // Increased from 0.6 to 0.9 for more prominence\n                }\n                // Target nodes: only those connected to the highlighted source or hovered target are bright\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredSource = sortedSources[hoveredSourceIndex];\n                    const isConnected = filteredLinks.some((l)=>l.source.name === hoveredSource && l.target.name === d.name);\n                    return isConnected ? 1 : 0.3;\n                }\n                if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                    return d.name === hoveredTarget ? 1 : 0.3;\n                }\n                return 0.9; // Increased from 0.6 to 0.9 for more prominence\n            }).on(\"mousemove\", function(event, d) {\n                setHoveredNode(d);\n                setTooltip({\n                    x: event.offsetX,\n                    y: event.offsetY,\n                    content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"font-bold\",\n                                children: d.name\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                lineNumber: 1097,\n                                columnNumber: 17\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Category: \",\n                                    d.category\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                lineNumber: 1098,\n                                columnNumber: 17\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Responses: \",\n                                    d.value\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                lineNumber: 1099,\n                                columnNumber: 17\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                        lineNumber: 1096,\n                        columnNumber: 15\n                    }, this)\n                });\n            }).on(\"mouseleave\", function() {\n                setHoveredNode(null);\n                setTooltip(null);\n            }).on(\"mouseenter\", function(event, d) {\n                if (d.category === currentSource) {\n                    const idx = sortedSources.indexOf(d.name);\n                    setHoveredSourceIndex(idx);\n                    setAnimationPhase(\"highlighting\");\n                }\n                if (d.category === currentTarget) {\n                    const idx = sortedTargets.indexOf(d.name);\n                    setHoveredTargetIndex(idx);\n                    setAnimationPhase(\"highlighting\");\n                }\n            }).on(\"mouseleave\", function(event, d) {\n                if (d.category === currentSource) {\n                    setHoveredSourceIndex(null);\n                    setAnimationPhase(\"full\");\n                }\n                if (d.category === currentTarget) {\n                    setHoveredTargetIndex(null);\n                    setAnimationPhase(\"full\");\n                }\n            }), (update)=>update.transition(d3__WEBPACK_IMPORTED_MODULE_2__.transition().duration(750).ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut)).attr(\"x\", (d)=>d.x0).attr(\"y\", (d)=>d.y0).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"width\", (d)=>d.x1 - d.x0).attr(\"fill\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d, getCurrentThemeColors(), settings.isDarkMode)).attr(\"opacity\", (d)=>{\n                // Source nodes: only the highlighted one is bright\n                if (d.category === currentSource) {\n                    if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                        return d.name === sortedSources[hoveredSourceIndex] ? 1 : 0.3;\n                    }\n                    return 0.9; // Increased from 0.6 to 0.9 for more prominence\n                }\n                // Target nodes: only those connected to the highlighted source or hovered target are bright\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredSource = sortedSources[hoveredSourceIndex];\n                    const isConnected = filteredLinks.some((l)=>l.source.name === hoveredSource && l.target.name === d.name);\n                    return isConnected ? 1 : 0.3;\n                }\n                if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                    return d.name === hoveredTarget ? 1 : 0.3;\n                }\n                return 0.9; // Increased from 0.6 to 0.9 for more prominence\n            }));\n        // --- Node labels (re-render as before) ---\n        g.selectAll(\"g.label-layer\").remove();\n        const labelLayer = g.append(\"g\").attr(\"class\", \"label-layer\");\n        const sourceNodeSet = new Set(sortedSources);\n        const targetNodeSet = new Set(sortedTargets);\n        const sourceNodes = sankeyData.nodes.filter((d)=>d.category === currentSource);\n        const targetNodes = sankeyData.nodes.filter((d)=>d.category === currentTarget);\n        sourceNodes.forEach((node)=>{\n            if (sourceNodeSet.has(node.name)) {\n                labelLayer.append(\"text\").attr(\"x\", -labelPadding).attr(\"y\", (node.y0 + node.y1) / 2).attr(\"text-anchor\", \"end\").attr(\"alignment-baseline\", \"middle\").attr(\"font-family\", nodeLabelFontFamily).attr(\"font-weight\", nodeLabelFontWeight).attr(\"font-size\", labelFontSize).attr(\"fill\", nodeLabelColor).attr(\"aria-label\", node.name).attr(\"opacity\", node.value === 0 ? 0.5 : 1).text(node.name);\n            }\n        });\n        targetNodes.forEach((node)=>{\n            if (targetNodeSet.has(node.name)) {\n                labelLayer.append(\"text\").attr(\"x\", chartWidth + labelPadding).attr(\"y\", (node.y0 + node.y1) / 2).attr(\"text-anchor\", \"start\").attr(\"alignment-baseline\", \"middle\").attr(\"font-family\", nodeLabelFontFamily).attr(\"font-weight\", nodeLabelFontWeight).attr(\"font-size\", labelFontSize).attr(\"fill\", nodeLabelColor).attr(\"aria-label\", node.name).attr(\"opacity\", node.value === 0 ? 0.5 : 1).text(node.name);\n            }\n        });\n        // 6. Update insights\n        let mostCommon = links.length > 0 ? links.reduce((a, b)=>b.value > a.value ? b : a, links[0]) : undefined;\n        setInsights([\n            {\n                title: \"Total Responses\",\n                value: data.length\n            },\n            {\n                title: \"Current View\",\n                value: \"\".concat(currentSource, \" → \").concat(currentTarget)\n            },\n            mostCommon ? {\n                title: \"Most Common Flow\",\n                value: \"\".concat(mostCommon.source.split(\":\")[1], \" → \").concat(mostCommon.target.split(\":\")[1]),\n                description: \"\".concat(mostCommon.value, \" attendees\")\n            } : {\n                title: \"Most Common Flow\",\n                value: \"N/A\",\n                description: \"\"\n            }\n        ]);\n        // 7. Automatic animation on question change only\n        const transition = d3__WEBPACK_IMPORTED_MODULE_2__.transition().duration(750).ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut);\n        // Animate nodes\n        nodeSel.transition(transition).attr(\"x\", (d)=>d.x0).attr(\"y\", (d)=>d.y0).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"width\", (d)=>d.x1 - d.x0).attr(\"fill\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d, getCurrentThemeColors(), settings.isDarkMode));\n    }, [\n        filteredData,\n        currentSource,\n        currentTarget,\n        containerWidth,\n        containerHeight,\n        settings.categoryColors,\n        settings.isDarkMode,\n        lastCategoryChange,\n        getCurrentThemeColors\n    ]);\n    // Create sorted targets for consistent highlighting\n    const sortedTargetsForHighlight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const sorted = [\n            ...targets\n        ];\n        if (currentTarget === \"years_at_medtronic\") {\n            sorted.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sorted.sort();\n        }\n        return sorted;\n    }, [\n        targets,\n        currentTarget\n    ]);\n    // Separate effect to update visual highlighting during animation\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        const g = svg.select(\"g\");\n        // Update node opacity based on animation state\n        g.selectAll(\"rect\").transition().duration(200).attr(\"opacity\", function(d) {\n            // Source nodes: only the highlighted one is bright\n            if (d.category === currentSource) {\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    return d.name === sortedSources[hoveredSourceIndex] ? 1 : 0.2; // Slightly higher for better visibility\n                }\n                return 0.9; // Increased from 0.6 to 0.9 for more prominence\n            }\n            // Target nodes: highlight those connected to the highlighted source\n            if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                // Check if this target node is connected to the highlighted source\n                const isConnected = svg.selectAll(\"path\").data().some((link)=>link.source.name === hoveredSource && link.target.name === d.name);\n                return isConnected ? 1 : 0.2; // Slightly higher for better visibility\n            }\n            if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                const hoveredTarget = sortedTargetsForHighlight[hoveredTargetIndex];\n                return d.name === hoveredTarget ? 1 : 0.2;\n            }\n            return 0.9; // Increased from 0.6 to 0.9 for more prominence\n        }).attr(\"stroke-width\", function(d) {\n            // Add thicker stroke to highlighted source node\n            if (d.category === currentSource && hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                return d.name === sortedSources[hoveredSourceIndex] ? 3 : 1;\n            }\n            return 1;\n        });\n        // Update link opacity based on animation state\n        g.selectAll(\"path\").transition().duration(200).attr(\"opacity\", function(d) {\n            // Adjust opacity based on dark mode for better visibility\n            const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n            const highlightOpacity = settings.isDarkMode ? 1.0 : 0.95;\n            const dimOpacity = settings.isDarkMode ? 0.35 : 0.05;\n            // Default opacity when no highlighting\n            if (animationPhase !== \"highlighting\") return baseOpacity;\n            // Highlight links from the active source\n            if (hoveredSourceIndex !== null) {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n            }\n            // Highlight links to the active target\n            if (hoveredTargetIndex !== null) {\n                const hoveredTarget = sortedTargetsForHighlight[hoveredTargetIndex];\n                return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n            }\n            return baseOpacity;\n        }).attr(\"stroke-width\", function(d) {\n            // Make highlighted links thicker\n            if (animationPhase === \"highlighting\" && hoveredSourceIndex !== null) {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                return d.source.name === hoveredSource ? Math.max(2, d.width * 1.2) : Math.max(1, d.width);\n            }\n            return Math.max(1, d.width);\n        });\n        console.log(\"\\uD83C\\uDFA8 Visual highlighting updated:\", {\n            hoveredSourceIndex,\n            sourceName: hoveredSourceIndex !== null ? sortedSources[hoveredSourceIndex] : null,\n            hoveredTargetIndex,\n            targetName: hoveredTargetIndex !== null ? sortedTargetsForHighlight[hoveredTargetIndex] : null,\n            animationPhase\n        });\n    }, [\n        hoveredSourceIndex,\n        hoveredTargetIndex,\n        animationPhase,\n        sortedSources,\n        sortedTargetsForHighlight,\n        currentSource,\n        currentTarget\n    ]);\n    // Separate effect for hover interactions (doesn't re-render the whole visualization)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        const g = svg.select(\"g\");\n        // Update link hover effects\n        g.selectAll(\"path\").each(function(d) {\n            const path = d3__WEBPACK_IMPORTED_MODULE_2__.select(this);\n            const isHovered = hoveredLink === d;\n            path.attr(\"filter\", isHovered ? \"url(#glow)\" : null);\n        });\n    }, [\n        hoveredNode,\n        hoveredLink\n    ]);\n    // Tooltip fadeout logic\n    const [tooltipVisible, setTooltipVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const tooltipTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (tooltip) {\n            setTooltipVisible(true);\n            if (tooltipTimeoutRef.current) clearTimeout(tooltipTimeoutRef.current);\n            tooltipTimeoutRef.current = setTimeout(()=>{\n                setTooltipVisible(false);\n                setTimeout(()=>setTooltip(null), 400); // Wait for fadeout\n            }, 5000);\n        } else {\n            setTooltipVisible(false);\n            if (tooltipTimeoutRef.current) clearTimeout(tooltipTimeoutRef.current);\n        }\n        return ()=>{\n            if (tooltipTimeoutRef.current) clearTimeout(tooltipTimeoutRef.current);\n        };\n    }, [\n        tooltip\n    ]);\n    const tooltipEl = tooltip ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: \"absolute\",\n            left: tooltip.x + 16,\n            top: tooltip.y + 16,\n            background: settings.isDarkMode ? \"rgba(20,20,30,0.98)\" : \"rgba(255,255,255,0.98)\",\n            color: settings.isDarkMode ? \"#fff\" : \"#170F5F\",\n            padding: \"8px 12px\",\n            borderRadius: 6,\n            pointerEvents: \"none\",\n            zIndex: 100,\n            fontFamily: \"Avenir Next World, sans-serif\",\n            fontWeight: 600,\n            fontSize: 14,\n            boxShadow: settings.isDarkMode ? \"0 4px 24px 0 rgba(16, 16, 235, 0.12)\" : \"0 4px 24px 0 rgba(0, 0, 0, 0.15)\",\n            border: settings.isDarkMode ? \"1px solid rgba(255,255,255,0.1)\" : \"1px solid rgba(0,0,0,0.1)\",\n            maxWidth: 280,\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden\",\n            textOverflow: \"ellipsis\",\n            opacity: tooltipVisible ? 1 : 0,\n            transition: \"opacity 0.4s\"\n        },\n        role: \"tooltip\",\n        \"aria-live\": \"polite\",\n        children: tooltip.content\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n        lineNumber: 1363,\n        columnNumber: 5\n    }, this) : null;\n    // Create sorted sources array for highlighting (same as rendering and animation)\n    const sortedSourcesForHighlight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        let visualOrder = [];\n        if (filteredData.length && chartWidth > 0 && chartHeight > 0) {\n            const sourcesForNodes = [\n                ...sources\n            ];\n            if (currentSource === \"years_at_medtronic\") {\n                sourcesForNodes.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n            } else {\n                sourcesForNodes.sort();\n            }\n            const nodes = [\n                ...sourcesForNodes.map((name)=>({\n                        id: \"\".concat(currentSource, \":\").concat(name),\n                        name,\n                        category: currentSource\n                    })),\n                ...targets.map((name)=>({\n                        id: \"\".concat(currentTarget, \":\").concat(name),\n                        name,\n                        category: currentTarget\n                    }))\n            ];\n            const linksMap = new Map();\n            filteredData.forEach((d)=>{\n                const source = currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentSource];\n                const target = currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentTarget];\n                const sourceId = \"\".concat(currentSource, \":\").concat(source);\n                const targetId = \"\".concat(currentTarget, \":\").concat(target);\n                if (!sourcesForNodes.includes(source) || !targets.includes(target)) return;\n                const key = \"\".concat(sourceId, \"→\").concat(targetId);\n                if (!linksMap.has(key)) {\n                    linksMap.set(key, {\n                        source: sourceId,\n                        target: targetId,\n                        value: 0\n                    });\n                }\n                linksMap.get(key).value += 1;\n            });\n            const links = Array.from(linksMap.values());\n            const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(nodePadding).extent([\n                [\n                    0,\n                    0\n                ],\n                [\n                    chartWidth,\n                    chartHeight\n                ]\n            ]);\n            const sankeyData = sankeyGenerator({\n                nodes: nodes.map((d)=>({\n                        ...d\n                    })),\n                links: links.map((d)=>({\n                        ...d\n                    }))\n            });\n            const sourceNodes = sankeyData.nodes.filter((d)=>d.category === currentSource);\n            visualOrder = sourceNodes.slice().sort((a, b)=>a.y0 - b.y0).map((d)=>d.name);\n        }\n        return visualOrder.length ? visualOrder : [\n            ...sources\n        ];\n    }, [\n        filteredData,\n        currentSource,\n        currentTarget,\n        sources,\n        targets,\n        chartWidth,\n        chartHeight,\n        nodePadding\n    ]);\n    // Determine which source or target to highlight based on animation state\n    let highlightSourceName = null;\n    let highlightTargetName = null;\n    if (isInFullOpacityState) {\n        highlightSourceName = null;\n        highlightTargetName = null;\n    } else if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n        highlightSourceName = sortedSourcesForHighlight[hoveredSourceIndex];\n    } else if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n        highlightTargetName = targets[hoveredTargetIndex];\n    }\n    // Enhanced animation pause/resume with debug tracking\n    const pauseAnimation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((reason)=>{\n        if (animationRef.current.running && !animationRef.current.isPaused) {\n            console.log(\"⏸️  PAUSING ANIMATION:\", reason, {\n                currentSourceIndex: animationRef.current.currentSourceIndex,\n                currentTargetIndex: animationRef.current.currentTargetIndex,\n                currentSource,\n                currentTarget\n            });\n            animationRef.current.isPaused = true;\n            animationRef.current.pausedAt = Date.now();\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n        }\n    }, [\n        currentSource,\n        currentTarget\n    ]);\n    const resumeAnimation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((reason)=>{\n        if (animationRef.current.running && animationRef.current.isPaused) {\n            console.log(\"▶️  RESUMING ANIMATION:\", reason, {\n                currentSourceIndex: animationRef.current.currentSourceIndex,\n                currentTargetIndex: animationRef.current.currentTargetIndex,\n                pausedDuration: Date.now() - animationRef.current.pausedAt\n            });\n            animationRef.current.isPaused = false;\n            animationRef.current.resumeFrom = \"source\";\n            // Resume animation from current position with a small delay to ensure state is updated\n            setTimeout(()=>{\n                if (animationRef.current.running && !animationRef.current.isPaused) {\n                    animate();\n                }\n            }, 100);\n        }\n    }, [\n        animate\n    ]);\n    // Update hover handlers with proper state management\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        // Update link hover behavior\n        svg.selectAll(\"path\").on(\"mouseenter\", function(event, d) {\n            // Pause animation during hover\n            pauseAnimation(\"link hover\");\n            // Set hover states\n            setHoveredLink(d);\n            setAnimationPhase(\"highlighting\");\n            // Handle source node hover\n            if (d.source && d.source.category === currentSource) {\n                const idx = sortedSources.indexOf(d.source.name);\n                setHoveredSourceIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual source highlight:\", d.source.name, \"index:\", idx);\n            }\n            // Handle target node hover\n            if (d.target && d.target.category === currentTarget) {\n                const idx = sortedTargetsForHighlight.indexOf(d.target.name);\n                setHoveredTargetIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual target highlight:\", d.target.name, \"index:\", idx);\n            }\n        }).on(\"mouseleave\", function() {\n            // Resume animation\n            resumeAnimation(\"link hover end\");\n            // Clear hover states\n            setHoveredLink(null);\n            setHoveredSourceIndex(null);\n            setHoveredTargetIndex(null);\n            setAnimationPhase(\"full\");\n        });\n        // Update node hover behavior\n        svg.selectAll(\"rect\").on(\"mouseenter\", function(event, d) {\n            // Pause animation during hover\n            pauseAnimation(\"node hover\");\n            setAnimationPhase(\"highlighting\");\n            // Handle source node hover\n            if (d.category === currentSource) {\n                const idx = sortedSources.indexOf(d.name);\n                setHoveredSourceIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual source node highlight:\", d.name, \"index:\", idx);\n            }\n            // Handle target node hover\n            if (d.category === currentTarget) {\n                const idx = sortedTargetsForHighlight.indexOf(d.name);\n                setHoveredTargetIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual target node highlight:\", d.name, \"index:\", idx);\n            }\n        }).on(\"mouseleave\", function() {\n            // Resume animation\n            resumeAnimation(\"node hover end\");\n            // Clear hover states\n            setHoveredSourceIndex(null);\n            setHoveredTargetIndex(null);\n            setAnimationPhase(\"full\");\n        });\n        return ()=>{\n            // Clean up all event listeners\n            svg.selectAll(\"path, rect\").on(\"mouseenter\", null).on(\"mouseleave\", null);\n        };\n    }, [\n        sortedSources,\n        sortedTargetsForHighlight,\n        currentSource,\n        currentTarget,\n        pauseAnimation,\n        resumeAnimation\n    ]);\n    // Main rendering effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current || !data.length) return;\n    // The main rendering logic handles all opacity updates\n    // This ensures data binding is correct and prevents the undefined error\n    }, [\n        filteredData,\n        hoveredSourceIndex,\n        hoveredTargetIndex,\n        animationPhase,\n        sortedSources,\n        targets,\n        currentSource,\n        currentTarget\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\",\n            minHeight: 220,\n            minWidth: 320,\n            position: \"relative\"\n        },\n        children: [\n            (nodeCount <= 2 || sources.length <= 1 || targets.length <= 1) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"absolute\",\n                    top: 40,\n                    left: \"50%\",\n                    transform: \"translateX(-50%)\",\n                    background: \"rgba(255,255,200,0.95)\",\n                    color: \"#170F5F\",\n                    padding: \"12px 24px\",\n                    borderRadius: 8,\n                    fontWeight: 600,\n                    fontSize: 18,\n                    zIndex: 10,\n                    boxShadow: \"0 2px 12px 0 rgba(0,0,0,0.08)\"\n                },\n                children: \"Not enough data to show a meaningful flow diagram.\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                lineNumber: 1586,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                ref: svgRef,\n                width: chartWidth + margin.left + margin.right,\n                height: chartHeight + margin.top + margin.bottom,\n                viewBox: \"0 0 \".concat(chartWidth + margin.left + margin.right, \" \").concat(chartHeight + margin.top + margin.bottom),\n                style: {\n                    display: \"block\",\n                    width: \"100%\",\n                    height: \"100%\",\n                    background: \"transparent\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                        transform: \"translate(\".concat(margin.left, \",\").concat(margin.top, \")\")\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                        lineNumber: 1611,\n                        columnNumber: 9\n                    }, this),\n                    debugOn && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                        transform: \"translate(\".concat(margin.left, \",\").concat(margin.top, \")\"),\n                        children: [\n                            Array.isArray(debugSankeyData === null || debugSankeyData === void 0 ? void 0 : debugSankeyData.nodes) && debugSankeyData.nodes.map((d, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                    x: d.x0,\n                                    y: d.y0,\n                                    width: d.x1 - d.x0,\n                                    height: d.y1 - d.y0,\n                                    fill: \"none\",\n                                    stroke: \"magenta\",\n                                    strokeDasharray: \"4 2\",\n                                    pointerEvents: \"none\"\n                                }, \"debug-node-\".concat(i), false, {\n                                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                    lineNumber: 1619,\n                                    columnNumber: 15\n                                }, this)),\n                            Array.isArray(debugSankeyData === null || debugSankeyData === void 0 ? void 0 : debugSankeyData.links) && debugSankeyData.links.map((d, i)=>{\n                                const path = clampedSankeyLinkHorizontal()(d) || \"\";\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                    d: path,\n                                    fill: \"none\",\n                                    stroke: \"cyan\",\n                                    strokeWidth: 2,\n                                    pointerEvents: \"none\"\n                                }, \"debug-link-\".concat(i), false, {\n                                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                    lineNumber: 1635,\n                                    columnNumber: 17\n                                }, this);\n                            })\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                        lineNumber: 1616,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                lineNumber: 1603,\n                columnNumber: 7\n            }, this),\n            tooltipEl\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n        lineNumber: 1583,\n        columnNumber: 5\n    }, this);\n}\n_s(AlluvialDiagram, \"6gYfAdpGWkB9+1STC2gDcKJDM6o=\", false, function() {\n    return [\n        _shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_4__.useVisualizationData,\n        _lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__.useAppContext\n    ];\n});\n_c = AlluvialDiagram;\nvar _c;\n$RefreshReg$(_c, \"AlluvialDiagram\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0RhdGFWaXN1YWxpemF0aW9uL0FsbHV2aWFsRGlhZ3JhbS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFFNkY7QUFDcEU7QUFDZ0M7QUFHWTtBQUdvQjtBQUVoQztBQW1EekQsTUFBTVksa0JBQWtCO0lBQ3RCO1FBQUVDLE9BQU87UUFBc0JDLE9BQU87SUFBcUI7SUFDM0Q7UUFBRUQsT0FBTztRQUFrQkMsT0FBTztJQUFpQjtJQUNuRDtRQUFFRCxPQUFPO1FBQWFDLE9BQU87SUFBWTtJQUN6QztRQUFFRCxPQUFPO1FBQW9CQyxPQUFPO0lBQW1CO0lBQ3ZEO1FBQUVELE9BQU87UUFBY0MsT0FBTztJQUFhO0NBRTVDO0FBRUQsTUFBTUMsbUJBQW1CO0lBQUM7SUFBTztJQUFRO0lBQVM7SUFBUztDQUFNO0FBRWpFLG9EQUFvRDtBQUNwRCxNQUFNQyx3QkFBd0IsQ0FBQ0M7SUFDN0IsSUFBSSxPQUFPQSxVQUFVLFlBQVlDLE1BQU1ELFVBQVVBLFFBQVEsR0FBRyxPQUFPO0lBQ25FLElBQUlBLFNBQVMsR0FBRyxPQUFPO0lBQ3ZCLElBQUlBLFNBQVMsSUFBSSxPQUFPO0lBQ3hCLElBQUlBLFNBQVMsSUFBSSxPQUFPO0lBQ3hCLElBQUlBLFNBQVMsSUFBSSxPQUFPO0lBQ3hCLE9BQU87QUFDVDtBQUVBLG1FQUFtRTtBQUNuRSxTQUFTRSxlQUFlQyxDQUFNO1FBQUVDLGdCQUFBQSxpRUFBZ0IsR0FBR0MsZ0JBQUFBLGlFQUFnQixLQUFLQyxhQUFBQSxpRUFBYSxLQUFLQyxjQUFBQSxpRUFBYztJQUN0Ryx3Q0FBd0M7SUFDeEMsSUFBSUMsS0FBS0wsRUFBRU0sTUFBTSxDQUFDQyxFQUFFO0lBQ3BCLElBQUlBLEtBQUtQLEVBQUVRLE1BQU0sQ0FBQ0gsRUFBRTtJQUNwQixJQUFJSSxLQUFLVCxFQUFFUyxFQUFFO0lBQ2IsSUFBSUMsS0FBS1YsRUFBRVUsRUFBRTtJQUViLHdEQUF3RDtJQUN4REws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QUcsQ0FBQyxDQUFDdEUsR0FBUStQO2dDQUMzRSxNQUFNZ0MsT0FBTzVRLDhCQUE4Qm5CLE1BQU07Z0NBQ2pELHFCQUNFLDhEQUFDK1I7b0NBRUMvUixHQUFHK1I7b0NBQ0h5RSxNQUFLO29DQUNMQyxRQUFPO29DQUNQRSxhQUFhO29DQUNiakMsZUFBYzttQ0FMVCxjQUFnQixPQUFGM0U7Ozs7OzRCQVF6Qjs7Ozs7Ozs7Ozs7OztZQUlMcUU7Ozs7Ozs7QUFHUDtHQW4vQ3dCelM7O1FBMkJhdkMsOEVBQW9CQTtRQUNYRyxrRUFBYUE7OztLQTVCbkNvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9EYXRhVmlzdWFsaXphdGlvbi9BbGx1dmlhbERpYWdyYW0udHN4P2I5NmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VNZW1vLCB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IHNhbmtleSwgc2Fua2V5TGlua0hvcml6b250YWwgfSBmcm9tICdkMy1zYW5rZXknO1xuLy8gQHRzLWV4cGVjdC1lcnJvcjogTm8gdHlwZXMgZm9yIGQzLWludGVycG9sYXRlLXBhdGhcbmltcG9ydCB7IGludGVycG9sYXRlUGF0aCB9IGZyb20gJ2QzLWludGVycG9sYXRlLXBhdGgnO1xuaW1wb3J0IHsgdXNlVmlzdWFsaXphdGlvbkRhdGEgfSBmcm9tICcuL3NoYXJlZC91c2VWaXN1YWxpemF0aW9uRGF0YSc7XG5pbXBvcnQgeyBWaXN1YWxpemF0aW9uQ29udGFpbmVyIH0gZnJvbSAnLi9zaGFyZWQvVmlzdWFsaXphdGlvbkNvbnRhaW5lcic7XG5pbXBvcnQgeyBEYXRhSW5zaWdodFBhbmVsIH0gZnJvbSAnLi9zaGFyZWQvRGF0YUluc2lnaHRQYW5lbCc7XG5pbXBvcnQgeyBnZXRZZWFyc0NvbG9yU2NhbGUsIGdldFllYXJzQ2F0ZWdvcnksIGdldE5vZGVDb2xvciB9IGZyb20gJy4vc2hhcmVkL2NvbG9yVXRpbHMnO1xuaW1wb3J0IHsgUXVlc3Rpb25TZWxlY3RvciB9IGZyb20gJy4vc2hhcmVkL1F1ZXN0aW9uU2VsZWN0b3InO1xuaW1wb3J0IHsgdXNlQXBwQ29udGV4dCB9IGZyb20gJ0AvbGliL2NvbnRleHQvQXBwQ29udGV4dCc7XG5pbXBvcnQgdHlwZSB7IERhdGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UvdHlwZXMnO1xuXG5pbnRlcmZhY2UgQWxsdXZpYWxEaWFncmFtUHJvcHMge1xuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBhdXRvUGxheT86IGJvb2xlYW47XG4gIG9uUXVlc3Rpb25DaGFuZ2U/OiAoc291cmNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG50eXBlIFN1cnZleVJlc3BvbnNlID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsnc3VydmV5X3Jlc3BvbnNlcyddWydSb3cnXSAmIHtcbiAgYXR0ZW5kZWU6IERhdGFiYXNlWydwdWJsaWMnXVsnVGFibGVzJ11bJ2F0dGVuZGVlcyddWydSb3cnXTtcbn07XG5cbmludGVyZmFjZSBTYW5rZXlOb2RlIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBjYXRlZ29yeTogc3RyaW5nO1xuICB4MDogbnVtYmVyO1xuICB4MTogbnVtYmVyO1xuICB5MDogbnVtYmVyO1xuICB5MTogbnVtYmVyO1xuICB2YWx1ZTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU2Fua2V5TGluayB7XG4gIHNvdXJjZTogU2Fua2V5Tm9kZTtcbiAgdGFyZ2V0OiBTYW5rZXlOb2RlO1xuICB2YWx1ZTogbnVtYmVyO1xuICB3aWR0aDogbnVtYmVyO1xuICB5MDogbnVtYmVyO1xuICB5MTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQW5pbWF0aW9uU3RhdGUge1xuICB0aW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsO1xuICBydW5uaW5nOiBib29sZWFuO1xuICBjdXJyZW50U291cmNlSW5kZXg6IG51bWJlcjtcbiAgY3VycmVudFRhcmdldEluZGV4OiBudW1iZXI7XG4gIGlzUGF1c2VkOiBib29sZWFuO1xuICBwYXVzZWRBdDogbnVtYmVyO1xuICByZXN1bWVGcm9tOiAnc291cmNlJyB8ICd0YXJnZXQnIHwgbnVsbDtcbiAgY3ljbGVDb3VudDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVG9vbHRpcFN0YXRlIHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGNvbnRlbnQ6IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuY29uc3QgYXZhaWxhYmxlRmllbGRzID0gW1xuICB7IHZhbHVlOiAneWVhcnNfYXRfbWVkdHJvbmljJywgbGFiZWw6ICdZZWFycyBhdCBNZWR0cm9uaWMnIH0sXG4gIHsgdmFsdWU6ICdsZWFybmluZ19zdHlsZScsIGxhYmVsOiAnTGVhcm5pbmcgU3R5bGUnIH0sXG4gIHsgdmFsdWU6ICdzaGFwZWRfYnknLCBsYWJlbDogJ1NoYXBlZCBCeScgfSxcbiAgeyB2YWx1ZTogJ3BlYWtfcGVyZm9ybWFuY2UnLCBsYWJlbDogJ1BlYWsgUGVyZm9ybWFuY2UnIH0sXG4gIHsgdmFsdWU6ICdtb3RpdmF0aW9uJywgbGFiZWw6ICdNb3RpdmF0aW9uJyB9LFxuICAvLyBBZGQgbW9yZSBmaWVsZHMgYXMgbmVlZGVkXG5dO1xuXG5jb25zdCBZRUFSU19DQVRFR09SSUVTID0gWycwLTUnLCAnNi0xMCcsICcxMS0xNScsICcxNi0yMCcsICcyMCsnXTtcblxuLy8gTW92ZSB0aGlzIGZ1bmN0aW9uIHVwIHNvIGl0IGlzIGRlZmluZWQgYmVmb3JlIHVzZVxuY29uc3QgZ2V0VmFsaWRZZWFyc0NhdGVnb3J5ID0gKHllYXJzOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBpZiAodHlwZW9mIHllYXJzICE9PSAnbnVtYmVyJyB8fCBpc05hTih5ZWFycykgfHwgeWVhcnMgPCAwKSByZXR1cm4gJzAtNSc7XG4gIGlmICh5ZWFycyA8PSA1KSByZXR1cm4gJzAtNSc7XG4gIGlmICh5ZWFycyA8PSAxMCkgcmV0dXJuICc2LTEwJztcbiAgaWYgKHllYXJzIDw9IDE1KSByZXR1cm4gJzExLTE1JztcbiAgaWYgKHllYXJzIDw9IDIwKSByZXR1cm4gJzE2LTIwJztcbiAgcmV0dXJuICcyMCsnO1xufTtcblxuLy8gQ3VzdG9tIHdhdmUgcGF0aCBnZW5lcmF0b3IgZm9yIFNhbmtleSBsaW5rcyB3aXRoIGJvdW5kcyBjaGVja2luZ1xuZnVuY3Rpb24gc2Fua2V5TGlua1dhdmUoZDogYW55LCB3YXZlQW1wbGl0dWRlID0gOCwgd2F2ZUZyZXF1ZW5jeSA9IDEuMSwgY2hhcnRXaWR0aCA9IDgwMCwgY2hhcnRIZWlnaHQgPSA2MDApIHtcbiAgLy8gZCBoYXMgc291cmNlL3RhcmdldDoge3gwLCB4MSwgeTAsIHkxfVxuICBsZXQgeDAgPSBkLnNvdXJjZS54MTtcbiAgbGV0IHgxID0gZC50YXJnZXQueDA7XG4gIGxldCB5MCA9IGQueTA7XG4gIGxldCB5MSA9IGQueTE7XG4gIFxuICAvLyBDbGFtcCBjb29yZGluYXRlcyB0byBjaGFydCBib3VuZHMgdG8gcHJldmVudCBvdmVyZmxvd1xuICB4MCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNoYXJ0V2lkdGgsIHgwKSk7XG4gIHgxID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY2hhcnRXaWR0aCwgeDEpKTtcbiAgeTAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjaGFydEhlaWdodCwgeTApKTtcbiAgeTEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjaGFydEhlaWdodCwgeTEpKTtcbiAgXG4gIGNvbnN0IG1pZFggPSAoeDAgKyB4MSkgLyAyO1xuICBcbiAgLy8gQWRkIGEgc2luZSB3YXZlIHRvIHRoZSBjb250cm9sIHBvaW50cywgYnV0IGVuc3VyZSB0aGV5IHN0YXkgd2l0aGluIGJvdW5kc1xuICBjb25zdCB3YXZlWTAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjaGFydEhlaWdodCwgeTAgKyB3YXZlQW1wbGl0dWRlICogTWF0aC5zaW4od2F2ZUZyZXF1ZW5jeSAqIE1hdGguUEkgKiAwLjI1KSkpO1xuICBjb25zdCB3YXZlWTEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjaGFydEhlaWdodCwgeTEgKyB3YXZlQW1wbGl0dWRlICogTWF0aC5zaW4od2F2ZUZyZXF1ZW5jeSAqIE1hdGguUEkgKiAwLjc1KSkpO1xuICBcbiAgcmV0dXJuIGBNJHt4MH0sJHt5MH1cbiAgICBDJHttaWRYfSwke3dhdmVZMH0gJHttaWRYfSwke3dhdmVZMX0gJHt4MX0sJHt5MX1gO1xufVxuXG4vLyBDdXN0b20gaG9yaXpvbnRhbCBsaW5rIGdlbmVyYXRvciB0aGF0IGNsYW1wcyB5MC95MSB0byBub2RlIGJvdW5kc1xuZnVuY3Rpb24gY2xhbXBlZFNhbmtleUxpbmtIb3Jpem9udGFsKCkge1xuICByZXR1cm4gZnVuY3Rpb24oZDogYW55KSB7XG4gICAgLy8gQ2xhbXAgeTAveTEgdG8gbm9kZSBib3VuZHNcbiAgICBjb25zdCBzeSA9IE1hdGgubWF4KGQuc291cmNlLnkwLCBNYXRoLm1pbihkLnNvdXJjZS55MSwgZC55MCkpO1xuICAgIGNvbnN0IHR5ID0gTWF0aC5tYXgoZC50YXJnZXQueTAsIE1hdGgubWluKGQudGFyZ2V0LnkxLCBkLnkxKSk7XG4gICAgY29uc3QgeDAgPSBkLnNvdXJjZS54MTtcbiAgICBjb25zdCB4MSA9IGQudGFyZ2V0LngwO1xuICAgIC8vIFVzZSBhIGN1YmljIEJlemllciBmb3Igc21vb3RobmVzc1xuICAgIGNvbnN0IGN1cnZhdHVyZSA9IDAuNTtcbiAgICBjb25zdCB4aSA9IGQzLmludGVycG9sYXRlTnVtYmVyKHgwLCB4MSk7XG4gICAgY29uc3QgeDIgPSB4aShjdXJ2YXR1cmUpO1xuICAgIGNvbnN0IHgzID0geGkoMSAtIGN1cnZhdHVyZSk7XG4gICAgcmV0dXJuIGBNJHt4MH0sJHtzeX1DJHt4Mn0sJHtzeX0gJHt4M30sJHt0eX0gJHt4MX0sJHt0eX1gO1xuICB9O1xufVxuXG4vLyBOb3RlOiBVc2luZyB0aGVtZS1hd2FyZSBnZXROb2RlQ29sb3IgZnVuY3Rpb24gZnJvbSBjb2xvclV0aWxzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFsbHV2aWFsRGlhZ3JhbSh7XG4gIHdpZHRoID0gODAwLFxuICBoZWlnaHQgPSA2MDAsXG4gIGF1dG9QbGF5ID0gdHJ1ZSxcbiAgb25RdWVzdGlvbkNoYW5nZSxcbn06IEFsbHV2aWFsRGlhZ3JhbVByb3BzKSB7XG4gIC8vIFJlc3BvbnNpdmU6IHVzZSBzdGF0ZSBmb3Igd2lkdGgvaGVpZ2h0LCBmYWxsYmFjayB0byBwcm9wc1xuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBbY29udGFpbmVyV2lkdGgsIHNldENvbnRhaW5lcldpZHRoXSA9IHVzZVN0YXRlKHdpZHRoKTtcbiAgY29uc3QgW2NvbnRhaW5lckhlaWdodCwgc2V0Q29udGFpbmVySGVpZ2h0XSA9IHVzZVN0YXRlKGhlaWdodCk7XG5cbiAgLy8gUmVzcG9uc2l2ZTogb2JzZXJ2ZSBjb250YWluZXIgc2l6ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBmb3IgKGxldCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmIChlbnRyeS5jb250ZW50UmVjdCkge1xuICAgICAgICAgIHNldENvbnRhaW5lcldpZHRoKGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoKTtcbiAgICAgICAgICBzZXRDb250YWluZXJIZWlnaHQoZW50cnkuY29udGVudFJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyUmVmLmN1cnJlbnQpO1xuICAgIHJldHVybiAoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzdmdSZWYgPSB1c2VSZWY8U1ZHU1ZHRWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IHsgZGF0YSwgaXNMb2FkaW5nLCBlcnJvciB9ID0gdXNlVmlzdWFsaXphdGlvbkRhdGEoKTtcbiAgY29uc3QgeyBzZXR0aW5ncywgZ2V0Q3VycmVudFRoZW1lQ29sb3JzIH0gPSB1c2VBcHBDb250ZXh0KCk7XG4gIGNvbnN0IFtjdXJyZW50U291cmNlLCBzZXRDdXJyZW50U291cmNlXSA9IHVzZVN0YXRlKCd5ZWFyc19hdF9tZWR0cm9uaWMnKTtcbiAgY29uc3QgW2N1cnJlbnRUYXJnZXQsIHNldEN1cnJlbnRUYXJnZXRdID0gdXNlU3RhdGUoJ2xlYXJuaW5nX3N0eWxlJyk7XG5cbiAgLy8gRmlsdGVyIGRhdGEgYmFzZWQgb24gdGVzdCBkYXRhIHNldHRpbmdcbiAgY29uc3QgZmlsdGVyZWREYXRhID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBzZXR0aW5ncy51c2VUZXN0RGF0YSA/IGRhdGEgOiBkYXRhLmZpbHRlcihpdGVtID0+ICEoaXRlbSBhcyBhbnkpLnRlc3RfZGF0YSk7XG4gIH0sIFtkYXRhLCBzZXR0aW5ncy51c2VUZXN0RGF0YV0pO1xuXG4gIC8vIENvbXB1dGUgc291cmNlcyBhbmQgdGFyZ2V0cyB3aXRoIHZhbGlkYXRpb25cbiAgY29uc3Qgc291cmNlczogc3RyaW5nW10gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyZWREYXRhKSB8fCAhZmlsdGVyZWREYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIGlmIChjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgICAgcmV0dXJuIFlFQVJTX0NBVEVHT1JJRVMuZmlsdGVyKGNhdCA9PiBcbiAgICAgICAgZmlsdGVyZWREYXRhLnNvbWUoZCA9PiBnZXRWYWxpZFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMCkgPT09IGNhdClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoXG4gICAgICAgIGZpbHRlcmVkRGF0YS5tYXAoKGQ6IFN1cnZleVJlc3BvbnNlKSA9PiBkW2N1cnJlbnRTb3VyY2UgYXMga2V5b2YgU3VydmV5UmVzcG9uc2VdKVxuICAgICAgKSkuZmlsdGVyKCh2YWx1ZSk6IHZhbHVlIGlzIHN0cmluZyA9PiBcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPiAwXG4gICAgICApO1xuICAgIH1cbiAgfSwgW2ZpbHRlcmVkRGF0YSwgY3VycmVudFNvdXJjZV0pO1xuXG4gIGNvbnN0IHRhcmdldHM6IHN0cmluZ1tdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcmVkRGF0YSkgfHwgIWZpbHRlcmVkRGF0YS5sZW5ndGgpIHJldHVybiBbXTtcbiAgICBpZiAoY3VycmVudFRhcmdldCA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycpIHtcbiAgICAgIHJldHVybiBZRUFSU19DQVRFR09SSUVTLmZpbHRlcihjYXQgPT4gXG4gICAgICAgIGZpbHRlcmVkRGF0YS5zb21lKGQgPT4gZ2V0VmFsaWRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApID09PSBjYXQpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb3J0IHRhcmdldCBub2RlcyBjb25zaXN0ZW50bHkgdG8gbWFpbnRhaW4gZml4ZWQgcG9zaXRpb25zXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KFxuICAgICAgICBmaWx0ZXJlZERhdGEubWFwKChkOiBTdXJ2ZXlSZXNwb25zZSkgPT4gXG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnIFxuICAgICAgICAgICAgPyBnZXRWYWxpZFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMClcbiAgICAgICAgICAgIDogZFtjdXJyZW50VGFyZ2V0IGFzIGtleW9mIFN1cnZleVJlc3BvbnNlXVxuICAgICAgICApXG4gICAgICApKS5maWx0ZXIoKHZhbHVlKTogdmFsdWUgaXMgc3RyaW5nID0+IFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA+IDBcbiAgICAgICkuc29ydCgpOyAvLyBBZGQgY29uc2lzdGVudCBzb3J0aW5nXG4gICAgfVxuICB9LCBbZmlsdGVyZWREYXRhLCBjdXJyZW50VGFyZ2V0XSk7XG5cbiAgLy8gLS0tIFJlc3BvbnNpdmUgY2hhcnQgc2l6aW5nIGJhc2VkIG9uIGRhdGEgc2l6ZSAtLS1cbiAgLy8gU2V0IHNlbnNpYmxlIG1pbi9tYXggY2hhcnQgZGltZW5zaW9uc1xuICBjb25zdCBNSU5fQ0hBUlRfSEVJR0hUID0gMTgwO1xuICBjb25zdCBNQVhfQ0hBUlRfSEVJR0hUID0gNzAwO1xuICBjb25zdCBNSU5fQ0hBUlRfV0lEVEggPSAzMjA7XG4gIGNvbnN0IE1BWF9DSEFSVF9XSURUSCA9IDE0MDA7XG5cbiAgLy8gQ2FsY3VsYXRlIG5vZGUgY291bnQgZm9yIHNpemluZ1xuICBjb25zdCBub2RlQ291bnQgPSBNYXRoLm1heChzb3VyY2VzLmxlbmd0aCwgdGFyZ2V0cy5sZW5ndGgsIDEpO1xuXG4gIC8vIC0tLSBTcGFyc2UgRGF0YSBUdW5pbmcgLS0tXG4gIC8vIEZvciBzcGFyc2UgZGF0YSwgc2hyaW5rIGNoYXJ0IGFuZCBjYXAgbm9kZS9saW5rIHNpemVcbiAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KE1JTl9DSEFSVF9IRUlHSFQsIE1hdGgubWluKGNvbnRhaW5lckhlaWdodCAtIDQwLCBNQVhfQ0hBUlRfSEVJR0hUKSk7XG4gIGxldCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KE1JTl9DSEFSVF9XSURUSCwgTWF0aC5taW4oY29udGFpbmVyV2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCwgTUFYX0NIQVJUX1dJRFRIKSk7XG4gIGxldCBtYXhOb2RlSGVpZ2h0ID0gNDg7XG4gIGxldCBtYXhMaW5rV2lkdGggPSAzMjtcbiAgaWYgKG5vZGVDb3VudCA8PSAzKSB7XG4gICAgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoTUlOX0NIQVJUX0hFSUdIVCwgTWF0aC5taW4oMjIwLCBhdmFpbGFibGVIZWlnaHQpKTsgLy8gU2hyaW5rIGNoYXJ0IGhlaWdodFxuICAgIGF2YWlsYWJsZVdpZHRoID0gTWF0aC5tYXgoTUlOX0NIQVJUX1dJRFRILCBNYXRoLm1pbig0MjAsIGF2YWlsYWJsZVdpZHRoKSk7ICAgLy8gU2hyaW5rIGNoYXJ0IHdpZHRoXG4gICAgbWF4Tm9kZUhlaWdodCA9IDI4OyAvLyBDYXAgbm9kZSBoZWlnaHRcbiAgICBtYXhMaW5rV2lkdGggPSAxNjsgIC8vIENhcCBsaW5rIHRoaWNrbmVzc1xuICB9XG4gIGlmIChub2RlQ291bnQgPj0gMTApIHtcbiAgICBhdmFpbGFibGVIZWlnaHQgPSBNYXRoLm1pbihNQVhfQ0hBUlRfSEVJR0hULCBNYXRoLm1heChhdmFpbGFibGVIZWlnaHQsIDUwMCkpO1xuICAgIGF2YWlsYWJsZVdpZHRoID0gTWF0aC5taW4oTUFYX0NIQVJUX1dJRFRILCBNYXRoLm1heChhdmFpbGFibGVXaWR0aCwgOTAwKSk7XG4gIH1cblxuICAvLyBOb2RlIGhlaWdodCBhbmQgcGFkZGluZyBsb2dpY1xuICBjb25zdCBtaW5Ob2RlSGVpZ2h0ID0gMTY7XG4gIGNvbnN0IG1pblBhZGRpbmcgPSA4O1xuICBsZXQgbm9kZUhlaWdodCA9IE1hdGguZmxvb3IoKGF2YWlsYWJsZUhlaWdodCAtIChub2RlQ291bnQgKyAxKSAqIG1pblBhZGRpbmcpIC8gbm9kZUNvdW50KTtcbiAgbm9kZUhlaWdodCA9IE1hdGgubWF4KG1pbk5vZGVIZWlnaHQsIE1hdGgubWluKG5vZGVIZWlnaHQsIG1heE5vZGVIZWlnaHQpKTtcbiAgbGV0IG5vZGVQYWRkaW5nID0gKGF2YWlsYWJsZUhlaWdodCAtIG5vZGVDb3VudCAqIG5vZGVIZWlnaHQpIC8gKG5vZGVDb3VudCArIDEpO1xuICBub2RlUGFkZGluZyA9IE1hdGgubWF4KG5vZGVQYWRkaW5nLCBtaW5QYWRkaW5nKTtcblxuICAvLyBEeW5hbWljYWxseSBzY2FsZSBsYWJlbCBmb250IHNpemUgd2l0aCBub2RlIGhlaWdodCAoY2xhbXAgYmV0d2VlbiAxMnB4IGFuZCAyOHB4KVxuICBjb25zdCBsYWJlbEZvbnRTaXplID0gTWF0aC5tYXgoMTIsIE1hdGgubWluKDI4LCBNYXRoLmZsb29yKG5vZGVIZWlnaHQgKiAwLjUpKSk7XG5cbiAgLy8gLS0tIER5bmFtaWMgbWFyZ2luIGNhbGN1bGF0aW9uIGZvciBmdWxsIGxhYmVsIHZpc2liaWxpdHkgLS0tXG4gIC8vIEhlbHBlciB0byBtZWFzdXJlIHRleHQgd2lkdGggaW4gcHhcbiAgZnVuY3Rpb24gbWVhc3VyZVRleHRXaWR0aCh0ZXh0OiBzdHJpbmcsIGZvbnQ6IHN0cmluZyk6IG51bWJlciB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gMTAwOyAvLyBmYWxsYmFjayBmb3IgU1NSXG4gICAgaWYgKCEobWVhc3VyZVRleHRXaWR0aCBhcyBhbnkpLl9jYW52YXMpIHtcbiAgICAgIChtZWFzdXJlVGV4dFdpZHRoIGFzIGFueSkuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMgPSAobWVhc3VyZVRleHRXaWR0aCBhcyBhbnkpLl9jYW52YXMgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICghY29udGV4dCkgcmV0dXJuIDEwMDtcbiAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuICAgIHJldHVybiBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICB9XG5cbiAgLy8gRm9udCBmb3IgbWVhc3VyaW5nXG4gIGNvbnN0IGxhYmVsRm9udCA9IGBib2xkICR7bGFiZWxGb250U2l6ZX1weCBBdmVuaXIgTmV4dCBXb3JsZCwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU0YgUHJvJywgJ1JvYm90bycsIHNhbnMtc2VyaWZgO1xuICBjb25zdCBhbGxMYWJlbHMgPSBbLi4uc291cmNlcywgLi4udGFyZ2V0c107XG4gIGNvbnN0IGxhYmVsV2lkdGhzID0gYWxsTGFiZWxzLm1hcChsYWJlbCA9PiBtZWFzdXJlVGV4dFdpZHRoKGxhYmVsLCBsYWJlbEZvbnQpKTtcbiAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IE1hdGgubWF4KC4uLmxhYmVsV2lkdGhzLCA4MCk7IC8vIGZhbGxiYWNrIG1pblxuICBjb25zdCBsYWJlbFBhZGRpbmcgPSAyNDtcbiAgY29uc3QgbWFyZ2luID0geyB0b3A6IDIwLCByaWdodDogbWF4TGFiZWxXaWR0aCArIGxhYmVsUGFkZGluZywgYm90dG9tOiAyMCwgbGVmdDogbWF4TGFiZWxXaWR0aCArIGxhYmVsUGFkZGluZyB9O1xuXG4gIC8vIFJlc3BvbnNpdmUgY2hhcnQgd2lkdGhcbiAgbGV0IGNoYXJ0V2lkdGggPSBNYXRoLm1heChNSU5fQ0hBUlRfV0lEVEgsIE1hdGgubWluKGNvbnRhaW5lcldpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsIE1BWF9DSEFSVF9XSURUSCkpO1xuICBsZXQgY2hhcnRIZWlnaHQgPSBhdmFpbGFibGVIZWlnaHQ7XG5cbiAgLy8gSWYgdmVyeSBzcGFyc2UsIHNocmluayB3aWR0aCB0b29cbiAgaWYgKG5vZGVDb3VudCA8PSAzKSB7XG4gICAgY2hhcnRXaWR0aCA9IE1hdGgubWF4KE1JTl9DSEFSVF9XSURUSCwgTWF0aC5taW4oY2hhcnRXaWR0aCwgNDgwKSk7XG4gIH1cblxuICAvLyBJZiB2ZXJ5IGRlbnNlLCBhbGxvdyBtb3JlIHdpZHRoXG4gIGlmIChub2RlQ291bnQgPj0gMTApIHtcbiAgICBjaGFydFdpZHRoID0gTWF0aC5taW4oTUFYX0NIQVJUX1dJRFRILCBNYXRoLm1heChjaGFydFdpZHRoLCA5MDApKTtcbiAgfVxuXG4gIC8vIERlYnVnIGxvZ2dpbmdcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0FsbHV2aWFsRGlhZ3JhbSBEZWJ1Z10nKTtcbiAgICBjb25zb2xlLmxvZygnICBDb250YWluZXI6JywgY29udGFpbmVyV2lkdGgsICd4JywgY29udGFpbmVySGVpZ2h0KTtcbiAgICBjb25zb2xlLmxvZygnICBDaGFydDonLCBjaGFydFdpZHRoLCAneCcsIGNoYXJ0SGVpZ2h0KTtcbiAgICBjb25zb2xlLmxvZygnICBOb2RlIGNvdW50IChzb3VyY2VzL3RhcmdldHMpOicsIHNvdXJjZXMubGVuZ3RoLCB0YXJnZXRzLmxlbmd0aCk7XG4gICAgY29uc29sZS5sb2coJyAgbm9kZUhlaWdodDonLCBub2RlSGVpZ2h0KTtcbiAgICBjb25zb2xlLmxvZygnICBub2RlUGFkZGluZzonLCBub2RlUGFkZGluZyk7XG4gICAgY29uc29sZS5sb2coJyAgbGFiZWxGb250U2l6ZTonLCBsYWJlbEZvbnRTaXplKTtcbiAgfSwgW2NvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQsIGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0LCBzb3VyY2VzLmxlbmd0aCwgdGFyZ2V0cy5sZW5ndGgsIG5vZGVIZWlnaHQsIG5vZGVQYWRkaW5nLCBsYWJlbEZvbnRTaXplXSk7XG5cbiAgLy8gVXNlIHJlZnMgdG8gdHJhY2sgY3VycmVudCB2YWx1ZXMgd2l0aG91dCB0cmlnZ2VyaW5nIHJlLXJlbmRlcnNcbiAgY29uc3QgY3VycmVudFNvdXJjZVJlZiA9IHVzZVJlZihjdXJyZW50U291cmNlKTtcbiAgY29uc3QgY3VycmVudFRhcmdldFJlZiA9IHVzZVJlZihjdXJyZW50VGFyZ2V0KTtcbiAgXG4gIC8vIFVwZGF0ZSByZWZzIHdoZW4gc3RhdGUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGN1cnJlbnRTb3VyY2VSZWYuY3VycmVudCA9IGN1cnJlbnRTb3VyY2U7XG4gIH0sIFtjdXJyZW50U291cmNlXSk7XG4gIFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGN1cnJlbnRUYXJnZXRSZWYuY3VycmVudCA9IGN1cnJlbnRUYXJnZXQ7XG4gIH0sIFtjdXJyZW50VGFyZ2V0XSk7XG4gIGNvbnN0IFtpbnNpZ2h0cywgc2V0SW5zaWdodHNdID0gdXNlU3RhdGU8QXJyYXk8eyB0aXRsZTogc3RyaW5nOyB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyOyBkZXNjcmlwdGlvbj86IHN0cmluZyB9Pj4oW10pO1xuICBjb25zdCBbaG92ZXJlZE5vZGUsIHNldEhvdmVyZWROb2RlXSA9IHVzZVN0YXRlPFNhbmtleU5vZGUgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2hvdmVyZWRMaW5rLCBzZXRIb3ZlcmVkTGlua10gPSB1c2VTdGF0ZTxTYW5rZXlMaW5rIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFt0b29sdGlwLCBzZXRUb29sdGlwXSA9IHVzZVN0YXRlPFRvb2x0aXBTdGF0ZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbGFzdENhdGVnb3J5Q2hhbmdlLCBzZXRMYXN0Q2F0ZWdvcnlDaGFuZ2VdID0gdXNlU3RhdGU8eyBzb3VyY2U6IHN0cmluZzsgdGFyZ2V0OiBzdHJpbmcgfT4oeyBzb3VyY2U6IGN1cnJlbnRTb3VyY2UsIHRhcmdldDogY3VycmVudFRhcmdldCB9KTtcbiAgY29uc3QgW2N1cnJlbnRUYXJnZXRJbmRleCwgc2V0Q3VycmVudFRhcmdldEluZGV4XSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtpc0FuaW1hdGluZywgc2V0SXNBbmltYXRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtob3ZlcmVkU291cmNlSW5kZXgsIHNldEhvdmVyZWRTb3VyY2VJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2hvdmVyZWRUYXJnZXRJbmRleCwgc2V0SG92ZXJlZFRhcmdldEluZGV4XSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNJbkZ1bGxPcGFjaXR5U3RhdGUsIHNldElzSW5GdWxsT3BhY2l0eVN0YXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2FuaW1hdGlvblBoYXNlLCBzZXRBbmltYXRpb25QaGFzZV0gPSB1c2VTdGF0ZTwnZnVsbCcgfCAnaGlnaGxpZ2h0aW5nJyB8ICd0cmFuc2l0aW9uaW5nJz4oJ2Z1bGwnKTtcblxuICBjb25zdCBhbmltYXRpb25SZWYgPSB1c2VSZWY8QW5pbWF0aW9uU3RhdGU+KHtcbiAgICB0aW1lcjogbnVsbCxcbiAgICBydW5uaW5nOiBmYWxzZSxcbiAgICBjdXJyZW50U291cmNlSW5kZXg6IDAsXG4gICAgY3VycmVudFRhcmdldEluZGV4OiAwLFxuICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICBwYXVzZWRBdDogRGF0ZS5ub3coKSxcbiAgICByZXN1bWVGcm9tOiBudWxsLFxuICAgIGN5Y2xlQ291bnQ6IDBcbiAgfSk7XG5cbiAgLy8gQ2hlY2sgZm9yIHJlZHVjZWQgbW90aW9uIHByZWZlcmVuY2VcbiAgY29uc3QgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpJykubWF0Y2hlcztcbiAgfSwgW10pO1xuXG4gIC8vIEFkanVzdCBhbmltYXRpb24gZHVyYXRpb25zIGJhc2VkIG9uIG1vdGlvbiBwcmVmZXJlbmNlXG4gIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGJhc2VTcGVlZCA9IHNldHRpbmdzLmF1dG9QbGF5U3BlZWQgfHwgMzAwMDtcbiAgICBjb25zdCByZWR1Y3Rpb25GYWN0b3IgPSBwcmVmZXJzUmVkdWNlZE1vdGlvbiA/IDAuNSA6IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0ZXBEdXJhdGlvbjogTWF0aC5tYXgoODAwLCAoYmFzZVNwZWVkIC8gOCkgKiByZWR1Y3Rpb25GYWN0b3IpLFxuICAgICAgcGF1c2VEdXJhdGlvbjogTWF0aC5tYXgoNDAwLCAoYmFzZVNwZWVkIC8gMTIpICogcmVkdWN0aW9uRmFjdG9yKSxcbiAgICAgIGNhdGVnb3J5UGF1c2VEdXJhdGlvbjogTWF0aC5tYXgoMTUwMCwgKGJhc2VTcGVlZCAvIDMpICogcmVkdWN0aW9uRmFjdG9yKSxcbiAgICAgIGxpbmtUcmFuc2l0aW9uRHVyYXRpb246IHByZWZlcnNSZWR1Y2VkTW90aW9uID8gNDAwIDogNzUwXG4gICAgfTtcbiAgfSwgW3NldHRpbmdzLmF1dG9QbGF5U3BlZWQsIHByZWZlcnNSZWR1Y2VkTW90aW9uXSk7XG5cbiAgLy8gR2V0IHZpc3VhbCBvcmRlciBvZiBzb3VyY2Ugbm9kZXMgKHRvcC10by1ib3R0b20gYXMgdGhleSBhcHBlYXIpXG4gIGNvbnN0IHNvcnRlZFNvdXJjZXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWZpbHRlcmVkRGF0YS5sZW5ndGggfHwgIWNoYXJ0V2lkdGggfHwgIWNoYXJ0SGVpZ2h0KSByZXR1cm4gc291cmNlcztcblxuICAgIGNvbnN0IHNvdXJjZXNGb3JOb2RlcyA9IFsuLi5zb3VyY2VzXTtcbiAgICBpZiAoY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycpIHtcbiAgICAgIHNvdXJjZXNGb3JOb2Rlcy5zb3J0KChhLCBiKSA9PiBZRUFSU19DQVRFR09SSUVTLmluZGV4T2YoYSkgLSBZRUFSU19DQVRFR09SSUVTLmluZGV4T2YoYikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VzRm9yTm9kZXMuc29ydCgpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBTYW5rZXkgbGF5b3V0IHRvIGdldCB2aXN1YWwgb3JkZXJcbiAgICBjb25zdCBub2RlcyA9IFtcbiAgICAgIC4uLnNvdXJjZXNGb3JOb2Rlcy5tYXAoKG5hbWUpID0+ICh7IGlkOiBgJHtjdXJyZW50U291cmNlfToke25hbWV9YCwgbmFtZSwgY2F0ZWdvcnk6IGN1cnJlbnRTb3VyY2UgfSkpLFxuICAgICAgLi4udGFyZ2V0cy5tYXAoKG5hbWUpID0+ICh7IGlkOiBgJHtjdXJyZW50VGFyZ2V0fToke25hbWV9YCwgbmFtZSwgY2F0ZWdvcnk6IGN1cnJlbnRUYXJnZXQgfSkpLFxuICAgIF07XG5cbiAgICBjb25zdCBsaW5rc01hcCA9IG5ldyBNYXA8c3RyaW5nLCB7IHNvdXJjZTogc3RyaW5nOyB0YXJnZXQ6IHN0cmluZzsgdmFsdWU6IG51bWJlciB9PigpOyBcbiAgICBmaWx0ZXJlZERhdGEuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgY29uc3Qgc291cmNlID0gY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycgXG4gICAgICAgID8gZ2V0VmFsaWRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApIFxuICAgICAgICA6IChkIGFzIGFueSlbY3VycmVudFNvdXJjZV07XG4gICAgICBjb25zdCB0YXJnZXQgPSBjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJ1xuICAgICAgICA/IGdldFZhbGlkWWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKVxuICAgICAgICA6IChkIGFzIGFueSlbY3VycmVudFRhcmdldF07XG4gICAgICBcbiAgICAgIGlmICghc291cmNlc0Zvck5vZGVzLmluY2x1ZGVzKHNvdXJjZSkgfHwgIXRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgXG4gICAgICBjb25zdCBzb3VyY2VJZCA9IGAke2N1cnJlbnRTb3VyY2V9OiR7c291cmNlfWA7XG4gICAgICBjb25zdCB0YXJnZXRJZCA9IGAke2N1cnJlbnRUYXJnZXR9OiR7dGFyZ2V0fWA7XG4gICAgICBjb25zdCBrZXkgPSBgJHtzb3VyY2VJZH3ihpIke3RhcmdldElkfWA7XG4gICAgICBcbiAgICAgIGlmICghbGlua3NNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgbGlua3NNYXAuc2V0KGtleSwgeyBzb3VyY2U6IHNvdXJjZUlkLCB0YXJnZXQ6IHRhcmdldElkLCB2YWx1ZTogMCB9KTtcbiAgICAgIH1cbiAgICAgIGxpbmtzTWFwLmdldChrZXkpIS52YWx1ZSArPSAxO1xuICAgIH0pO1xuXG4gICAgY29uc3QgbGlua3MgPSBBcnJheS5mcm9tKGxpbmtzTWFwLnZhbHVlcygpKTtcbiAgICBjb25zdCBzYW5rZXlHZW5lcmF0b3IgPSBzYW5rZXk8YW55LCBhbnk+KClcbiAgICAgIC5ub2RlSWQoKGQ6IGFueSkgPT4gZC5pZClcbiAgICAgIC5ub2RlV2lkdGgoMTIpXG4gICAgICAubm9kZVBhZGRpbmcobm9kZVBhZGRpbmcpXG4gICAgICAuZXh0ZW50KFtbMCwgMF0sIFtjaGFydFdpZHRoLCBjaGFydEhlaWdodF1dKTtcblxuICAgIGNvbnN0IHNhbmtleURhdGEgPSBzYW5rZXlHZW5lcmF0b3Ioe1xuICAgICAgbm9kZXM6IG5vZGVzLm1hcCgoZCkgPT4gKHsgLi4uZCB9KSksXG4gICAgICBsaW5rczogbGlua3MubWFwKChkKSA9PiAoeyAuLi5kIH0pKSxcbiAgICB9KTtcblxuICAgIC8vIEdldCBzb3VyY2Ugbm9kZXMgaW4gdmlzdWFsIG9yZGVyICh0b3AgdG8gYm90dG9tKVxuICAgIGNvbnN0IHNvdXJjZU5vZGVzID0gc2Fua2V5RGF0YS5ub2Rlc1xuICAgICAgLmZpbHRlcigoZDogYW55KSA9PiBkLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlKVxuICAgICAgLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiBhLnkwIC0gYi55MCk7XG5cbiAgICByZXR1cm4gc291cmNlTm9kZXMubWFwKChkOiBhbnkpID0+IGQubmFtZSk7XG4gIH0sIFtmaWx0ZXJlZERhdGEsIHNvdXJjZXMsIHRhcmdldHMsIGN1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXQsIGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0LCBub2RlUGFkZGluZ10pO1xuXG4gIC8vIEVuaGFuY2VkIGFuaW1hdGlvbiBmdW5jdGlvbiB3aXRoIGNvbXByZWhlbnNpdmUgZGVidWcgdHJhY2tpbmdcbiAgY29uc3QgYW5pbWF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAvLyBDaGVjayBpZiBhbmltYXRpb24gaXMgcGF1c2VkXG4gICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4o+477iPICBBbmltYXRpb24gaXMgcGF1c2VkLCBza2lwcGluZyBjeWNsZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyB8fCAhZmlsdGVyZWREYXRhLmxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBBbmltYXRpb24gc3RvcHBlZDonLCB7XG4gICAgICAgIHJ1bm5pbmc6IGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcsXG4gICAgICAgIGRhdGFMZW5ndGg6IGZpbHRlcmVkRGF0YS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNhZmV0eSBjaGVjazogcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5jeWNsZUNvdW50ID4gMTAwMCkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfm5EgQW5pbWF0aW9uIGN5Y2xlIGxpbWl0IHJlYWNoZWQsIHJlc2V0dGluZycpO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3ljbGVDb3VudCA9IDA7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXggPSAwO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvLyBJbmNyZW1lbnQgY3ljbGUgY291bnRlclxuICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN5Y2xlQ291bnQrKztcblxuICAgIC8vIFNldCBhbmltYXRpb24gcGhhc2UgdG8gaGlnaGxpZ2h0aW5nXG4gICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgICBzZXRJc0luRnVsbE9wYWNpdHlTdGF0ZShmYWxzZSk7XG4gICAgXG4gICAgLy8gU2V0IHRoZSBob3ZlcmVkIHNvdXJjZSBpbmRleCB0byBtYXRjaCB0aGUgYW5pbWF0aW9uXG4gICAgc2V0SG92ZXJlZFNvdXJjZUluZGV4KGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCk7XG5cbiAgICBjb25zdCB0YXJnZXRPcHRpb25zID0gYXZhaWxhYmxlRmllbGRzXG4gICAgICAuZmlsdGVyKGYgPT4gZi52YWx1ZSAhPT0gY3VycmVudFNvdXJjZVJlZi5jdXJyZW50KVxuICAgICAgLm1hcChmID0+IGYudmFsdWUpO1xuICAgIFxuICAgIC8vIERlYnVnOiBMb2cgdGhlIHRhcmdldCBvcHRpb25zIHRvIHZlcmlmeSB0aGV5J3JlIGNvcnJlY3RcbiAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4ID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+OryBBdmFpbGFibGUgdGFyZ2V0IG9wdGlvbnMgZm9yJywgY3VycmVudFNvdXJjZVJlZi5jdXJyZW50LCAnOicsIHRhcmdldE9wdGlvbnMpO1xuICAgIH1cblxuICAgICAgICAgIC8vIENPTVBSRUhFTlNJVkUgREVCVUc6IExvZyBjdXJyZW50IHN0YXRlIHdpdGggZnVsbCBkZXRhaWxcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIEFOSU1BVElPTiBDWUNMRSBERUJVRzonLCB7XG4gICAgICAgICfwn5ONIEN1cnJlbnQgUG9zaXRpb24nOiB7XG4gICAgICAgICAgc291cmNlSW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCxcbiAgICAgICAgICB0YXJnZXRJbmRleDogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4LFxuICAgICAgICAgIHNvdXJjZU5hbWU6IHNvcnRlZFNvdXJjZXNbYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4XSxcbiAgICAgICAgICB0YXJnZXROYW1lOiBjdXJyZW50VGFyZ2V0UmVmLmN1cnJlbnRcbiAgICAgICAgfSxcbiAgICAgICAgJ/Cfk4ogQ2F0ZWdvcmllcyc6IHtcbiAgICAgICAgICBjdXJyZW50U291cmNlOiBjdXJyZW50U291cmNlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgY3VycmVudFRhcmdldDogY3VycmVudFRhcmdldFJlZi5jdXJyZW50LFxuICAgICAgICAgIHNvdXJjZU9wdGlvbnM6IGF2YWlsYWJsZUZpZWxkcy5tYXAoZiA9PiBmLnZhbHVlKSxcbiAgICAgICAgICB0YXJnZXRPcHRpb25zXG4gICAgICAgIH0sXG4gICAgICAn8J+TiCBQcm9ncmVzcyc6IHtcbiAgICAgICAgc291cmNlUHJvZ3Jlc3M6IGAke2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCArIDF9LyR7c29ydGVkU291cmNlcy5sZW5ndGh9YCxcbiAgICAgICAgdGFyZ2V0UHJvZ3Jlc3M6IGAke2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCArIDF9LyR7dGFyZ2V0T3B0aW9ucy5sZW5ndGh9YCxcbiAgICAgICAgaXNMYXN0U291cmNlOiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXggPj0gc29ydGVkU291cmNlcy5sZW5ndGggLSAxLFxuICAgICAgICBoYXNNb3JlVGFyZ2V0czogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4IDwgdGFyZ2V0T3B0aW9ucy5sZW5ndGggLSAxXG4gICAgICB9LFxuICAgICAgJ/Cfjq8gU291cmNlcyc6IHNvcnRlZFNvdXJjZXMsXG4gICAgICAn8J+OryBUYXJnZXRzJzogdGFyZ2V0T3B0aW9ucyxcbiAgICAgICfij7HvuI8gIFRpbWluZ3MnOiBhbmltYXRpb25EdXJhdGlvbnNcbiAgICB9KTtcblxuICAgICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXggPCBzb3J0ZWRTb3VyY2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gTW92ZSB0byBuZXh0IHNvdXJjZVxuICAgICAgICBjb25zdCBuZXh0VGltZW91dCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5zdGVwRHVyYXRpb24gKyBhbmltYXRpb25EdXJhdGlvbnMucGF1c2VEdXJhdGlvbjtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBgJHthbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXggKyAxfS8ke3NvcnRlZFNvdXJjZXMubGVuZ3RofWA7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46vIFNvdXJjZSAke3Byb2dyZXNzfTogSGlnaGxpZ2h0aW5nICcke3NvcnRlZFNvdXJjZXNbYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4XX0nIOKGkiAnJHtjdXJyZW50VGFyZ2V0UmVmLmN1cnJlbnR9JyBmb3IgJHtuZXh0VGltZW91dH1tc2ApO1xuICAgICAgXG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIWFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgfHwgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHJldHVybjtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4Kys7XG4gICAgICAgIGFuaW1hdGUoKTtcbiAgICAgIH0sIG5leHRUaW1lb3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZnRlciBsYXN0IHNvdXJjZSwgY2hlY2sgaWYgd2UgbmVlZCB0byBjeWNsZSB0YXJnZXRzIG9yIGNoYW5nZSBzb3VyY2UgY2F0ZWdvcnlcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIEVORCBPRiBTT1VSQ0VTIC0gQ2hlY2tpbmcgdGFyZ2V0IGN5Y2xpbmc6Jywge1xuICAgICAgICBjdXJyZW50VGFyZ2V0SW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCxcbiAgICAgICAgdGFyZ2V0T3B0aW9uc0xlbmd0aDogdGFyZ2V0T3B0aW9ucy5sZW5ndGgsXG4gICAgICAgIGhhc01vcmVUYXJnZXRzOiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXggPCB0YXJnZXRPcHRpb25zLmxlbmd0aCAtIDEsXG4gICAgICAgIGF2YWlsYWJsZVRhcmdldHM6IHRhcmdldE9wdGlvbnNcbiAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXggPCB0YXJnZXRPcHRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBTdGlsbCBoYXZlIG1vcmUgdGFyZ2V0IGNhdGVnb3JpZXMgdG8gY3ljbGUgdGhyb3VnaFxuICAgICAgICAgIGNvbnN0IHRhcmdldFByb2dyZXNzID0gYCR7YW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4ICsgMn0vJHt0YXJnZXRPcHRpb25zLmxlbmd0aH1gO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIOKchSBDT01QTEVURUQgQUxMIFNPVVJDRVMgZm9yICcke2N1cnJlbnRUYXJnZXRSZWYuY3VycmVudH0nLCBtb3ZpbmcgdG8gbmV4dCB0YXJnZXQgKCR7dGFyZ2V0UHJvZ3Jlc3N9KWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lciB0byBwcmV2ZW50IGNvbmZsaWN0c1xuICAgICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKTtcbiAgICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyB8fCBhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ3RyYW5zaXRpb25pbmcnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTW92ZSB0byBuZXh0IHRhcmdldCBjYXRlZ29yeVxuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4Kys7XG4gICAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gdGFyZ2V0T3B0aW9uc1thbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8g4pyoIE5FVyBUQVJHRVQgQ0FURUdPUlk6JywgbmV4dFRhcmdldCwgYCgke2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCArIDF9LyR7dGFyZ2V0T3B0aW9ucy5sZW5ndGh9KWApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflI0gVGFyZ2V0IHByb2dyZXNzaW9uIGRlYnVnOicsIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNUYXJnZXQ6IGN1cnJlbnRUYXJnZXRSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgbmV4dFRhcmdldCxcbiAgICAgICAgICAgICAgY3VycmVudFRhcmdldEluZGV4OiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXgsXG4gICAgICAgICAgICAgIGFsbFRhcmdldE9wdGlvbnM6IHRhcmdldE9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0Q3VycmVudFRhcmdldChuZXh0VGFyZ2V0KTtcbiAgICAgICAgICAgIHNldExhc3RDYXRlZ29yeUNoYW5nZSh7IHNvdXJjZTogY3VycmVudFNvdXJjZVJlZi5jdXJyZW50LCB0YXJnZXQ6IG5leHRUYXJnZXQgfSk7XG4gICAgICAgICAgICBvblF1ZXN0aW9uQ2hhbmdlPy4oY3VycmVudFNvdXJjZVJlZi5jdXJyZW50LCBuZXh0VGFyZ2V0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlc2V0IHNvdXJjZSBpbmRleCBhbmQgcmVzdGFydCB3aXRoIG5ldyB0YXJnZXRcbiAgICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCA9IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IGN5Y2xlIGFmdGVyIGEgYnJpZWYgcGF1c2VcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyAmJiAhYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGFuaW1hdGlvbkR1cmF0aW9ucy5jYXRlZ29yeVBhdXNlRHVyYXRpb24pO1xuICAgICAgICAgIH0sIGFuaW1hdGlvbkR1cmF0aW9ucy5jYXRlZ29yeVBhdXNlRHVyYXRpb24pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlJ3ZlIGN5Y2xlZCB0aHJvdWdoIGFsbCB0YXJnZXRzLCBub3cgY2hhbmdlIHRoZSBzb3VyY2UgY2F0ZWdvcnlcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCDinKggQ09NUExFVEVEIEFMTCBUQVJHRVRTIGZvciAnJHtjdXJyZW50U291cmNlUmVmLmN1cnJlbnR9JyAtIE1vdmluZyB0byBuZXh0IHNvdXJjZSBjYXRlZ29yeSEg4pyoYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyIHRvIHByZXZlbnQgY29uZmxpY3RzXG4gICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpO1xuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nIHx8IGFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSByZXR1cm47XG4gICAgICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgndHJhbnNpdGlvbmluZycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgc291cmNlIGNhdGVnb3J5XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VPcHRpb25zID0gYXZhaWxhYmxlRmllbGRzLm1hcChmID0+IGYudmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFNvdXJjZUluZGV4ID0gc291cmNlT3B0aW9ucy5pbmRleE9mKGN1cnJlbnRTb3VyY2VSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0U291cmNlSW5kZXggPSAoY3VycmVudFNvdXJjZUluZGV4ICsgMSkgJSBzb3VyY2VPcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTb3VyY2UgPSBzb3VyY2VPcHRpb25zW25leHRTb3VyY2VJbmRleF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46vIPCfhpUgTkVXIFNPVVJDRSBDQVRFR09SWTonLCBuZXh0U291cmNlLCAnLSBTdGFydGluZyBmcmVzaCBjeWNsZSB3aXRoIGFsbCB0YXJnZXRzJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0YXJnZXQgb3B0aW9ucyBmb3IgdGhlIE5FVyBzb3VyY2UgKGluY2x1ZGluZyB5ZWFyc19hdF9tZWR0cm9uaWMpXG4gICAgICAgICAgICBjb25zdCBuZXdUYXJnZXRPcHRpb25zID0gYXZhaWxhYmxlRmllbGRzXG4gICAgICAgICAgICAgIC5maWx0ZXIoZiA9PiBmLnZhbHVlICE9PSBuZXh0U291cmNlKVxuICAgICAgICAgICAgICAubWFwKGYgPT4gZi52YWx1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIE5ldyB0YXJnZXQgb3B0aW9ucyBmb3InLCBuZXh0U291cmNlLCAnOicsIG5ld1RhcmdldE9wdGlvbnMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXRDdXJyZW50U291cmNlKG5leHRTb3VyY2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXNldCBib3RoIGluZGljZXMgYW5kIHN0YXJ0IHdpdGggZmlyc3QgdGFyZ2V0IGFnYWluXG4gICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXggPSAwO1xuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VGFyZ2V0ID0gbmV3VGFyZ2V0T3B0aW9uc1swXTtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUYXJnZXQoZmlyc3RUYXJnZXQpO1xuICAgICAgICAgICAgc2V0TGFzdENhdGVnb3J5Q2hhbmdlKHsgc291cmNlOiBuZXh0U291cmNlLCB0YXJnZXQ6IGZpcnN0VGFyZ2V0IH0pO1xuICAgICAgICAgICAgb25RdWVzdGlvbkNoYW5nZT8uKG5leHRTb3VyY2UsIGZpcnN0VGFyZ2V0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IGN5Y2xlIGFmdGVyIGEgbG9uZ2VyIHBhdXNlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhbmltYXRpb25EdXJhdGlvbnMuY2F0ZWdvcnlQYXVzZUR1cmF0aW9uICogMS41KTsgLy8gTG9uZ2VyIHBhdXNlIGZvciBzb3VyY2UgY2F0ZWdvcnkgY2hhbmdlXG4gICAgICAgICAgfSwgYW5pbWF0aW9uRHVyYXRpb25zLmNhdGVnb3J5UGF1c2VEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LCBbXG4gICAgZGF0YS5sZW5ndGgsXG4gICAgc29ydGVkU291cmNlcy5sZW5ndGgsXG4gICAgb25RdWVzdGlvbkNoYW5nZSxcbiAgICBhbmltYXRpb25EdXJhdGlvbnMsXG4gICAgYXZhaWxhYmxlRmllbGRzXG4gICAgLy8gUmVtb3ZlZCBzb3J0ZWRTb3VyY2VzIHRvIHByZXZlbnQgZGVwZW5kZW5jeSBsb29wc1xuICBdKTtcblxuXG5cbiAgLy8gQW5pbWF0aW9uIGVmZmVjdCAtIHJlc3RhcnQgd2hlbiBzZXR0aW5ncyBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygn8J+OrCBBbmltYXRpb24gdXNlRWZmZWN0IHRyaWdnZXJlZDonLCB7XG4gICAgICBhdXRvUGxheSxcbiAgICAgIGlzQXV0b1BsYXlFbmFibGVkOiBzZXR0aW5ncy5pc0F1dG9QbGF5RW5hYmxlZCxcbiAgICAgIGRhdGFMZW5ndGg6IGRhdGEubGVuZ3RoLFxuICAgICAgc3ZnUmVmRXhpc3RzOiAhIXN2Z1JlZi5jdXJyZW50LFxuICAgICAgY3VycmVudFNvdXJjZSxcbiAgICAgIGN1cnJlbnRUYXJnZXQsXG4gICAgICBhdXRvUGxheVNwZWVkOiBzZXR0aW5ncy5hdXRvUGxheVNwZWVkLFxuICAgICAgaXNSdW5uaW5nOiBhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nXG4gICAgfSk7XG5cbiAgICBpZiAoIWF1dG9QbGF5IHx8ICFzZXR0aW5ncy5pc0F1dG9QbGF5RW5hYmxlZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBBbmltYXRpb24gZGlzYWJsZWQnKTtcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpO1xuICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBzZXRBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgc2V0SXNJbkZ1bGxPcGFjaXR5U3RhdGUodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICghZmlsdGVyZWREYXRhLmxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBObyBkYXRhIGF2YWlsYWJsZSBmb3IgYW5pbWF0aW9uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc3ZnUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgU1ZHIHJlZiBub3QgYXZhaWxhYmxlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVzdGFydCBhbmltYXRpb24gd2hlbiBzcGVlZCBjaGFuZ2VzIG9yIG9uIG1ham9yIGNoYW5nZXNcbiAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZykge1xuICAgICAgY29uc29sZS5sb2coJ/CflIQgUmVzdGFydGluZyBhbmltYXRpb24gd2l0aCBuZXcgc2V0dGluZ3M6Jywge1xuICAgICAgICBzb3VyY2VDYXRlZ29yeTogY3VycmVudFNvdXJjZSxcbiAgICAgICAgdG90YWxTb3VyY2VzOiBzb3J0ZWRTb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgdG90YWxUYXJnZXRzOiBhdmFpbGFibGVGaWVsZHMuZmlsdGVyKGYgPT4gZi52YWx1ZSAhPT0gY3VycmVudFNvdXJjZSkubGVuZ3RoLFxuICAgICAgICBzcGVlZDogc2V0dGluZ3MuYXV0b1BsYXlTcGVlZCArICdtcydcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKTtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IG5ldyBhbmltYXRpb24gY3ljbGVcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU3RhcnRpbmcgYW5pbWF0aW9uIGN5Y2xlOicsIHtcbiAgICAgICAgc291cmNlQ2F0ZWdvcnk6IGN1cnJlbnRTb3VyY2UsXG4gICAgICAgIHRvdGFsU291cmNlczogc29ydGVkU291cmNlcy5sZW5ndGgsXG4gICAgICAgIHRvdGFsVGFyZ2V0czogYXZhaWxhYmxlRmllbGRzLmZpbHRlcihmID0+IGYudmFsdWUgIT09IGN1cnJlbnRTb3VyY2UpLmxlbmd0aCxcbiAgICAgICAgc3BlZWQ6IHNldHRpbmdzLmF1dG9QbGF5U3BlZWQgKyAnbXMnXG4gICAgICB9KTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBhbmltYXRpb24gc3RhdGVcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4ID0gMDtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCA9IDA7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jeWNsZUNvdW50ID0gMDsgLy8gUmVzZXQgY3ljbGUgY291bnRlclxuXG4gICAgICAvLyBTdGFydCBhbmltYXRpb25cbiAgICAgIGFuaW1hdGUoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKTtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyA9IGZhbHNlO1xuICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgIHNldElzSW5GdWxsT3BhY2l0eVN0YXRlKHRydWUpO1xuICAgIH07XG4gIH0sIFtcbiAgICBhdXRvUGxheSxcbiAgICBzZXR0aW5ncy5pc0F1dG9QbGF5RW5hYmxlZCxcbiAgICBzZXR0aW5ncy5hdXRvUGxheVNwZWVkLCAvLyBBZGQgdGhpcyB0byByZXN0YXJ0IHdoZW4gc3BlZWQgY2hhbmdlc1xuICAgIGZpbHRlcmVkRGF0YS5sZW5ndGgsXG4gICAgY3VycmVudFNvdXJjZSAvLyBPbmx5IHJlc3RhcnQgb24gc291cmNlIGNoYW5nZXMsIG5vdCB0YXJnZXQgY2hhbmdlc1xuICBdKTtcblxuICBjb25zdCBub2RlTGFiZWxGb250U2l6ZSA9IDE4OyAvLyBsYXJnZXIgZm9yIHJlYWRhYmlsaXR5XG4gIGNvbnN0IG5vZGVMYWJlbEZvbnRXZWlnaHQgPSA3MDA7XG4gIGNvbnN0IG5vZGVMYWJlbENvbG9yID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICcjRkZGRkZGJyA6ICcjMTcwRjVGJztcbiAgY29uc3Qgbm9kZUxhYmVsRm9udEZhbWlseSA9ICdBdmVuaXIgTmV4dCBXb3JsZCwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNGIFByb1wiLCBcIlJvYm90b1wiLCBzYW5zLXNlcmlmJztcbiAgY29uc3Qgbm9kZUxhYmVsT2Zmc2V0ID0gMjQ7XG5cbiAgLy8gTG9jYWwgZGVidWcgdG9nZ2xlIGZvciB0aGlzIGNvbXBvbmVudCBpZiBubyBnbG9iYWwgYWRtaW4gY29udGV4dFxuICBjb25zdCBbbG9jYWxEZWJ1Zywgc2V0TG9jYWxEZWJ1Z10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93VGhlbWVUb2dnbGUsIHNldFNob3dUaGVtZVRvZ2dsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGRlYnVnT24gPSBsb2NhbERlYnVnO1xuXG4gIC8vIERlYnVnIFNhbmtleSBkYXRhIGZvciBvdXRsaW5lc1xuICBjb25zdCBbZGVidWdTYW5rZXlEYXRhLCBzZXREZWJ1Z1NhbmtleURhdGFdID0gdXNlU3RhdGU8YW55PihudWxsKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlcykgfHwgIUFycmF5LmlzQXJyYXkodGFyZ2V0cykpIHJldHVybjtcbiAgICBjb25zdCBub2RlcyA9IFtcbiAgICAgIC4uLnNvdXJjZXMubWFwKChuYW1lKSA9PiAoeyBpZDogYHNvdXJjZToke25hbWV9YCwgbmFtZSwgY2F0ZWdvcnk6ICdzb3VyY2UnIH0pKSxcbiAgICAgIC4uLnRhcmdldHMubWFwKChuYW1lKSA9PiAoeyBpZDogYHRhcmdldDoke25hbWV9YCwgbmFtZSwgY2F0ZWdvcnk6ICd0YXJnZXQnIH0pKSxcbiAgICBdO1xuICAgIC8vIE9ubHkgY3JlYXRlIGxpbmtzIGlmIGJvdGggc2lkZXMgaGF2ZSBhdCBsZWFzdCBvbmUgbm9kZVxuICAgIGNvbnN0IGxpbmtzID0gKHNvdXJjZXMubGVuZ3RoICYmIHRhcmdldHMubGVuZ3RoKVxuICAgICAgPyBbeyBzb3VyY2U6IGBzb3VyY2U6JHtzb3VyY2VzWzBdfWAsIHRhcmdldDogYHRhcmdldDoke3RhcmdldHNbMF19YCwgdmFsdWU6IDEgfV1cbiAgICAgIDogW107XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA8IDIgfHwgbGlua3MubGVuZ3RoIDwgMSkgcmV0dXJuOyAvLyBQcmV2ZW50IGludmFsaWQgYXJyYXkgbGVuZ3RoXG4gICAgY29uc3Qgc2Fua2V5R2VuZXJhdG9yID0gc2Fua2V5PGFueSwgYW55PigpXG4gICAgICAubm9kZUlkKChkOiBhbnkpID0+IGQuaWQpXG4gICAgICAubm9kZVdpZHRoKDEyKVxuICAgICAgLm5vZGVQYWRkaW5nKG5vZGVQYWRkaW5nKVxuICAgICAgLmV4dGVudChbWzAsIDBdLCBbY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHRdXSk7XG4gICAgY29uc3Qgc2Fua2V5RGF0YSA9IHNhbmtleUdlbmVyYXRvcih7IG5vZGVzOiBub2Rlcy5tYXAoKGQpID0+ICh7IC4uLmQgfSkpLCBsaW5rczogbGlua3MubWFwKChkKSA9PiAoeyAuLi5kIH0pKSB9KTtcbiAgICBzZXREZWJ1Z1NhbmtleURhdGEoc2Fua2V5RGF0YSk7XG4gIH0sIFtzb3VyY2VzLCB0YXJnZXRzLCBjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgbm9kZVBhZGRpbmddKTtcblxuICAvLyBSZW5kZXIgU2Fua2V5IGRpYWdyYW1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN2Z1JlZi5jdXJyZW50IHx8ICFmaWx0ZXJlZERhdGEubGVuZ3RoKSByZXR1cm47XG5cbiAgICAvLyAtLS0gUGVyc2lzdGVudCBTVkcgc3RydWN0dXJlIC0tLVxuICAgIGNvbnN0IHN2ZyA9IGQzLnNlbGVjdDxTVkdTVkdFbGVtZW50LCB1bmtub3duPihzdmdSZWYuY3VycmVudCk7XG4gICAgc3ZnLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpOyAvLyBDbGVhciBwcmV2aW91cyBjb250ZW50XG4gICAgc3ZnXG4gICAgICAuYXR0cignd2lkdGgnLCBjb250YWluZXJXaWR0aClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBjb250YWluZXJIZWlnaHQpO1xuXG4gICAgLy8gLS0tIFNhbmtleSBub2RlL2xpbmsgY3JlYXRpb24gYW5kIHZlcnRpY2FsIGNlbnRlcmluZyAoZGVkdXBsaWNhdGVkKSAtLS1cbiAgICAvLyBTb3J0IHNvdXJjZSBub2RlcyB0byBtYWludGFpbiBhIGZpeGVkIG9yZGVyIChzYW1lIGFzIGFuaW1hdGlvbilcbiAgICBjb25zdCBzb3J0ZWRTb3VyY2VzID0gWy4uLnNvdXJjZXNdO1xuICAgIGlmIChjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgICAgc29ydGVkU291cmNlcy5zb3J0KChhLCBiKSA9PiBZRUFSU19DQVRFR09SSUVTLmluZGV4T2YoYSkgLSBZRUFSU19DQVRFR09SSUVTLmluZGV4T2YoYikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3J0ZWRTb3VyY2VzLnNvcnQoKTtcbiAgICB9XG4gICAgLy8gU29ydCB0YXJnZXQgbm9kZXMgdG8gbWFpbnRhaW4gYSBmaXhlZCBvcmRlclxuICAgIGNvbnN0IHNvcnRlZFRhcmdldHMgPSBbLi4udGFyZ2V0c107XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgICBzb3J0ZWRUYXJnZXRzLnNvcnQoKGEsIGIpID0+IFlFQVJTX0NBVEVHT1JJRVMuaW5kZXhPZihhKSAtIFlFQVJTX0NBVEVHT1JJRVMuaW5kZXhPZihiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvcnRlZFRhcmdldHMuc29ydCgpO1xuICAgIH1cblxuICAgIC8vIFNhbmtleSB0cmFuc2Zvcm1hdGlvbiBhY2Nlc3NvcnNcbiAgICBjb25zdCBzb3VyY2VBY2Nlc3NvciA9IChkOiBhbnkpID0+XG4gICAgICBjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJ1xuICAgICAgICA/IGdldFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMClcbiAgICAgICAgOiAoZCBhcyBhbnkpW2N1cnJlbnRTb3VyY2VdO1xuICAgIGNvbnN0IHRhcmdldEFjY2Vzc29yID0gKGQ6IGFueSkgPT5cbiAgICAgIGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICAgID8gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKVxuICAgICAgICA6IChkIGFzIGFueSlbY3VycmVudFRhcmdldF07XG5cbiAgICAvLyBGaWx0ZXIgZGF0YSB0byBvbmx5IGluY2x1ZGUgdmFsaWQgdmFsdWVzXG4gICAgY29uc3QgdmFsaWREYXRhID0gZmlsdGVyZWREYXRhLmZpbHRlcihkID0+XG4gICAgICAoY3VycmVudFNvdXJjZSAhPT0gJ3llYXJzX2F0X21lZHRyb25pYycgfHwgZC55ZWFyc19hdF9tZWR0cm9uaWMgIT09IG51bGwpICYmXG4gICAgICAoY3VycmVudFRhcmdldCAhPT0gJ3llYXJzX2F0X21lZHRyb25pYycgfHwgZC55ZWFyc19hdF9tZWR0cm9uaWMgIT09IG51bGwpXG4gICAgKTtcblxuICAgIC8vIEJ1aWxkIG5vZGVzIGFycmF5IHdpdGggdW5pcXVlIGlkc1xuICAgIGNvbnN0IG5vZGVzID0gW1xuICAgICAgLi4uc29ydGVkU291cmNlcy5tYXAoKG5hbWUpID0+ICh7IGlkOiBgJHtjdXJyZW50U291cmNlfToke25hbWV9YCwgbmFtZSwgY2F0ZWdvcnk6IGN1cnJlbnRTb3VyY2UgfSkpLFxuICAgICAgLi4uc29ydGVkVGFyZ2V0cy5tYXAoKG5hbWUpID0+ICh7IGlkOiBgJHtjdXJyZW50VGFyZ2V0fToke25hbWV9YCwgbmFtZSwgY2F0ZWdvcnk6IGN1cnJlbnRUYXJnZXQgfSkpLFxuICAgIF07XG5cbiAgICAvLyBCdWlsZCBsaW5rcyBhcnJheSAoYWdncmVnYXRlIGNvdW50cyBmb3IgZWFjaCBzb3VyY2UtdGFyZ2V0IHBhaXIpXG4gICAgY29uc3QgbGlua3NNYXAgPSBuZXcgTWFwPHN0cmluZywgeyBzb3VyY2U6IHN0cmluZzsgdGFyZ2V0OiBzdHJpbmc7IHZhbHVlOiBudW1iZXIsIGlzRHVtbXk/OiBib29sZWFuIH0+KCk7XG4gICAgLy8gMS4gRm9yIGV2ZXJ5IHBvc3NpYmxlIHNvdXJjZS10YXJnZXQgcGFpciwgY3JlYXRlIGEgbGluayAoZHVtbXkgaWYgbm8gZGF0YSlcbiAgICBzb3J0ZWRTb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgc29ydGVkVGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICAgICAgY29uc3Qgc291cmNlSWQgPSBgJHtjdXJyZW50U291cmNlfToke3NvdXJjZX1gO1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IGAke2N1cnJlbnRUYXJnZXR9OiR7dGFyZ2V0fWA7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke3NvdXJjZUlkfeKGkiR7dGFyZ2V0SWR9YDtcbiAgICAgICAgbGlua3NNYXAuc2V0KGtleSwgeyBzb3VyY2U6IHNvdXJjZUlkLCB0YXJnZXQ6IHRhcmdldElkLCB2YWx1ZTogMCwgaXNEdW1teTogdHJ1ZSB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIDIuIEZpbGwgaW4gcmVhbCBkYXRhLCBtYXJraW5nIGxpbmtzIGFzIG5vdCBkdW1teVxuICAgIHZhbGlkRGF0YS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VBY2Nlc3NvcihkKTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldEFjY2Vzc29yKGQpO1xuICAgICAgaWYgKCFzb3J0ZWRTb3VyY2VzLmluY2x1ZGVzKHNvdXJjZSkgfHwgIXNvcnRlZFRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgY29uc3Qgc291cmNlSWQgPSBgJHtjdXJyZW50U291cmNlfToke3NvdXJjZX1gO1xuICAgICAgY29uc3QgdGFyZ2V0SWQgPSBgJHtjdXJyZW50VGFyZ2V0fToke3RhcmdldH1gO1xuICAgICAgY29uc3Qga2V5ID0gYCR7c291cmNlSWR94oaSJHt0YXJnZXRJZH1gO1xuICAgICAgaWYgKCFsaW5rc01hcC5oYXMoa2V5KSkge1xuICAgICAgICBsaW5rc01hcC5zZXQoa2V5LCB7IHNvdXJjZTogc291cmNlSWQsIHRhcmdldDogdGFyZ2V0SWQsIHZhbHVlOiAxLCBpc0R1bW15OiBmYWxzZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBsaW5rc01hcC5nZXQoa2V5KSE7XG4gICAgICAgIGxpbmsudmFsdWUgKz0gMTtcbiAgICAgICAgbGluay5pc0R1bW15ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gMy4gU2V0IGR1bW15IGxpbmtzIHRvIGEgdmVyeSBzbWFsbCB2YWx1ZSBpZiBzdGlsbCBkdW1teVxuICAgIEFycmF5LmZyb20obGlua3NNYXAudmFsdWVzKCkpLmZvckVhY2gobGluayA9PiB7XG4gICAgICBpZiAobGluay5pc0R1bW15KSBsaW5rLnZhbHVlID0gMC4wMDAxO1xuICAgIH0pO1xuXG4gICAgLy8gLS0tIENPTFVNTiBIRUlHSFQgTk9STUFMSVpBVElPTiAtLS1cbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgdmFsdWUgZm9yIGVhY2ggc2lkZVxuICAgIGNvbnN0IGxlZnRUb3RhbHMgPSBzb3J0ZWRTb3VyY2VzLm1hcChzb3VyY2UgPT4ge1xuICAgICAgY29uc3Qgc291cmNlSWQgPSBgJHtjdXJyZW50U291cmNlfToke3NvdXJjZX1gO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obGlua3NNYXAudmFsdWVzKCkpLmZpbHRlcihsID0+IGwuc291cmNlID09PSBzb3VyY2VJZCkucmVkdWNlKChzdW0sIGwpID0+IHN1bSArIGwudmFsdWUsIDApO1xuICAgIH0pO1xuICAgIGNvbnN0IHJpZ2h0VG90YWxzID0gc29ydGVkVGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldElkID0gYCR7Y3VycmVudFRhcmdldH06JHt0YXJnZXR9YDtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGxpbmtzTWFwLnZhbHVlcygpKS5maWx0ZXIobCA9PiBsLnRhcmdldCA9PT0gdGFyZ2V0SWQpLnJlZHVjZSgoc3VtLCBsKSA9PiBzdW0gKyBsLnZhbHVlLCAwKTtcbiAgICB9KTtcbiAgICBjb25zdCBsZWZ0U3VtID0gbGVmdFRvdGFscy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICBjb25zdCByaWdodFN1bSA9IHJpZ2h0VG90YWxzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIC8vIElmIHN1bXMgYXJlIGRpZmZlcmVudCwgc2NhbGUgdGhlIHNtYWxsZXIgc2lkZSdzIG5vZGUgdmFsdWVzIGFuZCBsaW5rIHZhbHVlc1xuICAgIGxldCBsZWZ0U2NhbGUgPSAxLCByaWdodFNjYWxlID0gMTtcbiAgICBpZiAobGVmdFN1bSA+IDAgJiYgcmlnaHRTdW0gPiAwICYmIGxlZnRTdW0gIT09IHJpZ2h0U3VtKSB7XG4gICAgICBpZiAobGVmdFN1bSA+IHJpZ2h0U3VtKSB7XG4gICAgICAgIHJpZ2h0U2NhbGUgPSBsZWZ0U3VtIC8gcmlnaHRTdW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0U2NhbGUgPSByaWdodFN1bSAvIGxlZnRTdW07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFNjYWxlIGxpbmtzXG4gICAgQXJyYXkuZnJvbShsaW5rc01hcC52YWx1ZXMoKSkuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZUlkID0gbGluay5zb3VyY2U7XG4gICAgICBjb25zdCB0YXJnZXRJZCA9IGxpbmsudGFyZ2V0O1xuICAgICAgaWYgKGxlZnRTY2FsZSAhPT0gMSAmJiBzb3J0ZWRTb3VyY2VzLnNvbWUocyA9PiBgJHtjdXJyZW50U291cmNlfToke3N9YCA9PT0gc291cmNlSWQpKSB7XG4gICAgICAgIGxpbmsudmFsdWUgKj0gbGVmdFNjYWxlO1xuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0U2NhbGUgIT09IDEgJiYgc29ydGVkVGFyZ2V0cy5zb21lKHQgPT4gYCR7Y3VycmVudFRhcmdldH06JHt0fWAgPT09IHRhcmdldElkKSkge1xuICAgICAgICBsaW5rLnZhbHVlICo9IHJpZ2h0U2NhbGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBsaW5rcyA9IEFycmF5LmZyb20obGlua3NNYXAudmFsdWVzKCkpO1xuXG4gICAgLy8gLS0tIERZTkFNSUMgTk9ERSBQQURESU5HIC0tLVxuICAgIC8vIFJlZHVjZSBub2RlUGFkZGluZyBmb3Igc3BhcnNlIGRhdGFcbiAgICBsZXQgZHluYW1pY05vZGVQYWRkaW5nID0gbm9kZVBhZGRpbmc7XG4gICAgaWYgKHNvcnRlZFNvdXJjZXMubGVuZ3RoIDw9IDQgJiYgc29ydGVkVGFyZ2V0cy5sZW5ndGggPD0gNCkge1xuICAgICAgZHluYW1pY05vZGVQYWRkaW5nID0gTWF0aC5tYXgoOCwgbm9kZVBhZGRpbmcgLyAyKTtcbiAgICB9XG5cbiAgICAvLyBTYW5rZXkgbGF5b3V0XG4gICAgY29uc3Qgc2Fua2V5R2VuZXJhdG9yID0gc2Fua2V5PGFueSwgYW55PigpXG4gICAgICAubm9kZUlkKChkOiBhbnkpID0+IGQuaWQpXG4gICAgICAubm9kZVdpZHRoKDEyKVxuICAgICAgLm5vZGVQYWRkaW5nKGR5bmFtaWNOb2RlUGFkZGluZylcbiAgICAgIC5leHRlbnQoW1swLCAwXSwgW2NoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0XV0pO1xuXG4gICAgY29uc3Qgc2Fua2V5RGF0YSA9IHNhbmtleUdlbmVyYXRvcih7XG4gICAgICBub2Rlczogbm9kZXMubWFwKChkKSA9PiAoeyAuLi5kIH0pKSxcbiAgICAgIGxpbmtzOiBsaW5rcy5tYXAoKGQpID0+ICh7IC4uLmQgfSkpLFxuICAgIH0pO1xuXG4gICAgLy8gLS0tIEZPUkNFIFJPVyBBTElHTk1FTlQgSUYgTk9ERSBTRVRTIE1BVENIIC0tLVxuICAgIC8vIElmIGxlZnQgYW5kIHJpZ2h0IG5vZGUgc2V0cyBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhbmQgb3JkZXIsIGFsaWduIHRoZWlyIHkwL3kxXG4gICAgY29uc3QgbGVmdE5vZGVzID0gc2Fua2V5RGF0YS5ub2Rlcy5maWx0ZXIoKG46IGFueSkgPT4gbi5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSk7XG4gICAgY29uc3QgcmlnaHROb2RlcyA9IHNhbmtleURhdGEubm9kZXMuZmlsdGVyKChuOiBhbnkpID0+IG4uY2F0ZWdvcnkgPT09IGN1cnJlbnRUYXJnZXQpO1xuICAgIGlmIChcbiAgICAgIGxlZnROb2Rlcy5sZW5ndGggPT09IHJpZ2h0Tm9kZXMubGVuZ3RoICYmXG4gICAgICBsZWZ0Tm9kZXMuZXZlcnkoKG4sIGkpID0+IHJpZ2h0Tm9kZXNbaV0gJiYgbi5uYW1lID09PSByaWdodE5vZGVzW2ldLm5hbWUpXG4gICAgKSB7XG4gICAgICAvLyBGb3JjZSB5MC95MSBvZiByaWdodCBub2RlcyB0byBtYXRjaCBsZWZ0IG5vZGVzXG4gICAgICByaWdodE5vZGVzLmZvckVhY2goKG4sIGkpID0+IHtcbiAgICAgICAgbi55MCA9IGxlZnROb2Rlc1tpXS55MDtcbiAgICAgICAgbi55MSA9IGxlZnROb2Rlc1tpXS55MTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIC0tLSBWSVNVQUwgR1VJREVTOiBSZW5kZXIgaG9yaXpvbnRhbCBiYW5kcyBmb3IgZWFjaCByb3cgLS0tXG4gICAgc3ZnLnNlbGVjdEFsbCgncmVjdC5yb3ctZ3VpZGUnKVxuICAgICAgLmRhdGEobGVmdE5vZGVzKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ3Jvdy1ndWlkZScpXG4gICAgICAuYXR0cigneCcsIC1tYXJnaW4ubGVmdClcbiAgICAgIC5hdHRyKCd5JywgKGQ6IGFueSkgPT4gZC55MClcbiAgICAgIC5hdHRyKCd3aWR0aCcsIGNoYXJ0V2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCAoZDogYW55KSA9PiBkLnkxIC0gZC55MClcbiAgICAgIC5hdHRyKCdmaWxsJywgKGQsIGkpID0+XG4gICAgICAgIHNldHRpbmdzLmlzRGFya01vZGVcbiAgICAgICAgICA/IChpICUgMiA9PT0gMCA/ICcjMjMyNDJhJyA6ICcjMTgxOTFkJykgLy8gc3VidGxlIGRhcmsgYmFuZHNcbiAgICAgICAgICA6IChpICUgMiA9PT0gMCA/ICcjZjVmN2ZhJyA6ICcjZTllZWY1JylcbiAgICAgIClcbiAgICAgIC5hdHRyKCdvcGFjaXR5Jywgc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuNSA6IDAuMjUpXG4gICAgICAubG93ZXIoKTtcblxuICAgIC8vIENvbXB1dGUgdmVydGljYWwgb2Zmc2V0IHRvIGNlbnRlciB0aGUgZGlhZ3JhbVxuICAgIGNvbnN0IG5vZGVZcyA9IHNhbmtleURhdGEubm9kZXMubWFwKChkOiBhbnkpID0+IFtkLnkwLCBkLnkxXSkuZmxhdCgpO1xuICAgIGNvbnN0IG1pblkgPSBNYXRoLm1pbiguLi5ub2RlWXMpO1xuICAgIGNvbnN0IG1heFkgPSBNYXRoLm1heCguLi5ub2RlWXMpO1xuICAgIGNvbnN0IHVzZWRIZWlnaHQgPSBtYXhZIC0gbWluWTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5tYXgoMCwgKGNoYXJ0SGVpZ2h0IC0gdXNlZEhlaWdodCkgLyAyIC0gbWluWSk7XG5cbiAgICAvLyBDcmVhdGUgYSBncm91cCBmb3IgdGhlIGNoYXJ0IGFyZWEgd2l0aCBtYXJnaW4gdHJhbnNsYXRpb24gYW5kIHZlcnRpY2FsIGNlbnRlcmluZ1xuICAgIGNvbnN0IGcgPSBzdmcuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwke21hcmdpbi50b3AgKyBvZmZzZXRZfSlgKTtcblxuICAgIGxldCBkZWZzID0gc3ZnLnNlbGVjdDxTVkdEZWZzRWxlbWVudD4oJ2RlZnMnKTtcbiAgICBpZiAoZGVmcy5lbXB0eSgpKSBkZWZzID0gc3ZnLmFwcGVuZCgnZGVmcycpIGFzIGQzLlNlbGVjdGlvbjxTVkdEZWZzRWxlbWVudCwgdW5rbm93biwgbnVsbCwgdW5kZWZpbmVkPjtcbiAgICBsZXQgbGlua3NHID0gZy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdsaW5rcycpO1xuICAgIGxldCBub2Rlc0cgPSBnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ25vZGVzJyk7XG5cbiAgICAvLyBSZW1vdmUgb2xkIGdyYWRpZW50cyAobm8gbG9uZ2VyIG5lZWRlZClcbiAgICBkZWZzLnNlbGVjdEFsbCgnbGluZWFyR3JhZGllbnQubGluay1ncmFkaWVudCcpLnJlbW92ZSgpO1xuXG4gICAgLy8gLS0tIEFkZCBjbGlwUGF0aCBmb3IgbGlua3MgZ3JvdXAgd2l0aCB0aWdodGVyIGJvdW5kcyAtLS1cbiAgICBzdmcuc2VsZWN0KCdkZWZzJykuc2VsZWN0QWxsKCcjbGluay1jbGlwJykucmVtb3ZlKCk7XG4gICAgZGVmcy5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgIC5hdHRyKCdpZCcsICdsaW5rLWNsaXAnKVxuICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0KVxuICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wKVxuICAgICAgLmF0dHIoJ3dpZHRoJywgY2hhcnRXaWR0aClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBjaGFydEhlaWdodCk7XG4gICAgbGlua3NHLmF0dHIoJ2NsaXAtcGF0aCcsICd1cmwoI2xpbmstY2xpcCknKTtcblxuICAgIC8vIEFkZCBnbG93IGZpbHRlciBmb3IgZGFyayBtb2RlXG4gICAgZGVmcy5zZWxlY3RBbGwoJyNkYXJrLW1vZGUtZ2xvdycpLnJlbW92ZSgpO1xuICAgIGlmIChzZXR0aW5ncy5pc0RhcmtNb2RlKSB7XG4gICAgICBjb25zdCBnbG93RmlsdGVyID0gZGVmcy5hcHBlbmQoJ2ZpbHRlcicpXG4gICAgICAgIC5hdHRyKCdpZCcsICdkYXJrLW1vZGUtZ2xvdycpXG4gICAgICAgIC5hdHRyKCd4JywgJy01MCUnKVxuICAgICAgICAuYXR0cigneScsICctNTAlJylcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgJzIwMCUnKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgJzIwMCUnKTtcbiAgICAgIFxuICAgICAgZ2xvd0ZpbHRlci5hcHBlbmQoJ2ZlR2F1c3NpYW5CbHVyJylcbiAgICAgICAgLmF0dHIoJ3N0ZERldmlhdGlvbicsICcxLjUnKVxuICAgICAgICAuYXR0cigncmVzdWx0JywgJ2NvbG9yZWRCbHVyJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZlTWVyZ2UgPSBnbG93RmlsdGVyLmFwcGVuZCgnZmVNZXJnZScpO1xuICAgICAgZmVNZXJnZS5hcHBlbmQoJ2ZlTWVyZ2VOb2RlJykuYXR0cignaW4nLCAnY29sb3JlZEJsdXInKTtcbiAgICAgIGZlTWVyZ2UuYXBwZW5kKCdmZU1lcmdlTm9kZScpLmF0dHIoJ2luJywgJ1NvdXJjZUdyYXBoaWMnKTtcbiAgICB9XG5cbiAgICAvLyAtLS0gTGlua3MgdXBkYXRlIHBhdHRlcm4gLS0tXG4gICAgLy8gQWxsIGxpbmtzIGFyZSBub3cgYmV0d2VlbiByZWFsIG5vZGVzLCB3aXRoIGlzRHVtbXkgcHJvcGVydHkgZm9yIHZpc3VhbCBkaXN0aW5jdGlvblxuICAgIGNvbnN0IGZpbHRlcmVkTGlua3MgPSBzYW5rZXlEYXRhLmxpbmtzO1xuICAgIC8vIFJlbW92ZSBtaXgtYmxlbmQtbW9kZSBpbiBkYXJrIG1vZGUgdG8gcHJldmVudCBjb2xvciB3YXNoaW5nIG91dFxuICAgIGxpbmtzRy5zdHlsZSgnbWl4LWJsZW5kLW1vZGUnLCBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ25vcm1hbCcgOiAnbXVsdGlwbHknKTtcbiAgICBjb25zdCBsaW5rS2V5ID0gKGQ6IGFueSkgPT4gYCR7ZC5zb3VyY2UuaWR94oaSJHtkLnRhcmdldC5pZH1gO1xuICAgIGNvbnN0IGxpbmtTZWwgPSBsaW5rc0cuc2VsZWN0QWxsKCdwYXRoJylcbiAgICAgIC5kYXRhKGZpbHRlcmVkTGlua3MsIGxpbmtLZXkpO1xuXG4gICAgLy8gRVhJVDogZmFkZSBvdXQgYW5kIHJlbW92ZSBhbGwgb2xkIGxpbmtzXG4gICAgbGlua1NlbC5leGl0KClcbiAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24oNDAwKVxuICAgICAgLmF0dHIoJ29wYWNpdHknLCAwKVxuICAgICAgLnJlbW92ZSgpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGNhdGVnb3J5IGNoYW5nZSB0aGF0IHNob3VsZCB0cmlnZ2VyIGFuaW1hdGlvblxuICAgIGNvbnN0IGlzQ2F0ZWdvcnlDaGFuZ2UgPSBsYXN0Q2F0ZWdvcnlDaGFuZ2Uuc291cmNlICE9PSBjdXJyZW50U291cmNlIHx8IGxhc3RDYXRlZ29yeUNoYW5nZS50YXJnZXQgIT09IGN1cnJlbnRUYXJnZXQ7XG5cbiAgICAvLyBFTlRFUjogZHJhdyBpbiBhbGwgbmV3IGxpbmtzIHdpdGggaW1wcm92ZWQgYW5pbWF0aW9uXG4gICAgY29uc3QgbmV3TGlua3MgPSBsaW5rc0cuc2VsZWN0QWxsKCdwYXRoJylcbiAgICAgIC5kYXRhKGZpbHRlcmVkTGlua3MsIGxpbmtLZXkpXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAuYXR0cignZCcsIGNsYW1wZWRTYW5rZXlMaW5rSG9yaXpvbnRhbCgpKVxuICAgICAgLmF0dHIoJ3N0cm9rZScsIChkOiBhbnkpID0+IGdldE5vZGVDb2xvcihkLnNvdXJjZSwgZ2V0Q3VycmVudFRoZW1lQ29sb3JzKCksIHNldHRpbmdzLmlzRGFya01vZGUpKVxuICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIChkOiBhbnkpID0+IE1hdGgubWluKE1hdGgubWF4KHNldHRpbmdzLmlzRGFya01vZGUgPyAyIDogMSwgZC53aWR0aCksIG1heExpbmtXaWR0aCkpXG4gICAgICAuYXR0cignZmlsbCcsICdub25lJylcbiAgICAgIC5hdHRyKCdmaWx0ZXInLCAoZDogYW55KSA9PiB7XG4gICAgICAgIGlmIChob3ZlcmVkTGluayA9PT0gZCkgcmV0dXJuICd1cmwoI2dsb3cpJztcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAndXJsKCNkYXJrLW1vZGUtZ2xvdyknIDogbnVsbDtcbiAgICAgIH0pXG4gICAgICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnYWxsJylcbiAgICAgIC5hdHRyKCdzdHJva2UtbGluZWNhcCcsICdyb3VuZCcpXG4gICAgICAuYXR0cignb3BhY2l0eScsIChkOiBhbnkpID0+IHtcbiAgICAgICAgLy8gRHVtbXkgbGlua3M6IHZlcnkgbG93IG9wYWNpdHlcbiAgICAgICAgaWYgKGQuaXNEdW1teSkgcmV0dXJuIDAuMDg7XG4gICAgICAgIC8vIEFkanVzdCBvcGFjaXR5IGJhc2VkIG9uIGRhcmsgbW9kZSBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgY29uc3QgYmFzZU9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMC44NSA6IDAuNDtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0T3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAxLjAgOiAwLjk7XG4gICAgICAgIGNvbnN0IGRpbU9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMC40IDogMC4xO1xuICAgICAgICAvLyBEZWZhdWx0IG9wYWNpdHkgd2hlbiBubyBoaWdobGlnaHRpbmdcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlICE9PSAnaGlnaGxpZ2h0aW5nJykgcmV0dXJuIGJhc2VPcGFjaXR5O1xuICAgICAgICAvLyBIaWdobGlnaHQgbGlua3MgZnJvbSB0aGUgYWN0aXZlIHNvdXJjZVxuICAgICAgICBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgaG92ZXJlZFNvdXJjZSA9IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XTtcbiAgICAgICAgICByZXR1cm4gZC5zb3VyY2UubmFtZSA9PT0gaG92ZXJlZFNvdXJjZSA/IGhpZ2hsaWdodE9wYWNpdHkgOiBkaW1PcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIEhpZ2hsaWdodCBsaW5rcyB0byB0aGUgYWN0aXZlIHRhcmdldFxuICAgICAgICBpZiAoaG92ZXJlZFRhcmdldEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgaG92ZXJlZFRhcmdldCA9IHNvcnRlZFRhcmdldHNbaG92ZXJlZFRhcmdldEluZGV4XTtcbiAgICAgICAgICByZXR1cm4gZC50YXJnZXQubmFtZSA9PT0gaG92ZXJlZFRhcmdldCA/IGhpZ2hsaWdodE9wYWNpdHkgOiBkaW1PcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlT3BhY2l0eTtcbiAgICAgIH0pXG4gICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsIChkOiBhbnkpID0+IGQuaXNEdW1teSA/ICc0LDQnIDogbnVsbCk7IC8vIERhc2hlZCBmb3IgZHVtbXkgbGlua3NcblxuICAgIC8vIEFwcGx5IGRyYXdpbmcgYW5pbWF0aW9uIG9ubHkgb24gY2F0ZWdvcnkgY2hhbmdlcyB0byBwcmV2ZW50IGZsaWNrZXJpbmdcbiAgICBpZiAoaXNDYXRlZ29yeUNoYW5nZSkge1xuICAgICAgbmV3TGlua3MuZWFjaChmdW5jdGlvbiAoZDogYW55KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gKHRoaXMgYXMgU1ZHUGF0aEVsZW1lbnQpLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCB3aXRoIGludmlzaWJsZSBwYXRoXG4gICAgICAgIHBhdGhcbiAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsIHRvdGFsTGVuZ3RoKVxuICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaG9mZnNldCcsIHRvdGFsTGVuZ3RoKVxuICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMClcbiAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgLmRlbGF5KChkOiBhbnksIGk6IG51bWJlcikgPT4gaSAqIDI1KSAvLyBSZWR1Y2VkIHN0YWdnZXIgZGVsYXlcbiAgICAgICAgICAuZHVyYXRpb24oNjAwKSAvLyBSZWR1Y2VkIGZyb20gMTIwMG1zIHRvIDYwMG1zXG4gICAgICAgICAgLmVhc2UoZDMuZWFzZUN1YmljSW5PdXQpXG4gICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAoZDogYW55KSA9PiB7XG4gICAgICAgICAgICAvLyBBZGp1c3Qgb3BhY2l0eSBiYXNlZCBvbiBkYXJrIG1vZGUgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgICAgICAgICBjb25zdCBiYXNlT3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjg1IDogMC40O1xuICAgICAgICAgICAgY29uc3QgaGlnaGxpZ2h0T3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAxLjAgOiAwLjk7XG4gICAgICAgICAgICBjb25zdCBkaW1PcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuNCA6IDAuMTtcblxuICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IGxpbmtzIGZyb20gdGhlIGFjdGl2ZSBzb3VyY2Ugb3IgdG8gdGhlIGFjdGl2ZSB0YXJnZXRcbiAgICAgICAgICAgIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRTb3VyY2UgPSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF07XG4gICAgICAgICAgICAgIHJldHVybiBkLnNvdXJjZS5uYW1lID09PSBob3ZlcmVkU291cmNlID8gaGlnaGxpZ2h0T3BhY2l0eSA6IGRpbU9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaG92ZXJlZFRhcmdldEluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgICAgICBjb25zdCBob3ZlcmVkVGFyZ2V0ID0gc29ydGVkVGFyZ2V0c1tob3ZlcmVkVGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgICByZXR1cm4gZC50YXJnZXQubmFtZSA9PT0gaG92ZXJlZFRhcmdldCA/IGhpZ2hsaWdodE9wYWNpdHkgOiBkaW1PcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhc2VPcGFjaXR5O1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNob2Zmc2V0JywgMClcbiAgICAgICAgICAub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWxpbmVjYXAnLCAnYnV0dCcpIC8vIGNyaXNwIGVkZ2UgYWZ0ZXIgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgbnVsbClcbiAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNob2Zmc2V0JywgbnVsbCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIG5vbi1jYXRlZ29yeSBjaGFuZ2VzLCBqdXN0IHNldCB0aGUgb3BhY2l0eSBkaXJlY3RseVxuICAgICAgbmV3TGlua3MuYXR0cignb3BhY2l0eScsIChkOiBhbnkpID0+IHtcbiAgICAgICAgLy8gQWRqdXN0IG9wYWNpdHkgYmFzZWQgb24gZGFyayBtb2RlIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICBjb25zdCBiYXNlT3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjg1IDogMC40O1xuICAgICAgICBjb25zdCBoaWdobGlnaHRPcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDEuMCA6IDAuOTtcbiAgICAgICAgY29uc3QgZGltT3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjQgOiAwLjE7XG5cbiAgICAgICAgLy8gSGlnaGxpZ2h0IGxpbmtzIGZyb20gdGhlIGFjdGl2ZSBzb3VyY2Ugb3IgdG8gdGhlIGFjdGl2ZSB0YXJnZXRcbiAgICAgICAgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBjb25zdCBob3ZlcmVkU291cmNlID0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdO1xuICAgICAgICAgIHJldHVybiBkLnNvdXJjZS5uYW1lID09PSBob3ZlcmVkU291cmNlID8gaGlnaGxpZ2h0T3BhY2l0eSA6IGRpbU9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvdmVyZWRUYXJnZXRJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBjb25zdCBob3ZlcmVkVGFyZ2V0ID0gc29ydGVkVGFyZ2V0c1tob3ZlcmVkVGFyZ2V0SW5kZXhdO1xuICAgICAgICAgIHJldHVybiBkLnRhcmdldC5uYW1lID09PSBob3ZlcmVkVGFyZ2V0ID8gaGlnaGxpZ2h0T3BhY2l0eSA6IGRpbU9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VPcGFjaXR5O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGhvdmVyIGludGVyYWN0aW9uc1xuICAgIG5ld0xpbmtzXG4gICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldmVudDogYW55LCBkOiBhbnkpIHtcbiAgICAgICAgc2V0SG92ZXJlZExpbmsoZCk7XG4gICAgICAgIHNldFRvb2x0aXAoe1xuICAgICAgICAgIHg6IGV2ZW50Lm9mZnNldFgsXG4gICAgICAgICAgeTogZXZlbnQub2Zmc2V0WSxcbiAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvbnQtYm9sZFwiPntkLnNvdXJjZS5uYW1lfSDihpIge2QudGFyZ2V0Lm5hbWV9PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXY+e2QudmFsdWV9IGF0dGVuZGVlczwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRIb3ZlcmVkTGluayhudWxsKTtcbiAgICAgICAgc2V0VG9vbHRpcChudWxsKTtcbiAgICAgIH0pO1xuXG4gICAgLy8gLS0tIE5vZGVzIHVwZGF0ZSBwYXR0ZXJuIChyZWN0cykgLS0tXG5cblxuICAgIGNvbnN0IGZpbHRlcmVkTm9kZXMgPSBzYW5rZXlEYXRhLm5vZGVzO1xuICAgIGNvbnN0IG5vZGVTZWwgPSBub2Rlc0cuc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgIC5kYXRhKGZpbHRlcmVkTm9kZXMsIChkOiBhbnkpID0+IGQuaWQpO1xuICAgIG5vZGVTZWwuZXhpdCgpLnJlbW92ZSgpO1xuICAgIG5vZGVTZWwuam9pbihcbiAgICAgIGVudGVyID0+IGVudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKCd4JywgKGQ6IGFueSkgPT4gZC54MClcbiAgICAgICAgLmF0dHIoJ3knLCAoZDogYW55KSA9PiBkLnkwKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQ6IGFueSkgPT4gZC55MSAtIGQueTApXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkOiBhbnkpID0+IGQueDEgLSBkLngwKVxuICAgICAgICAuYXR0cignZmlsbCcsIChkOiBhbnkpID0+IGdldE5vZGVDb2xvcihkLCBnZXRDdXJyZW50VGhlbWVDb2xvcnMoKSwgc2V0dGluZ3MuaXNEYXJrTW9kZSkpXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJyM0NDQnIDogJyMyMjIyM2InKVxuICAgICAgICAuYXR0cignb3BhY2l0eScsIChkOiBhbnkpID0+IHtcbiAgICAgICAgICAvLyBTb3VyY2Ugbm9kZXM6IG9ubHkgdGhlIGhpZ2hsaWdodGVkIG9uZSBpcyBicmlnaHRcbiAgICAgICAgICBpZiAoZC5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdID8gMSA6IDAuMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjk7IC8vIEluY3JlYXNlZCBmcm9tIDAuNiB0byAwLjkgZm9yIG1vcmUgcHJvbWluZW5jZVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUYXJnZXQgbm9kZXM6IG9ubHkgdGhvc2UgY29ubmVjdGVkIHRvIHRoZSBoaWdobGlnaHRlZCBzb3VyY2Ugb3IgaG92ZXJlZCB0YXJnZXQgYXJlIGJyaWdodFxuICAgICAgICAgIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBob3ZlcmVkU291cmNlID0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBmaWx0ZXJlZExpbmtzLnNvbWUobCA9PiBsLnNvdXJjZS5uYW1lID09PSBob3ZlcmVkU291cmNlICYmIGwudGFyZ2V0Lm5hbWUgPT09IGQubmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gaXNDb25uZWN0ZWQgPyAxIDogMC4zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaG92ZXJlZFRhcmdldEluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZFRhcmdldCA9IHNvcnRlZFRhcmdldHNbaG92ZXJlZFRhcmdldEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGhvdmVyZWRUYXJnZXQgPyAxIDogMC4zO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMC45OyAvLyBJbmNyZWFzZWQgZnJvbSAwLjYgdG8gMC45IGZvciBtb3JlIHByb21pbmVuY2VcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQ6IGFueSwgZDogYW55KSB7XG4gICAgICAgICAgc2V0SG92ZXJlZE5vZGUoZCk7XG4gICAgICAgICAgc2V0VG9vbHRpcCh7XG4gICAgICAgICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgICAgICAgeTogZXZlbnQub2Zmc2V0WSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IChcbiAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvbnQtYm9sZFwiPntkLm5hbWV9PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdj5DYXRlZ29yeToge2QuY2F0ZWdvcnl9PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdj5SZXNwb25zZXM6IHtkLnZhbHVlfTwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZXRIb3ZlcmVkTm9kZShudWxsKTtcbiAgICAgICAgICBzZXRUb29sdGlwKG51bGwpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoZXZlbnQ6IGFueSwgZDogYW55KSB7XG4gICAgICAgICAgaWYgKGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHNvcnRlZFNvdXJjZXMuaW5kZXhPZihkLm5hbWUpO1xuICAgICAgICAgICAgc2V0SG92ZXJlZFNvdXJjZUluZGV4KGlkeCk7XG4gICAgICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnaGlnaGxpZ2h0aW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkLmNhdGVnb3J5ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBzb3J0ZWRUYXJnZXRzLmluZGV4T2YoZC5uYW1lKTtcbiAgICAgICAgICAgIHNldEhvdmVyZWRUYXJnZXRJbmRleChpZHgpO1xuICAgICAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKGV2ZW50OiBhbnksIGQ6IGFueSkge1xuICAgICAgICAgIGlmIChkLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlKSB7XG4gICAgICAgICAgICBzZXRIb3ZlcmVkU291cmNlSW5kZXgobnVsbCk7XG4gICAgICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZC5jYXRlZ29yeSA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgc2V0SG92ZXJlZFRhcmdldEluZGV4KG51bGwpO1xuICAgICAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgdXBkYXRlID0+IHVwZGF0ZVxuICAgICAgICAudHJhbnNpdGlvbihkMy50cmFuc2l0aW9uKCkuZHVyYXRpb24oNzUwKS5lYXNlKGQzLmVhc2VDdWJpY0luT3V0KSlcbiAgICAgICAgLmF0dHIoJ3gnLCAoZDogYW55KSA9PiBkLngwKVxuICAgICAgICAuYXR0cigneScsIChkOiBhbnkpID0+IGQueTApXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoZDogYW55KSA9PiBkLnkxIC0gZC55MClcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQ6IGFueSkgPT4gZC54MSAtIGQueDApXG4gICAgICAgIC5hdHRyKCdmaWxsJywgKGQ6IGFueSkgPT4gZ2V0Tm9kZUNvbG9yKGQsIGdldEN1cnJlbnRUaGVtZUNvbG9ycygpLCBzZXR0aW5ncy5pc0RhcmtNb2RlKSlcbiAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAoZDogYW55KSA9PiB7XG4gICAgICAgICAgLy8gU291cmNlIG5vZGVzOiBvbmx5IHRoZSBoaWdobGlnaHRlZCBvbmUgaXMgYnJpZ2h0XG4gICAgICAgICAgaWYgKGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XSA/IDEgOiAwLjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC45OyAvLyBJbmNyZWFzZWQgZnJvbSAwLjYgdG8gMC45IGZvciBtb3JlIHByb21pbmVuY2VcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGFyZ2V0IG5vZGVzOiBvbmx5IHRob3NlIGNvbm5lY3RlZCB0byB0aGUgaGlnaGxpZ2h0ZWQgc291cmNlIG9yIGhvdmVyZWQgdGFyZ2V0IGFyZSBicmlnaHRcbiAgICAgICAgICBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZFNvdXJjZSA9IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gZmlsdGVyZWRMaW5rcy5zb21lKGwgPT4gbC5zb3VyY2UubmFtZSA9PT0gaG92ZXJlZFNvdXJjZSAmJiBsLnRhcmdldC5uYW1lID09PSBkLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkID8gMSA6IDAuMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhvdmVyZWRUYXJnZXRJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRUYXJnZXQgPSBzb3J0ZWRUYXJnZXRzW2hvdmVyZWRUYXJnZXRJbmRleF07XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBob3ZlcmVkVGFyZ2V0ID8gMSA6IDAuMztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDAuOTsgLy8gSW5jcmVhc2VkIGZyb20gMC42IHRvIDAuOSBmb3IgbW9yZSBwcm9taW5lbmNlXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIC0tLSBOb2RlIGxhYmVscyAocmUtcmVuZGVyIGFzIGJlZm9yZSkgLS0tXG4gICAgZy5zZWxlY3RBbGwoJ2cubGFiZWwtbGF5ZXInKS5yZW1vdmUoKTtcbiAgICBjb25zdCBsYWJlbExheWVyID0gZy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdsYWJlbC1sYXllcicpO1xuICAgIGNvbnN0IHNvdXJjZU5vZGVTZXQgPSBuZXcgU2V0KHNvcnRlZFNvdXJjZXMpO1xuICAgIGNvbnN0IHRhcmdldE5vZGVTZXQgPSBuZXcgU2V0KHNvcnRlZFRhcmdldHMpO1xuICAgIGNvbnN0IHNvdXJjZU5vZGVzID0gc2Fua2V5RGF0YS5ub2Rlcy5maWx0ZXIoZCA9PiBkLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlKTtcbiAgICBjb25zdCB0YXJnZXROb2RlcyA9IHNhbmtleURhdGEubm9kZXMuZmlsdGVyKGQgPT4gZC5jYXRlZ29yeSA9PT0gY3VycmVudFRhcmdldCk7XG4gICAgc291cmNlTm9kZXMuZm9yRWFjaCgobm9kZTogYW55KSA9PiB7XG4gICAgICBpZiAoc291cmNlTm9kZVNldC5oYXMobm9kZS5uYW1lKSkge1xuICAgICAgICBsYWJlbExheWVyXG4gICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgLmF0dHIoJ3gnLCAtbGFiZWxQYWRkaW5nKVxuICAgICAgICAgIC5hdHRyKCd5JywgKG5vZGUueTAgKyBub2RlLnkxKSAvIDIpXG4gICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgLmF0dHIoJ2FsaWdubWVudC1iYXNlbGluZScsICdtaWRkbGUnKVxuICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsIG5vZGVMYWJlbEZvbnRGYW1pbHkpXG4gICAgICAgICAgLmF0dHIoJ2ZvbnQtd2VpZ2h0Jywgbm9kZUxhYmVsRm9udFdlaWdodClcbiAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgbGFiZWxGb250U2l6ZSlcbiAgICAgICAgICAuYXR0cignZmlsbCcsIG5vZGVMYWJlbENvbG9yKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWxhYmVsJywgbm9kZS5uYW1lKVxuICAgICAgICAgIC5hdHRyKCdvcGFjaXR5Jywgbm9kZS52YWx1ZSA9PT0gMCA/IDAuNSA6IDEpXG4gICAgICAgICAgLnRleHQobm9kZS5uYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YXJnZXROb2Rlcy5mb3JFYWNoKChub2RlOiBhbnkpID0+IHtcbiAgICAgIGlmICh0YXJnZXROb2RlU2V0Lmhhcyhub2RlLm5hbWUpKSB7XG4gICAgICAgIGxhYmVsTGF5ZXJcbiAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAuYXR0cigneCcsIGNoYXJ0V2lkdGggKyBsYWJlbFBhZGRpbmcpXG4gICAgICAgICAgLmF0dHIoJ3knLCAobm9kZS55MCArIG5vZGUueTEpIC8gMilcbiAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnc3RhcnQnKVxuICAgICAgICAgIC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcbiAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCBub2RlTGFiZWxGb250RmFtaWx5KVxuICAgICAgICAgIC5hdHRyKCdmb250LXdlaWdodCcsIG5vZGVMYWJlbEZvbnRXZWlnaHQpXG4gICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGxhYmVsRm9udFNpemUpXG4gICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBub2RlTGFiZWxDb2xvcilcbiAgICAgICAgICAuYXR0cignYXJpYS1sYWJlbCcsIG5vZGUubmFtZSlcbiAgICAgICAgICAuYXR0cignb3BhY2l0eScsIG5vZGUudmFsdWUgPT09IDAgPyAwLjUgOiAxKVxuICAgICAgICAgIC50ZXh0KG5vZGUubmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyA2LiBVcGRhdGUgaW5zaWdodHNcbiAgICBsZXQgbW9zdENvbW1vbjogdHlwZW9mIGxpbmtzWzBdIHwgdW5kZWZpbmVkID0gbGlua3MubGVuZ3RoID4gMCA/IGxpbmtzLnJlZHVjZSgoYSwgYikgPT4gKGIudmFsdWUgPiBhLnZhbHVlID8gYiA6IGEpLCBsaW5rc1swXSkgOiB1bmRlZmluZWQ7XG4gICAgc2V0SW5zaWdodHMoW1xuICAgICAgeyB0aXRsZTogJ1RvdGFsIFJlc3BvbnNlcycsIHZhbHVlOiBkYXRhLmxlbmd0aCB9LFxuICAgICAgeyB0aXRsZTogJ0N1cnJlbnQgVmlldycsIHZhbHVlOiBgJHtjdXJyZW50U291cmNlfSDihpIgJHtjdXJyZW50VGFyZ2V0fWAgfSxcbiAgICAgIG1vc3RDb21tb25cbiAgICAgICAgPyB7IHRpdGxlOiAnTW9zdCBDb21tb24gRmxvdycsIHZhbHVlOiBgJHttb3N0Q29tbW9uLnNvdXJjZS5zcGxpdCgnOicpWzFdfSDihpIgJHttb3N0Q29tbW9uLnRhcmdldC5zcGxpdCgnOicpWzFdfWAsIGRlc2NyaXB0aW9uOiBgJHttb3N0Q29tbW9uLnZhbHVlfSBhdHRlbmRlZXNgIH1cbiAgICAgICAgOiB7IHRpdGxlOiAnTW9zdCBDb21tb24gRmxvdycsIHZhbHVlOiAnTi9BJywgZGVzY3JpcHRpb246ICcnIH0sXG4gICAgXSk7XG5cbiAgICAvLyA3LiBBdXRvbWF0aWMgYW5pbWF0aW9uIG9uIHF1ZXN0aW9uIGNoYW5nZSBvbmx5XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IGQzLnRyYW5zaXRpb24oKS5kdXJhdGlvbig3NTApLmVhc2UoZDMuZWFzZUN1YmljSW5PdXQpO1xuXG4gICAgLy8gQW5pbWF0ZSBub2Rlc1xuICAgIG5vZGVTZWxcbiAgICAgIC50cmFuc2l0aW9uKHRyYW5zaXRpb24pXG4gICAgICAuYXR0cigneCcsIChkOiBhbnkpID0+IGQueDApXG4gICAgICAuYXR0cigneScsIChkOiBhbnkpID0+IGQueTApXG4gICAgICAuYXR0cignaGVpZ2h0JywgKGQ6IGFueSkgPT4gZC55MSAtIGQueTApXG4gICAgICAuYXR0cignd2lkdGgnLCAoZDogYW55KSA9PiBkLngxIC0gZC54MClcbiAgICAgIC5hdHRyKCdmaWxsJywgKGQ6IGFueSkgPT4gZ2V0Tm9kZUNvbG9yKGQsIGdldEN1cnJlbnRUaGVtZUNvbG9ycygpLCBzZXR0aW5ncy5pc0RhcmtNb2RlKSk7XG5cbiAgfSwgW2ZpbHRlcmVkRGF0YSwgY3VycmVudFNvdXJjZSwgY3VycmVudFRhcmdldCwgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCwgc2V0dGluZ3MuY2F0ZWdvcnlDb2xvcnMsIHNldHRpbmdzLmlzRGFya01vZGUsIGxhc3RDYXRlZ29yeUNoYW5nZSwgZ2V0Q3VycmVudFRoZW1lQ29sb3JzXSk7XG5cbiAgLy8gQ3JlYXRlIHNvcnRlZCB0YXJnZXRzIGZvciBjb25zaXN0ZW50IGhpZ2hsaWdodGluZ1xuICBjb25zdCBzb3J0ZWRUYXJnZXRzRm9ySGlnaGxpZ2h0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc29ydGVkID0gWy4uLnRhcmdldHNdO1xuICAgIGlmIChjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgICAgc29ydGVkLnNvcnQoKGEsIGIpID0+IFlFQVJTX0NBVEVHT1JJRVMuaW5kZXhPZihhKSAtIFlFQVJTX0NBVEVHT1JJRVMuaW5kZXhPZihiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvcnRlZC5zb3J0KCk7XG4gICAgfVxuICAgIHJldHVybiBzb3J0ZWQ7XG4gIH0sIFt0YXJnZXRzLCBjdXJyZW50VGFyZ2V0XSk7XG5cbiAgLy8gU2VwYXJhdGUgZWZmZWN0IHRvIHVwZGF0ZSB2aXN1YWwgaGlnaGxpZ2h0aW5nIGR1cmluZyBhbmltYXRpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN2Z1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3Q8U1ZHU1ZHRWxlbWVudCwgdW5rbm93bj4oc3ZnUmVmLmN1cnJlbnQpO1xuICAgIGNvbnN0IGcgPSBzdmcuc2VsZWN0KCdnJyk7XG4gICAgXG4gICAgLy8gVXBkYXRlIG5vZGUgb3BhY2l0eSBiYXNlZCBvbiBhbmltYXRpb24gc3RhdGVcbiAgICBnLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMjAwKVxuICAgICAgLmF0dHIoJ29wYWNpdHknLCBmdW5jdGlvbihkOiBhbnkpIHtcbiAgICAgICAgLy8gU291cmNlIG5vZGVzOiBvbmx5IHRoZSBoaWdobGlnaHRlZCBvbmUgaXMgYnJpZ2h0XG4gICAgICAgIGlmIChkLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlKSB7XG4gICAgICAgICAgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XSA/IDEgOiAwLjI7IC8vIFNsaWdodGx5IGhpZ2hlciBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDAuOTsgLy8gSW5jcmVhc2VkIGZyb20gMC42IHRvIDAuOSBmb3IgbW9yZSBwcm9taW5lbmNlXG4gICAgICAgIH1cbiAgICAgICAgLy8gVGFyZ2V0IG5vZGVzOiBoaWdobGlnaHQgdGhvc2UgY29ubmVjdGVkIHRvIHRoZSBoaWdobGlnaHRlZCBzb3VyY2VcbiAgICAgICAgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBjb25zdCBob3ZlcmVkU291cmNlID0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdO1xuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgdGFyZ2V0IG5vZGUgaXMgY29ubmVjdGVkIHRvIHRoZSBoaWdobGlnaHRlZCBzb3VyY2VcbiAgICAgICAgICBjb25zdCBpc0Nvbm5lY3RlZCA9IHN2Zy5zZWxlY3RBbGwoJ3BhdGgnKS5kYXRhKCkuc29tZSgobGluazogYW55KSA9PiBcbiAgICAgICAgICAgIGxpbmsuc291cmNlLm5hbWUgPT09IGhvdmVyZWRTb3VyY2UgJiYgbGluay50YXJnZXQubmFtZSA9PT0gZC5uYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gaXNDb25uZWN0ZWQgPyAxIDogMC4yOyAvLyBTbGlnaHRseSBoaWdoZXIgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvdmVyZWRUYXJnZXRJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBjb25zdCBob3ZlcmVkVGFyZ2V0ID0gc29ydGVkVGFyZ2V0c0ZvckhpZ2hsaWdodFtob3ZlcmVkVGFyZ2V0SW5kZXhdO1xuICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGhvdmVyZWRUYXJnZXQgPyAxIDogMC4yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwLjk7IC8vIEluY3JlYXNlZCBmcm9tIDAuNiB0byAwLjkgZm9yIG1vcmUgcHJvbWluZW5jZVxuICAgICAgfSlcbiAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbihkOiBhbnkpIHtcbiAgICAgICAgLy8gQWRkIHRoaWNrZXIgc3Ryb2tlIHRvIGhpZ2hsaWdodGVkIHNvdXJjZSBub2RlXG4gICAgICAgIGlmIChkLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlICYmIGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF0gPyAzIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIGxpbmsgb3BhY2l0eSBiYXNlZCBvbiBhbmltYXRpb24gc3RhdGVcbiAgICBnLnNlbGVjdEFsbCgncGF0aCcpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMjAwKVxuICAgICAgLmF0dHIoJ29wYWNpdHknLCBmdW5jdGlvbihkOiBhbnkpIHtcbiAgICAgICAgLy8gQWRqdXN0IG9wYWNpdHkgYmFzZWQgb24gZGFyayBtb2RlIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICBjb25zdCBiYXNlT3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjg1IDogMC40O1xuICAgICAgICBjb25zdCBoaWdobGlnaHRPcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDEuMCA6IDAuOTU7XG4gICAgICAgIGNvbnN0IGRpbU9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMC4zNSA6IDAuMDU7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBvcGFjaXR5IHdoZW4gbm8gaGlnaGxpZ2h0aW5nXG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSAhPT0gJ2hpZ2hsaWdodGluZycpIHJldHVybiBiYXNlT3BhY2l0eTtcblxuICAgICAgICAvLyBIaWdobGlnaHQgbGlua3MgZnJvbSB0aGUgYWN0aXZlIHNvdXJjZVxuICAgICAgICBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgaG92ZXJlZFNvdXJjZSA9IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XTtcbiAgICAgICAgICByZXR1cm4gZC5zb3VyY2UubmFtZSA9PT0gaG92ZXJlZFNvdXJjZSA/IGhpZ2hsaWdodE9wYWNpdHkgOiBkaW1PcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGlnaGxpZ2h0IGxpbmtzIHRvIHRoZSBhY3RpdmUgdGFyZ2V0XG4gICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0SW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBob3ZlcmVkVGFyZ2V0ID0gc29ydGVkVGFyZ2V0c0ZvckhpZ2hsaWdodFtob3ZlcmVkVGFyZ2V0SW5kZXhdO1xuICAgICAgICAgIHJldHVybiBkLnRhcmdldC5uYW1lID09PSBob3ZlcmVkVGFyZ2V0ID8gaGlnaGxpZ2h0T3BhY2l0eSA6IGRpbU9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFzZU9wYWNpdHk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uKGQ6IGFueSkge1xuICAgICAgICAvLyBNYWtlIGhpZ2hsaWdodGVkIGxpbmtzIHRoaWNrZXJcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJyAmJiBob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBob3ZlcmVkU291cmNlID0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdO1xuICAgICAgICAgIHJldHVybiBkLnNvdXJjZS5uYW1lID09PSBob3ZlcmVkU291cmNlID8gTWF0aC5tYXgoMiwgZC53aWR0aCAqIDEuMikgOiBNYXRoLm1heCgxLCBkLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMSwgZC53aWR0aCk7XG4gICAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKCfwn46oIFZpc3VhbCBoaWdobGlnaHRpbmcgdXBkYXRlZDonLCB7XG4gICAgICBob3ZlcmVkU291cmNlSW5kZXgsXG4gICAgICBzb3VyY2VOYW1lOiBob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgPyBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF0gOiBudWxsLFxuICAgICAgaG92ZXJlZFRhcmdldEluZGV4LFxuICAgICAgdGFyZ2V0TmFtZTogaG92ZXJlZFRhcmdldEluZGV4ICE9PSBudWxsID8gc29ydGVkVGFyZ2V0c0ZvckhpZ2hsaWdodFtob3ZlcmVkVGFyZ2V0SW5kZXhdIDogbnVsbCxcbiAgICAgIGFuaW1hdGlvblBoYXNlXG4gICAgfSk7XG5cbiAgfSwgW2hvdmVyZWRTb3VyY2VJbmRleCwgaG92ZXJlZFRhcmdldEluZGV4LCBhbmltYXRpb25QaGFzZSwgc29ydGVkU291cmNlcywgc29ydGVkVGFyZ2V0c0ZvckhpZ2hsaWdodCwgY3VycmVudFNvdXJjZSwgY3VycmVudFRhcmdldF0pO1xuXG4gIC8vIFNlcGFyYXRlIGVmZmVjdCBmb3IgaG92ZXIgaW50ZXJhY3Rpb25zIChkb2Vzbid0IHJlLXJlbmRlciB0aGUgd2hvbGUgdmlzdWFsaXphdGlvbilcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN2Z1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3Q8U1ZHU1ZHRWxlbWVudCwgdW5rbm93bj4oc3ZnUmVmLmN1cnJlbnQpO1xuICAgIGNvbnN0IGcgPSBzdmcuc2VsZWN0KCdnJyk7XG4gICAgXG4gICAgLy8gVXBkYXRlIGxpbmsgaG92ZXIgZWZmZWN0c1xuICAgIGcuc2VsZWN0QWxsKCdwYXRoJylcbiAgICAgIC5lYWNoKGZ1bmN0aW9uKGQ6IGFueSkge1xuICAgICAgICBjb25zdCBwYXRoID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICBjb25zdCBpc0hvdmVyZWQgPSBob3ZlcmVkTGluayA9PT0gZDtcbiAgICAgICAgcGF0aC5hdHRyKCdmaWx0ZXInLCBpc0hvdmVyZWQgPyAndXJsKCNnbG93KScgOiBudWxsKTtcbiAgICAgIH0pO1xuXG4gIH0sIFtob3ZlcmVkTm9kZSwgaG92ZXJlZExpbmtdKTtcblxuICAvLyBUb29sdGlwIGZhZGVvdXQgbG9naWNcbiAgY29uc3QgW3Rvb2x0aXBWaXNpYmxlLCBzZXRUb29sdGlwVmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHRvb2x0aXBUaW1lb3V0UmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodG9vbHRpcCkge1xuICAgICAgc2V0VG9vbHRpcFZpc2libGUodHJ1ZSk7XG4gICAgICBpZiAodG9vbHRpcFRpbWVvdXRSZWYuY3VycmVudCkgY2xlYXJUaW1lb3V0KHRvb2x0aXBUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgdG9vbHRpcFRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRUb29sdGlwVmlzaWJsZShmYWxzZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0VG9vbHRpcChudWxsKSwgNDAwKTsgLy8gV2FpdCBmb3IgZmFkZW91dFxuICAgICAgfSwgNTAwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRvb2x0aXBWaXNpYmxlKGZhbHNlKTtcbiAgICAgIGlmICh0b29sdGlwVGltZW91dFJlZi5jdXJyZW50KSBjbGVhclRpbWVvdXQodG9vbHRpcFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodG9vbHRpcFRpbWVvdXRSZWYuY3VycmVudCkgY2xlYXJUaW1lb3V0KHRvb2x0aXBUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFt0b29sdGlwXSk7XG5cbiAgY29uc3QgdG9vbHRpcEVsID0gdG9vbHRpcCA/IChcbiAgICA8ZGl2XG4gICAgICBzdHlsZT17e1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgbGVmdDogdG9vbHRpcC54ICsgMTYsXG4gICAgICAgIHRvcDogdG9vbHRpcC55ICsgMTYsXG4gICAgICAgIGJhY2tncm91bmQ6IHNldHRpbmdzLmlzRGFya01vZGUgPyAncmdiYSgyMCwyMCwzMCwwLjk4KScgOiAncmdiYSgyNTUsMjU1LDI1NSwwLjk4KScsXG4gICAgICAgIGNvbG9yOiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJyNmZmYnIDogJyMxNzBGNUYnLFxuICAgICAgICBwYWRkaW5nOiAnOHB4IDEycHgnLFxuICAgICAgICBib3JkZXJSYWRpdXM6IDYsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgekluZGV4OiAxMDAsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdBdmVuaXIgTmV4dCBXb3JsZCwgc2Fucy1zZXJpZicsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICBib3hTaGFkb3c6IHNldHRpbmdzLmlzRGFya01vZGUgXG4gICAgICAgICAgPyAnMCA0cHggMjRweCAwIHJnYmEoMTYsIDE2LCAyMzUsIDAuMTIpJyBcbiAgICAgICAgICA6ICcwIDRweCAyNHB4IDAgcmdiYSgwLCAwLCAwLCAwLjE1KScsXG4gICAgICAgIGJvcmRlcjogc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICcxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjEpJyA6ICcxcHggc29saWQgcmdiYSgwLDAsMCwwLjEpJyxcbiAgICAgICAgbWF4V2lkdGg6IDI4MCxcbiAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICBvcGFjaXR5OiB0b29sdGlwVmlzaWJsZSA/IDEgOiAwLFxuICAgICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjRzJyxcbiAgICAgIH19XG4gICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICBhcmlhLWxpdmU9XCJwb2xpdGVcIlxuICAgID5cbiAgICAgIHt0b29sdGlwLmNvbnRlbnR9XG4gICAgPC9kaXY+XG4gICkgOiBudWxsO1xuXG4gIC8vIENyZWF0ZSBzb3J0ZWQgc291cmNlcyBhcnJheSBmb3IgaGlnaGxpZ2h0aW5nIChzYW1lIGFzIHJlbmRlcmluZyBhbmQgYW5pbWF0aW9uKVxuICBjb25zdCBzb3J0ZWRTb3VyY2VzRm9ySGlnaGxpZ2h0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHZpc3VhbE9yZGVyOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmIChmaWx0ZXJlZERhdGEubGVuZ3RoICYmIGNoYXJ0V2lkdGggPiAwICYmIGNoYXJ0SGVpZ2h0ID4gMCkge1xuICAgICAgY29uc3Qgc291cmNlc0Zvck5vZGVzID0gWy4uLnNvdXJjZXNdO1xuICBpZiAoY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycpIHtcbiAgICAgICAgc291cmNlc0Zvck5vZGVzLnNvcnQoKGEsIGIpID0+IFlFQVJTX0NBVEVHT1JJRVMuaW5kZXhPZihhKSAtIFlFQVJTX0NBVEVHT1JJRVMuaW5kZXhPZihiKSk7XG4gIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZXNGb3JOb2Rlcy5zb3J0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlcyA9IFtcbiAgICAgICAgLi4uc291cmNlc0Zvck5vZGVzLm1hcCgobmFtZSkgPT4gKHsgaWQ6IGAke2N1cnJlbnRTb3VyY2V9OiR7bmFtZX1gLCBuYW1lLCBjYXRlZ29yeTogY3VycmVudFNvdXJjZSB9KSksXG4gICAgICAgIC4uLnRhcmdldHMubWFwKChuYW1lKSA9PiAoeyBpZDogYCR7Y3VycmVudFRhcmdldH06JHtuYW1lfWAsIG5hbWUsIGNhdGVnb3J5OiBjdXJyZW50VGFyZ2V0IH0pKSxcbiAgICAgIF07XG4gICAgICBjb25zdCBsaW5rc01hcCA9IG5ldyBNYXA8c3RyaW5nLCB7IHNvdXJjZTogc3RyaW5nOyB0YXJnZXQ6IHN0cmluZzsgdmFsdWU6IG51bWJlciwgaXNEdW1teT86IGJvb2xlYW4gfT4oKTtcbiAgICAgIGZpbHRlcmVkRGF0YS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnID8gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSA6IChkIGFzIGFueSlbY3VycmVudFNvdXJjZV07XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnID8gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSA6IChkIGFzIGFueSlbY3VycmVudFRhcmdldF07XG4gICAgICAgIGNvbnN0IHNvdXJjZUlkID0gYCR7Y3VycmVudFNvdXJjZX06JHtzb3VyY2V9YDtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBgJHtjdXJyZW50VGFyZ2V0fToke3RhcmdldH1gO1xuICAgICAgICBpZiAoIXNvdXJjZXNGb3JOb2Rlcy5pbmNsdWRlcyhzb3VyY2UpIHx8ICF0YXJnZXRzLmluY2x1ZGVzKHRhcmdldCkpIHJldHVybjtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7c291cmNlSWR94oaSJHt0YXJnZXRJZH1gO1xuICAgICAgICBpZiAoIWxpbmtzTWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgbGlua3NNYXAuc2V0KGtleSwgeyBzb3VyY2U6IHNvdXJjZUlkLCB0YXJnZXQ6IHRhcmdldElkLCB2YWx1ZTogMCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsaW5rc01hcC5nZXQoa2V5KSEudmFsdWUgKz0gMTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbGlua3MgPSBBcnJheS5mcm9tKGxpbmtzTWFwLnZhbHVlcygpKTtcbiAgICAgIGNvbnN0IHNhbmtleUdlbmVyYXRvciA9IHNhbmtleTxhbnksIGFueT4oKVxuICAgICAgICAubm9kZUlkKChkOiBhbnkpID0+IGQuaWQpXG4gICAgICAgIC5ub2RlV2lkdGgoMTIpXG4gICAgICAgIC5ub2RlUGFkZGluZyhub2RlUGFkZGluZylcbiAgICAgICAgLmV4dGVudChbWzAsIDBdLCBbY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHRdXSk7XG4gICAgICBjb25zdCBzYW5rZXlEYXRhID0gc2Fua2V5R2VuZXJhdG9yKHtcbiAgICAgICAgbm9kZXM6IG5vZGVzLm1hcCgoZCkgPT4gKHsgLi4uZCB9KSksXG4gICAgICAgIGxpbmtzOiBsaW5rcy5tYXAoKGQpID0+ICh7IC4uLmQgfSkpLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBzb3VyY2VOb2RlcyA9IHNhbmtleURhdGEubm9kZXMuZmlsdGVyKChkOiBhbnkpID0+IGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpO1xuICAgICAgdmlzdWFsT3JkZXIgPSBzb3VyY2VOb2Rlc1xuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IGEueTAgLSBiLnkwKVxuICAgICAgICAubWFwKChkOiBhbnkpID0+IGQubmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB2aXN1YWxPcmRlci5sZW5ndGggPyB2aXN1YWxPcmRlciA6IFsuLi5zb3VyY2VzXTtcbiAgfSwgW2ZpbHRlcmVkRGF0YSwgY3VycmVudFNvdXJjZSwgY3VycmVudFRhcmdldCwgc291cmNlcywgdGFyZ2V0cywgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQsIG5vZGVQYWRkaW5nXSk7XG5cbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNvdXJjZSBvciB0YXJnZXQgdG8gaGlnaGxpZ2h0IGJhc2VkIG9uIGFuaW1hdGlvbiBzdGF0ZVxuICBsZXQgaGlnaGxpZ2h0U291cmNlTmFtZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIGxldCBoaWdobGlnaHRUYXJnZXROYW1lOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgaWYgKGlzSW5GdWxsT3BhY2l0eVN0YXRlKSB7XG4gICAgaGlnaGxpZ2h0U291cmNlTmFtZSA9IG51bGw7XG4gICAgaGlnaGxpZ2h0VGFyZ2V0TmFtZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgIGhpZ2hsaWdodFNvdXJjZU5hbWUgPSBzb3J0ZWRTb3VyY2VzRm9ySGlnaGxpZ2h0W2hvdmVyZWRTb3VyY2VJbmRleF07XG4gIH0gZWxzZSBpZiAoaG92ZXJlZFRhcmdldEluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgIGhpZ2hsaWdodFRhcmdldE5hbWUgPSB0YXJnZXRzW2hvdmVyZWRUYXJnZXRJbmRleF07XG4gIH1cblxuICAvLyBFbmhhbmNlZCBhbmltYXRpb24gcGF1c2UvcmVzdW1lIHdpdGggZGVidWcgdHJhY2tpbmdcbiAgY29uc3QgcGF1c2VBbmltYXRpb24gPSB1c2VDYWxsYmFjaygocmVhc29uOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyAmJiAhYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfij7jvuI8gIFBBVVNJTkcgQU5JTUFUSU9OOicsIHJlYXNvbiwge1xuICAgICAgICBjdXJyZW50U291cmNlSW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCxcbiAgICAgICAgY3VycmVudFRhcmdldEluZGV4OiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXgsXG4gICAgICAgIGN1cnJlbnRTb3VyY2UsXG4gICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCA9IHRydWU7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5wYXVzZWRBdCA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpO1xuICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCBbY3VycmVudFNvdXJjZSwgY3VycmVudFRhcmdldF0pO1xuXG4gIGNvbnN0IHJlc3VtZUFuaW1hdGlvbiA9IHVzZUNhbGxiYWNrKChyZWFzb246IHN0cmluZykgPT4ge1xuICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nICYmIGFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pa277iPICBSRVNVTUlORyBBTklNQVRJT046JywgcmVhc29uLCB7XG4gICAgICAgIGN1cnJlbnRTb3VyY2VJbmRleDogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4LFxuICAgICAgICBjdXJyZW50VGFyZ2V0SW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCxcbiAgICAgICAgcGF1c2VkRHVyYXRpb246IERhdGUubm93KCkgLSBhbmltYXRpb25SZWYuY3VycmVudC5wYXVzZWRBdFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5yZXN1bWVGcm9tID0gJ3NvdXJjZSc7XG4gICAgICBcbiAgICAgIC8vIFJlc3VtZSBhbmltYXRpb24gZnJvbSBjdXJyZW50IHBvc2l0aW9uIHdpdGggYSBzbWFsbCBkZWxheSB0byBlbnN1cmUgc3RhdGUgaXMgdXBkYXRlZFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nICYmICFhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgICAgIGFuaW1hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcbiAgICB9XG4gIH0sIFthbmltYXRlXSk7XG5cbiAgLy8gVXBkYXRlIGhvdmVyIGhhbmRsZXJzIHdpdGggcHJvcGVyIHN0YXRlIG1hbmFnZW1lbnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN2Z1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3Qoc3ZnUmVmLmN1cnJlbnQpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBsaW5rIGhvdmVyIGJlaGF2aW9yXG4gICAgc3ZnLnNlbGVjdEFsbCgncGF0aCcpXG4gICAgICAub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbihldmVudDogYW55LCBkOiBhbnkpIHtcbiAgICAgICAgLy8gUGF1c2UgYW5pbWF0aW9uIGR1cmluZyBob3ZlclxuICAgICAgICBwYXVzZUFuaW1hdGlvbignbGluayBob3ZlcicpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGhvdmVyIHN0YXRlc1xuICAgICAgICBzZXRIb3ZlcmVkTGluayhkKTtcbiAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgICBcbiAgICAgICAgLy8gSGFuZGxlIHNvdXJjZSBub2RlIGhvdmVyXG4gICAgICAgIGlmIChkLnNvdXJjZSAmJiBkLnNvdXJjZS5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSkge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IHNvcnRlZFNvdXJjZXMuaW5kZXhPZihkLnNvdXJjZS5uYW1lKTtcbiAgICAgICAgICBzZXRIb3ZlcmVkU291cmNlSW5kZXgoaWR4KTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+OryBNYW51YWwgc291cmNlIGhpZ2hsaWdodDonLCBkLnNvdXJjZS5uYW1lLCAnaW5kZXg6JywgaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSGFuZGxlIHRhcmdldCBub2RlIGhvdmVyXG4gICAgICAgIGlmIChkLnRhcmdldCAmJiBkLnRhcmdldC5jYXRlZ29yeSA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IHNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHQuaW5kZXhPZihkLnRhcmdldC5uYW1lKTtcbiAgICAgICAgICBzZXRIb3ZlcmVkVGFyZ2V0SW5kZXgoaWR4KTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+OryBNYW51YWwgdGFyZ2V0IGhpZ2hsaWdodDonLCBkLnRhcmdldC5uYW1lLCAnaW5kZXg6JywgaWR4KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBSZXN1bWUgYW5pbWF0aW9uXG4gICAgICAgIHJlc3VtZUFuaW1hdGlvbignbGluayBob3ZlciBlbmQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGhvdmVyIHN0YXRlc1xuICAgICAgICBzZXRIb3ZlcmVkTGluayhudWxsKTtcbiAgICAgICAgc2V0SG92ZXJlZFNvdXJjZUluZGV4KG51bGwpO1xuICAgICAgICBzZXRIb3ZlcmVkVGFyZ2V0SW5kZXgobnVsbCk7XG4gICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBub2RlIGhvdmVyIGJlaGF2aW9yXG4gICAgc3ZnLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbihldmVudDogYW55LCBkOiBhbnkpIHtcbiAgICAgICAgLy8gUGF1c2UgYW5pbWF0aW9uIGR1cmluZyBob3ZlclxuICAgICAgICBwYXVzZUFuaW1hdGlvbignbm9kZSBob3ZlcicpO1xuICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnaGlnaGxpZ2h0aW5nJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgc291cmNlIG5vZGUgaG92ZXJcbiAgICAgICAgaWYgKGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpIHtcbiAgICAgICAgICBjb25zdCBpZHggPSBzb3J0ZWRTb3VyY2VzLmluZGV4T2YoZC5uYW1lKTtcbiAgICAgICAgICBzZXRIb3ZlcmVkU291cmNlSW5kZXgoaWR4KTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+OryBNYW51YWwgc291cmNlIG5vZGUgaGlnaGxpZ2h0OicsIGQubmFtZSwgJ2luZGV4OicsIGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEhhbmRsZSB0YXJnZXQgbm9kZSBob3ZlclxuICAgICAgICBpZiAoZC5jYXRlZ29yeSA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IHNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHQuaW5kZXhPZihkLm5hbWUpO1xuICAgICAgICAgIHNldEhvdmVyZWRUYXJnZXRJbmRleChpZHgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46vIE1hbnVhbCB0YXJnZXQgbm9kZSBoaWdobGlnaHQ6JywgZC5uYW1lLCAnaW5kZXg6JywgaWR4KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBSZXN1bWUgYW5pbWF0aW9uXG4gICAgICAgIHJlc3VtZUFuaW1hdGlvbignbm9kZSBob3ZlciBlbmQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGhvdmVyIHN0YXRlc1xuICAgICAgICBzZXRIb3ZlcmVkU291cmNlSW5kZXgobnVsbCk7XG4gICAgICAgIHNldEhvdmVyZWRUYXJnZXRJbmRleChudWxsKTtcbiAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIENsZWFuIHVwIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ3BhdGgsIHJlY3QnKVxuICAgICAgICAub24oJ21vdXNlZW50ZXInLCBudWxsKVxuICAgICAgICAub24oJ21vdXNlbGVhdmUnLCBudWxsKTtcbiAgICB9O1xuICB9LCBbc29ydGVkU291cmNlcywgc29ydGVkVGFyZ2V0c0ZvckhpZ2hsaWdodCwgY3VycmVudFNvdXJjZSwgY3VycmVudFRhcmdldCwgcGF1c2VBbmltYXRpb24sIHJlc3VtZUFuaW1hdGlvbl0pO1xuXG4gIC8vIE1haW4gcmVuZGVyaW5nIGVmZmVjdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc3ZnUmVmLmN1cnJlbnQgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm47XG4gICAgXG4gICAgLy8gVGhlIG1haW4gcmVuZGVyaW5nIGxvZ2ljIGhhbmRsZXMgYWxsIG9wYWNpdHkgdXBkYXRlc1xuICAgIC8vIFRoaXMgZW5zdXJlcyBkYXRhIGJpbmRpbmcgaXMgY29ycmVjdCBhbmQgcHJldmVudHMgdGhlIHVuZGVmaW5lZCBlcnJvclxuICAgIFxuICB9LCBbZmlsdGVyZWREYXRhLCBob3ZlcmVkU291cmNlSW5kZXgsIGhvdmVyZWRUYXJnZXRJbmRleCwgYW5pbWF0aW9uUGhhc2UsIHNvcnRlZFNvdXJjZXMsIHRhcmdldHMsIGN1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXRdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgcmVmPXtjb250YWluZXJSZWZ9IHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnLCBtaW5IZWlnaHQ6IDIyMCwgbWluV2lkdGg6IDMyMCwgcG9zaXRpb246ICdyZWxhdGl2ZScgfX0+XG4gICAgICB7LyogU2hvdyBhIG1lc3NhZ2UgaWYgZGF0YSBpcyB2ZXJ5IHNwYXJzZSAqL31cbiAgICAgIHsobm9kZUNvdW50IDw9IDIgfHwgKHNvdXJjZXMubGVuZ3RoIDw9IDEgfHwgdGFyZ2V0cy5sZW5ndGggPD0gMSkpICYmIChcbiAgICAgICAgPGRpdiBzdHlsZT17e1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHRvcDogNDAsXG4gICAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKScsXG4gICAgICAgICAgYmFja2dyb3VuZDogJ3JnYmEoMjU1LDI1NSwyMDAsMC45NSknLFxuICAgICAgICAgIGNvbG9yOiAnIzE3MEY1RicsXG4gICAgICAgICAgcGFkZGluZzogJzEycHggMjRweCcsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiA4LFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICAgICAgICBmb250U2l6ZTogMTgsXG4gICAgICAgICAgekluZGV4OiAxMCxcbiAgICAgICAgICBib3hTaGFkb3c6ICcwIDJweCAxMnB4IDAgcmdiYSgwLDAsMCwwLjA4KSdcbiAgICAgICAgfX0+XG4gICAgICAgICAgTm90IGVub3VnaCBkYXRhIHRvIHNob3cgYSBtZWFuaW5nZnVsIGZsb3cgZGlhZ3JhbS5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgPHN2Z1xuICAgICAgICByZWY9e3N2Z1JlZn1cbiAgICAgICAgd2lkdGg9e2NoYXJ0V2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodH1cbiAgICAgICAgaGVpZ2h0PXtjaGFydEhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tfVxuICAgICAgICB2aWV3Qm94PXtgMCAwICR7Y2hhcnRXaWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0fSAke2NoYXJ0SGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b219YH1cbiAgICAgICAgc3R5bGU9e3sgZGlzcGxheTogJ2Jsb2NrJywgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcgfX1cbiAgICAgID5cbiAgICAgICAgey8qIE1haW4gY2hhcnQgZ3JvdXAsIHRyYW5zbGF0ZWQgYnkgbWFyZ2luICovfVxuICAgICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sJHttYXJnaW4udG9wfSlgfT5cbiAgICAgICAgICB7LyogLi4uIG5vZGVzIGFuZCBsaW5rcyAuLi4gKi99XG4gICAgICAgIDwvZz5cbiAgICAgICAgey8qIERlYnVnIG91dGxpbmVzIGZvciBhbGlnbm1lbnQgKG9ubHkgaWYgZGVidWdPbikgKi99XG4gICAgICAgIHtkZWJ1Z09uICYmIChcbiAgICAgICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sJHttYXJnaW4udG9wfSlgfT5cbiAgICAgICAgICAgIHsvKiBOb2RlIGRlYnVnIG91dGxpbmVzICovfVxuICAgICAgICAgICAge0FycmF5LmlzQXJyYXkoZGVidWdTYW5rZXlEYXRhPy5ub2RlcykgJiYgZGVidWdTYW5rZXlEYXRhLm5vZGVzLm1hcCgoZDogYW55LCBpOiBudW1iZXIpID0+IChcbiAgICAgICAgICAgICAgPHJlY3RcbiAgICAgICAgICAgICAgICBrZXk9e2BkZWJ1Zy1ub2RlLSR7aX1gfVxuICAgICAgICAgICAgICAgIHg9e2QueDB9XG4gICAgICAgICAgICAgICAgeT17ZC55MH1cbiAgICAgICAgICAgICAgICB3aWR0aD17ZC54MSAtIGQueDB9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXtkLnkxIC0gZC55MH1cbiAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgc3Ryb2tlPVwibWFnZW50YVwiXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5PVwiNCAyXCJcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzPVwibm9uZVwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICAgIHsvKiBMaW5rIGRlYnVnIG91dGxpbmVzIChpZiBhbnkpICovfVxuICAgICAgICAgICAge0FycmF5LmlzQXJyYXkoZGVidWdTYW5rZXlEYXRhPy5saW5rcykgJiYgZGVidWdTYW5rZXlEYXRhLmxpbmtzLm1hcCgoZDogYW55LCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGNsYW1wZWRTYW5rZXlMaW5rSG9yaXpvbnRhbCgpKGQpIHx8ICcnO1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICBrZXk9e2BkZWJ1Zy1saW5rLSR7aX1gfVxuICAgICAgICAgICAgICAgICAgZD17cGF0aH1cbiAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN5YW5cIlxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgIDwvZz5cbiAgICAgICAgKX1cbiAgICAgIDwvc3ZnPlxuICAgICAge3Rvb2x0aXBFbH1cbiAgICA8L2Rpdj5cbiAgKTtcbn0gIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCJkMyIsInNhbmtleSIsInVzZVZpc3VhbGl6YXRpb25EYXRhIiwiZ2V0WWVhcnNDYXRlZ29yeSIsImdldE5vZGVDb2xvciIsInVzZUFwcENvbnRleHQiLCJhdmFpbGFibGVGaWVsZHMiLCJ2YWx1ZSIsImxhYmVsIiwiWUVBUlNfQ0FURUdPUklFUyIsImdldFZhbGlkWWVhcnNDYXRlZ29yeSIsInllYXJzIiwiaXNOYU4iLCJzYW5rZXlMaW5rV2F2ZSIsImQiLCJ3YXZlQW1wbGl0dWRlIiwid2F2ZUZyZXF1ZW5jeSIsImNoYXJ0V2lkdGgiLCJjaGFydEhlaWdodCIsIngwIiwic291cmNlIiwieDEiLCJ0YXJnZXQiLCJ5MCIsInkxIiwiTWF0aCIsIm1heCIsIm1pbiIsIm1pZFgiLCJ3YXZlWTAiLCJzaW4iLCJQSSIsIndhdmVZMSIsImNsYW1wZWRTYW5rZXlMaW5rSG9yaXpvbnRhbCIsInN5IiwidHkiLCJjdXJ2YXR1cmUiLCJ4aSIsImludGVycG9sYXRlTnVtYmVyIiwieDIiLCJ4MyIsIkFsbHV2aWFsRGlhZ3JhbSIsIndpZHRoIiwiaGVpZ2h0IiwiYXV0b1BsYXkiLCJvblF1ZXN0aW9uQ2hhbmdlIiwiY29udGFpbmVyUmVmIiwiY29udGFpbmVyV2lkdGgiLCJzZXRDb250YWluZXJXaWR0aCIsImNvbnRhaW5lckhlaWdodCIsInNldENvbnRhaW5lckhlaWdodCIsImN1cnJlbnQiLCJvYnNlcnZlciIsIndpbmRvdyIsIlJlc2l6ZU9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiY29udGVudFJlY3QiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInN2Z1JlZiIsImRhdGEiLCJpc0xvYWRpbmciLCJlcnJvciIsInNldHRpbmdzIiwiZ2V0Q3VycmVudFRoZW1lQ29sb3JzIiwiY3VycmVudFNvdXJjZSIsInNldEN1cnJlbnRTb3VyY2UiLCJjdXJyZW50VGFyZ2V0Iiwic2V0Q3VycmVudFRhcmdldCIsImZpbHRlcmVkRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInVzZVRlc3REYXRhIiwiZmlsdGVyIiwiaXRlbSIsInRlc3RfZGF0YSIsInNvdXJjZXMiLCJjYXQiLCJzb21lIiwieWVhcnNfYXRfbWVkdHJvbmljIiwiZnJvbSIsIlNldCIsIm1hcCIsInRhcmdldHMiLCJzb3J0IiwiTUlOX0NIQVJUX0hFSUdIVCIsIk1BWF9DSEFSVF9IRUlHSFQiLCJNSU5fQ0hBUlRfV0lEVEgiLCJNQVhfQ0hBUlRfV0lEVEgiLCJub2RlQ291bnQiLCJhdmFpbGFibGVIZWlnaHQiLCJhdmFpbGFibGVXaWR0aCIsIm1hcmdpbiIsImxlZnQiLCJyaWdodCIsIm1heE5vZGVIZWlnaHQiLCJtYXhMaW5rV2lkdGgiLCJtaW5Ob2RlSGVpZ2h0IiwibWluUGFkZGluZyIsIm5vZGVIZWlnaHQiLCJmbG9vciIsIm5vZGVQYWRkaW5nIiwibGFiZWxGb250U2l6ZSIsIm1lYXN1cmVUZXh0V2lkdGgiLCJ0ZXh0IiwiZm9udCIsIl9jYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjYW52YXMiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsIm1lYXN1cmVUZXh0IiwibGFiZWxGb250IiwiYWxsTGFiZWxzIiwibGFiZWxXaWR0aHMiLCJtYXhMYWJlbFdpZHRoIiwibGFiZWxQYWRkaW5nIiwidG9wIiwiYm90dG9tIiwiY29uc29sZSIsImxvZyIsImN1cnJlbnRTb3VyY2VSZWYiLCJjdXJyZW50VGFyZ2V0UmVmIiwiaW5zaWdodHMiLCJzZXRJbnNpZ2h0cyIsImhvdmVyZWROb2RlIiwic2V0SG92ZXJlZE5vZGUiLCJob3ZlcmVkTGluayIsInNldEhvdmVyZWRMaW5rIiwidG9vbHRpcCIsInNldFRvb2x0aXAiLCJsYXN0Q2F0ZWdvcnlDaGFuZ2UiLCJzZXRMYXN0Q2F0ZWdvcnlDaGFuZ2UiLCJjdXJyZW50VGFyZ2V0SW5kZXgiLCJzZXRDdXJyZW50VGFyZ2V0SW5kZXgiLCJpc0FuaW1hdGluZyIsInNldElzQW5pbWF0aW5nIiwiaG92ZXJlZFNvdXJjZUluZGV4Iiwic2V0SG92ZXJlZFNvdXJjZUluZGV4IiwiaG92ZXJlZFRhcmdldEluZGV4Iiwic2V0SG92ZXJlZFRhcmdldEluZGV4IiwiaXNJbkZ1bGxPcGFjaXR5U3RhdGUiLCJzZXRJc0luRnVsbE9wYWNpdHlTdGF0ZSIsImFuaW1hdGlvblBoYXNlIiwic2V0QW5pbWF0aW9uUGhhc2UiLCJhbmltYXRpb25SZWYiLCJ0aW1lciIsInJ1bm5pbmciLCJjdXJyZW50U291cmNlSW5kZXgiLCJpc1BhdXNlZCIsInBhdXNlZEF0IiwiRGF0ZSIsIm5vdyIsInJlc3VtZUZyb20iLCJjeWNsZUNvdW50IiwicHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImJhc2VTcGVlZCIsImF1dG9QbGF5U3BlZWQiLCJyZWR1Y3Rpb25GYWN0b3IiLCJzdGVwRHVyYXRpb24iLCJwYXVzZUR1cmF0aW9uIiwiY2F0ZWdvcnlQYXVzZUR1cmF0aW9uIiwibGlua1RyYW5zaXRpb25EdXJhdGlvbiIsInNvcnRlZFNvdXJjZXMiLCJzb3VyY2VzRm9yTm9kZXMiLCJhIiwiYiIsImluZGV4T2YiLCJub2RlcyIsIm5hbWUiLCJpZCIsImNhdGVnb3J5IiwibGlua3NNYXAiLCJNYXAiLCJmb3JFYWNoIiwiaW5jbHVkZXMiLCJzb3VyY2VJZCIsInRhcmdldElkIiwia2V5IiwiaGFzIiwic2V0IiwiZ2V0IiwibGlua3MiLCJ2YWx1ZXMiLCJzYW5rZXlHZW5lcmF0b3IiLCJub2RlSWQiLCJub2RlV2lkdGgiLCJleHRlbnQiLCJzYW5rZXlEYXRhIiwic291cmNlTm9kZXMiLCJhbmltYXRlIiwiZGF0YUxlbmd0aCIsInRhcmdldE9wdGlvbnMiLCJmIiwic291cmNlSW5kZXgiLCJ0YXJnZXRJbmRleCIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwic291cmNlT3B0aW9ucyIsInNvdXJjZVByb2dyZXNzIiwidGFyZ2V0UHJvZ3Jlc3MiLCJpc0xhc3RTb3VyY2UiLCJoYXNNb3JlVGFyZ2V0cyIsIm5leHRUaW1lb3V0IiwicHJvZ3Jlc3MiLCJzZXRUaW1lb3V0IiwidGFyZ2V0T3B0aW9uc0xlbmd0aCIsImF2YWlsYWJsZVRhcmdldHMiLCJjbGVhclRpbWVvdXQiLCJuZXh0VGFyZ2V0IiwicHJldmlvdXNUYXJnZXQiLCJhbGxUYXJnZXRPcHRpb25zIiwibmV4dFNvdXJjZUluZGV4IiwibmV4dFNvdXJjZSIsIm5ld1RhcmdldE9wdGlvbnMiLCJmaXJzdFRhcmdldCIsImlzQXV0b1BsYXlFbmFibGVkIiwic3ZnUmVmRXhpc3RzIiwiaXNSdW5uaW5nIiwic291cmNlQ2F0ZWdvcnkiLCJ0b3RhbFNvdXJjZXMiLCJ0b3RhbFRhcmdldHMiLCJzcGVlZCIsIm5vZGVMYWJlbEZvbnRTaXplIiwibm9kZUxhYmVsRm9udFdlaWdodCIsIm5vZGVMYWJlbENvbG9yIiwiaXNEYXJrTW9kZSIsIm5vZGVMYWJlbEZvbnRGYW1pbHkiLCJub2RlTGFiZWxPZmZzZXQiLCJsb2NhbERlYnVnIiwic2V0TG9jYWxEZWJ1ZyIsInNob3dUaGVtZVRvZ2dsZSIsInNldFNob3dUaGVtZVRvZ2dsZSIsImRlYnVnT24iLCJkZWJ1Z1NhbmtleURhdGEiLCJzZXREZWJ1Z1NhbmtleURhdGEiLCJzdmciLCJzZWxlY3QiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJhdHRyIiwic29ydGVkVGFyZ2V0cyIsInNvdXJjZUFjY2Vzc29yIiwidGFyZ2V0QWNjZXNzb3IiLCJ2YWxpZERhdGEiLCJpc0R1bW15IiwibGluayIsImxlZnRUb3RhbHMiLCJsIiwicmVkdWNlIiwic3VtIiwicmlnaHRUb3RhbHMiLCJsZWZ0U3VtIiwicmlnaHRTdW0iLCJsZWZ0U2NhbGUiLCJyaWdodFNjYWxlIiwicyIsInQiLCJkeW5hbWljTm9kZVBhZGRpbmciLCJsZWZ0Tm9kZXMiLCJuIiwicmlnaHROb2RlcyIsImV2ZXJ5IiwiaSIsImVudGVyIiwiYXBwZW5kIiwibG93ZXIiLCJub2RlWXMiLCJmbGF0IiwibWluWSIsIm1heFkiLCJ1c2VkSGVpZ2h0Iiwib2Zmc2V0WSIsImciLCJkZWZzIiwiZW1wdHkiLCJsaW5rc0ciLCJub2Rlc0ciLCJnbG93RmlsdGVyIiwiZmVNZXJnZSIsImZpbHRlcmVkTGlua3MiLCJzdHlsZSIsImxpbmtLZXkiLCJsaW5rU2VsIiwiZXhpdCIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImlzQ2F0ZWdvcnlDaGFuZ2UiLCJuZXdMaW5rcyIsImJhc2VPcGFjaXR5IiwiaGlnaGxpZ2h0T3BhY2l0eSIsImRpbU9wYWNpdHkiLCJob3ZlcmVkU291cmNlIiwiaG92ZXJlZFRhcmdldCIsImVhY2giLCJwYXRoIiwidG90YWxMZW5ndGgiLCJnZXRUb3RhbExlbmd0aCIsImRlbGF5IiwiZWFzZSIsImVhc2VDdWJpY0luT3V0Iiwib24iLCJldmVudCIsIngiLCJvZmZzZXRYIiwieSIsImNvbnRlbnQiLCJkaXYiLCJjbGFzc05hbWUiLCJmaWx0ZXJlZE5vZGVzIiwibm9kZVNlbCIsImpvaW4iLCJpc0Nvbm5lY3RlZCIsImlkeCIsInVwZGF0ZSIsImxhYmVsTGF5ZXIiLCJzb3VyY2VOb2RlU2V0IiwidGFyZ2V0Tm9kZVNldCIsInRhcmdldE5vZGVzIiwibm9kZSIsIm1vc3RDb21tb24iLCJ1bmRlZmluZWQiLCJ0aXRsZSIsInNwbGl0IiwiZGVzY3JpcHRpb24iLCJjYXRlZ29yeUNvbG9ycyIsInNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHQiLCJzb3J0ZWQiLCJpc0hvdmVyZWQiLCJ0b29sdGlwVmlzaWJsZSIsInNldFRvb2x0aXBWaXNpYmxlIiwidG9vbHRpcFRpbWVvdXRSZWYiLCJ0b29sdGlwRWwiLCJwb3NpdGlvbiIsImJhY2tncm91bmQiLCJjb2xvciIsInBhZGRpbmciLCJib3JkZXJSYWRpdXMiLCJwb2ludGVyRXZlbnRzIiwiekluZGV4IiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJmb250U2l6ZSIsImJveFNoYWRvdyIsImJvcmRlciIsIm1heFdpZHRoIiwid2hpdGVTcGFjZSIsIm92ZXJmbG93IiwidGV4dE92ZXJmbG93Iiwib3BhY2l0eSIsInJvbGUiLCJhcmlhLWxpdmUiLCJzb3J0ZWRTb3VyY2VzRm9ySGlnaGxpZ2h0IiwidmlzdWFsT3JkZXIiLCJzbGljZSIsImhpZ2hsaWdodFNvdXJjZU5hbWUiLCJoaWdobGlnaHRUYXJnZXROYW1lIiwicGF1c2VBbmltYXRpb24iLCJyZWFzb24iLCJyZXN1bWVBbmltYXRpb24iLCJwYXVzZWREdXJhdGlvbiIsInJlZiIsIm1pbkhlaWdodCIsIm1pbldpZHRoIiwidHJhbnNmb3JtIiwidmlld0JveCIsImRpc3BsYXkiLCJyZWN0IiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZVdpZHRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/DataVisualization/AlluvialDiagram.tsx\n"));

/***/ })

});