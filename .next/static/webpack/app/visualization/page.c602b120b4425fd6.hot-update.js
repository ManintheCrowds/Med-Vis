"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/visualization/page",{

/***/ "(app-pages-browser)/./src/components/DataVisualization/ChordDiagram.tsx":
/*!***********************************************************!*\
  !*** ./src/components/DataVisualization/ChordDiagram.tsx ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ChordDiagram; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/useVisualizationData */ \"(app-pages-browser)/./src/components/DataVisualization/shared/useVisualizationData.ts\");\n/* harmony import */ var _shared_QuestionSelector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/QuestionSelector */ \"(app-pages-browser)/./src/components/DataVisualization/shared/QuestionSelector.tsx\");\n/* harmony import */ var _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shared/chordUtils */ \"(app-pages-browser)/./src/components/DataVisualization/shared/chordUtils.ts\");\n/* harmony import */ var _lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/context/AppContext */ \"(app-pages-browser)/./src/lib/context/AppContext.tsx\");\n/* harmony import */ var _components_shared_GlobalControlsNav__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/shared/GlobalControlsNav */ \"(app-pages-browser)/./src/components/shared/GlobalControlsNav.tsx\");\n/* harmony import */ var _shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shared/colorUtils */ \"(app-pages-browser)/./src/components/DataVisualization/shared/colorUtils.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n// Helper to get color for a node using global context (theme-aware)\nfunction getNodeColor(nodeName, category, globalColors) {\n    let isDarkMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    const themeColors = isDarkMode ? globalColors.dark : globalColors.light;\n    if (category === \"years_at_medtronic\") {\n        var _themeColors_years_at_medtronic;\n        return ((_themeColors_years_at_medtronic = themeColors.years_at_medtronic) === null || _themeColors_years_at_medtronic === void 0 ? void 0 : _themeColors_years_at_medtronic[nodeName]) || \"#FF6B6B\";\n    }\n    // Use global colors if available, otherwise fallback to defaults\n    if (category === \"learning_style\") {\n        var _themeColors_learning_style;\n        return ((_themeColors_learning_style = themeColors.learning_style) === null || _themeColors_learning_style === void 0 ? void 0 : _themeColors_learning_style[nodeName]) || \"#60a5fa\";\n    }\n    if (category === \"peak_performance\") {\n        var _themeColors_peak_performance;\n        return ((_themeColors_peak_performance = themeColors.peak_performance) === null || _themeColors_peak_performance === void 0 ? void 0 : _themeColors_peak_performance[nodeName]) || \"#4F8EF7\";\n    }\n    if (category === \"motivation\") {\n        var _themeColors_motivation;\n        return ((_themeColors_motivation = themeColors.motivation) === null || _themeColors_motivation === void 0 ? void 0 : _themeColors_motivation[nodeName]) || \"#9467bd\";\n    }\n    if (category === \"shaped_by\") {\n        var _themeColors_shaped_by;\n        return ((_themeColors_shaped_by = themeColors.shaped_by) === null || _themeColors_shaped_by === void 0 ? void 0 : _themeColors_shaped_by[nodeName]) || \"#1f77b4\";\n    }\n    return \"#8884d8\";\n}\nfunction ChordDiagram(param) {\n    let { width = 1400, height = 1000, autoPlay = true, onRelationshipChange, enableRotation = true, showAllConnections = false } = param;\n    _s();\n    const svgRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const secondarySvgRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { data, isLoading, error } = (0,_shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_3__.useVisualizationData)();\n    const [currentSource, setCurrentSource] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"years_at_medtronic\");\n    const [currentTarget, setCurrentTarget] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"learning_style\");\n    const [insights, setInsights] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [tooltip, setTooltip] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const { settings } = (0,_lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__.useAppContext)();\n    const [lastCategoryChange, setLastCategoryChange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        source: currentSource,\n        target: currentTarget\n    });\n    const [showSecondaryChord, setShowSecondaryChord] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Animation state management (similar to AlluvialDiagram)\n    const [animationPhase, setAnimationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"full\");\n    const [highlightedArcIndex, setHighlightedArcIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [highlightedSide, setHighlightedSide] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isAnimating, setIsAnimating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Secondary chord animation state\n    const [secondaryAnimationPhase, setSecondaryAnimationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"full\");\n    const [secondaryHighlightedArcIndex, setSecondaryHighlightedArcIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [secondaryHighlightedSide, setSecondaryHighlightedSide] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Animation timing ref\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        timer: null,\n        running: false,\n        currentIndex: 0,\n        currentSide: \"left\",\n        isPaused: false\n    });\n    // Secondary chord animation timing ref\n    const secondaryAnimationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        timer: null,\n        running: false,\n        currentIndex: 0,\n        currentSide: \"left\",\n        isPaused: false\n    });\n    // Define available fields for the selector\n    const availableFields = [\n        {\n            value: \"years_at_medtronic\",\n            label: \"Years at Medtronic\"\n        },\n        {\n            value: \"peak_performance\",\n            label: \"Peak Performance\"\n        },\n        {\n            value: \"learning_style\",\n            label: \"Learning Style\"\n        },\n        {\n            value: \"motivation\",\n            label: \"Motivation\"\n        },\n        {\n            value: \"shaped_by\",\n            label: \"Shaped By\"\n        }\n    ];\n    // Typography constants (theme-aware)\n    const labelFontSize = 20;\n    const labelFontWeight = 700;\n    const labelColor = settings.isDarkMode ? \"#ffffff\" : \"#170F5F\";\n    const labelFontFamily = 'Avenir Next World, -apple-system, BlinkMacSystemFont, \"SF Pro\", \"Roboto\", sans-serif';\n    // Check if peak performance is involved and show secondary chord\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const isPeakPerformanceInvolved = currentSource === \"peak_performance\" || currentTarget === \"peak_performance\";\n        setShowSecondaryChord(isPeakPerformanceInvolved);\n    }, [\n        currentSource,\n        currentTarget\n    ]);\n    // Secondary chord diagram for peak performance breakdown\n    const renderSecondaryChord = ()=>{\n        if (!secondarySvgRef.current || !data.length || isLoading) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(secondarySvgRef.current);\n        svg.selectAll(\"*\").remove();\n        const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n        // Get all data for secondary chord (Years at Medtronic vs Peak Performance categories)\n        const secondaryData = filteredData.filter((d)=>d.peak_performance);\n        if (secondaryData.length < 5) return;\n        // Use same dimensions as main chord for consistency\n        const secondaryWidth = showSecondaryChord ? width * 0.45 : width;\n        const secondaryHeight = showSecondaryChord ? height * 0.8 : height * 0.85;\n        const secondaryMargin = {\n            top: 80,\n            right: 80,\n            bottom: 100,\n            left: 80\n        };\n        const secondaryChartWidth = secondaryWidth - secondaryMargin.left - secondaryMargin.right;\n        const secondaryChartHeight = secondaryHeight - secondaryMargin.top - secondaryMargin.bottom;\n        const secondaryRadius = Math.max(120, Math.min(secondaryChartWidth, secondaryChartHeight) / 2 - 60);\n        // Years categories and Peak Performance categories\n        const yearsCategories = [\n            \"0-5\",\n            \"6-10\",\n            \"11-15\",\n            \"16-20\",\n            \"20+\"\n        ];\n        const peakPerfCategories = Array.from(new Set(secondaryData.map((d)=>d.peak_performance))).filter(Boolean).sort();\n        // Create bipartite matrix: Years vs Peak Performance\n        const allCategories = [\n            ...yearsCategories,\n            ...peakPerfCategories\n        ];\n        const matrix = allCategories.map((sourceCategory, sourceIndex)=>allCategories.map((targetCategory, targetIndex)=>{\n                // Only create connections between years and peak performance (not within same type)\n                const sourceIsYears = sourceIndex < yearsCategories.length;\n                const targetIsYears = targetIndex < yearsCategories.length;\n                // Only connect years to peak performance\n                if (sourceIsYears === targetIsYears) return 0;\n                // Count people who match this year + performance combination\n                const yearsCat = sourceIsYears ? sourceCategory : targetCategory;\n                const perfCat = sourceIsYears ? targetCategory : sourceCategory;\n                return secondaryData.filter((d)=>{\n                    const years = (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0);\n                    const perf = d.peak_performance;\n                    return years === yearsCat && perf === perfCat;\n                }).length;\n            }));\n        // Create chord layout\n        const chordLayout = d3__WEBPACK_IMPORTED_MODULE_2__.chord().padAngle(0.05);\n        const chordData = chordLayout(matrix);\n        const g = svg.append(\"g\").attr(\"transform\", \"translate(\".concat(secondaryMargin.left + secondaryChartWidth / 2, \", \").concat(secondaryMargin.top + secondaryChartHeight / 2, \")\"));\n        // Draw arcs\n        const arc = d3__WEBPACK_IMPORTED_MODULE_2__.arc().innerRadius(secondaryRadius * 0.75).outerRadius(secondaryRadius * 0.95);\n        const ribbon = d3__WEBPACK_IMPORTED_MODULE_2__.ribbon().radius(secondaryRadius * 0.75);\n        // Colors: different hues for years vs peak performance types\n        const yearsColors = [\n            \"#0077CC\",\n            \"#00A3E0\",\n            \"#4FC3F7\",\n            \"#81C784\",\n            \"#AED581\"\n        ]; // Blues/Greens for years\n        const perfColors = [\n            \"#FF6B6B\",\n            \"#FFD166\",\n            \"#06D6A0\",\n            \"#118AB2\",\n            \"#FF9F1C\",\n            \"#4ECDC4\"\n        ]; // Various colors for performance types\n        const colors = [\n            ...yearsColors,\n            ...perfColors.slice(0, peakPerfCategories.length)\n        ];\n        // Draw groups (arcs) with animation and hover effects\n        const groupSelection = g.selectAll(\".chord-group\").data(chordData.groups).enter().append(\"path\").attr(\"class\", \"chord-group\").attr(\"d\", arc).style(\"fill\", (d, i)=>colors[i % colors.length]).style(\"opacity\", 0).on(\"mouseenter\", function(event, d) {\n            var _allCategories_d_index;\n            pauseAnimation(\"secondary arc hover\");\n            // Trigger highlighting for secondary chord\n            console.log(\"\\uD83C\\uDFAF Secondary chord arc hover:\", {\n                groupIndex: d.index,\n                category: allCategories[d.index]\n            });\n            setSecondaryAnimationPhase(\"highlighting\");\n            setSecondaryHighlightedArcIndex(d.index);\n            setSecondaryHighlightedSide(d.index < yearsCategories.length ? \"left\" : \"right\");\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: ((_allCategories_d_index = allCategories[d.index]) === null || _allCategories_d_index === void 0 ? void 0 : _allCategories_d_index.toString().replace(/_/g, \" \")) || \"\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 235,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: d.index < yearsCategories.length ? \"Years at Medtronic\" : \"Peak Performance Type\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 236,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Value: \",\n                                d.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 237,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 234,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", ()=>{\n            resumeAnimation(\"secondary arc hover end\");\n            setTooltip(null);\n            // Reset highlighting when animation resumes\n            setSecondaryAnimationPhase(\"full\");\n            setSecondaryHighlightedArcIndex(null);\n            setSecondaryHighlightedSide(null);\n        });\n        // Apply transition animations to groups\n        groupSelection.transition().duration(750).style(\"opacity\", (d, i)=>{\n            // Apply full relationship chain highlighting\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === i) {\n                    return 1.0; // Source arc is fully highlighted\n                }\n                // Check if this arc is connected to the highlighted arc\n                if (secondaryHighlightedArcIndex !== null) {\n                    const isConnected = chordData.some((chord)=>chord.source.index === i && chord.target.index === secondaryHighlightedArcIndex || chord.source.index === secondaryHighlightedArcIndex && chord.target.index === i);\n                    return isConnected ? 0.95 : 0.3;\n                }\n            }\n            return 0.8;\n        }).style(\"stroke-width\", (d, i)=>{\n            if (secondaryAnimationPhase === \"highlighting\" && secondaryHighlightedArcIndex === i) {\n                return 3;\n            }\n            return 1;\n        }).style(\"stroke\", (d, i)=>{\n            if (secondaryAnimationPhase === \"highlighting\" && secondaryHighlightedArcIndex === i) {\n                return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n            }\n            return \"none\";\n        });\n        // Draw chords (ribbons) with animation and hover effects\n        const chordSelection = g.selectAll(\".chord\").data(chordData).enter().append(\"path\").attr(\"class\", \"chord\").attr(\"d\", ribbon).style(\"fill\", (d)=>colors[d.source.index % colors.length]).style(\"opacity\", 0).on(\"mouseenter\", function(event, d) {\n            pauseAnimation(\"secondary ribbon hover\");\n            // Trigger highlighting for the source side of this ribbon\n            console.log(\"\\uD83C\\uDFAF Secondary ribbon hover:\", {\n                sourceIndex: d.source.index,\n                targetIndex: d.target.index,\n                sourceCategory: allCategories[d.source.index],\n                targetCategory: allCategories[d.target.index]\n            });\n            setSecondaryAnimationPhase(\"highlighting\");\n            setSecondaryHighlightedArcIndex(d.source.index);\n            setSecondaryHighlightedSide(d.source.index < yearsCategories.length ? \"left\" : \"right\");\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: [\n                                allCategories[d.source.index],\n                                \" ↔ \",\n                                allCategories[d.target.index]\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 315,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Connections: \",\n                                d.source.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 318,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 314,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", function() {\n            resumeAnimation(\"secondary ribbon hover end\");\n            setTooltip(null);\n            // Reset highlighting when animation resumes\n            setSecondaryAnimationPhase(\"full\");\n            setSecondaryHighlightedArcIndex(null);\n            setSecondaryHighlightedSide(null);\n        });\n        // Apply transition animations to chords\n        chordSelection.transition().duration(750).style(\"opacity\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                return 0.2; // Dim non-connected ribbons\n            }\n            return settings.isDarkMode ? 0.7 : 0.6;\n        }).style(\"stroke-width\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return 2.5;\n                }\n            }\n            return 0.5;\n        }).style(\"stroke\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n        // Add labels with proper spacing and rotation\n        const secondaryLabelRadius = Math.max(120, secondaryRadius * 1.45);\n        g.selectAll(\".chord-label\").data(chordData.groups).enter().append(\"text\").attr(\"class\", \"chord-label\").attr(\"transform\", (d)=>{\n            const angle = (d.startAngle + d.endAngle) / 2 - Math.PI / 2;\n            const x = secondaryLabelRadius * Math.cos(angle);\n            const y = secondaryLabelRadius * Math.sin(angle);\n            const rotation = angle * 180 / Math.PI;\n            // Rotate text for better readability\n            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {\n                return \"translate(\".concat(x, \", \").concat(y, \") rotate(\").concat(rotation + 180, \")\");\n            } else {\n                return \"translate(\".concat(x, \", \").concat(y, \") rotate(\").concat(rotation, \")\");\n            }\n        }).attr(\"text-anchor\", (d)=>{\n            const angle = (d.startAngle + d.endAngle) / 2 - Math.PI / 2;\n            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {\n                return \"end\";\n            } else {\n                return \"start\";\n            }\n        }).attr(\"alignment-baseline\", \"middle\").style(\"font-family\", labelFontFamily).style(\"font-weight\", labelFontWeight).style(\"font-size\", (d)=>{\n            // Dynamic font size based on number of labels\n            const totalLabels = allCategories.length;\n            if (totalLabels > 12) return \"13px\";\n            if (totalLabels > 10) return \"14px\";\n            if (totalLabels > 8) return \"15px\";\n            return \"16px\";\n        }).style(\"fill\", labelColor).style(\"text-transform\", \"uppercase\").text((d, i)=>{\n            var _allCategories_i;\n            const text = ((_allCategories_i = allCategories[i]) === null || _allCategories_i === void 0 ? void 0 : _allCategories_i.toString().replace(/_/g, \" \")) || \"\";\n            // Show full text for secondary chord labels\n            return text;\n        }).on(\"mouseenter\", function(event, d) {\n            var _allCategories_d_index;\n            const fullText = ((_allCategories_d_index = allCategories[d.index]) === null || _allCategories_d_index === void 0 ? void 0 : _allCategories_d_index.toString().replace(/_/g, \" \")) || \"\";\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: fullText\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 416,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: d.index < yearsCategories.length ? \"Years at Medtronic\" : \"Peak Performance Type\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 417,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 415,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", ()=>setTooltip(null));\n    };\n    // Helper function to ensure source and target are different\n    const ensureDifferentCategories = (source, target)=>{\n        if (source === target) {\n            // Find a different target\n            const differentOption = availableFields.find((field)=>field.value !== source);\n            return {\n                source,\n                target: differentOption ? differentOption.value : \"learning_style\"\n            };\n        }\n        return {\n            source,\n            target\n        };\n    };\n    // Ensure initial state doesn't have same categories\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const corrected = ensureDifferentCategories(currentSource, currentTarget);\n        if (corrected.source !== currentSource || corrected.target !== currentTarget) {\n            setCurrentSource(corrected.source);\n            setCurrentTarget(corrected.target);\n        }\n    }, []);\n    // Track current mode index with ref to avoid dependency issues\n    const currentModeIndexRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Update mode index when source/target changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const modeIndex = _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes.findIndex((mode)=>mode.source === currentSource && mode.target === currentTarget);\n        if (modeIndex !== -1) {\n            currentModeIndexRef.current = modeIndex;\n        }\n    }, [\n        currentSource,\n        currentTarget\n    ]);\n    // Auto-cycling logic with stable dependencies\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"\\uD83C\\uDFB5 ChordDiagram auto-cycling useEffect:\", {\n            autoPlay,\n            isAutoPlayEnabled: settings.isAutoPlayEnabled,\n            autoPlaySpeed: settings.autoPlaySpeed\n        });\n        if (!autoPlay || !settings.isAutoPlayEnabled) {\n            console.log(\"❌ ChordDiagram auto-cycling disabled\");\n            return;\n        }\n        console.log(\"✅ ChordDiagram starting auto-cycling\");\n        const interval = setInterval(()=>{\n            const nextModeIndex = (currentModeIndexRef.current + 1) % _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes.length;\n            const nextMode = _shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.cyclingModes[nextModeIndex];\n            // Safety check: ensure source and target are different\n            if (nextMode.source === nextMode.target) {\n                console.warn(\"Skipping invalid cycling mode with same source and target:\", nextMode);\n                return;\n            }\n            console.log(\"\\uD83D\\uDD04 ChordDiagram cycling to:\", {\n                from: \"mode \".concat(currentModeIndexRef.current),\n                to: \"\".concat(nextMode.source, \" → \").concat(nextMode.target),\n                modeIndex: nextModeIndex\n            });\n            currentModeIndexRef.current = nextModeIndex;\n            setCurrentSource(nextMode.source);\n            setCurrentTarget(nextMode.target);\n            setLastCategoryChange({\n                source: nextMode.source,\n                target: nextMode.target\n            });\n            onRelationshipChange === null || onRelationshipChange === void 0 ? void 0 : onRelationshipChange(nextMode.source, nextMode.target);\n        }, settings.autoPlaySpeed || 6000);\n        return ()=>{\n            console.log(\"\\uD83E\\uDDF9 ChordDiagram cleaning up auto-cycling interval\");\n            clearInterval(interval);\n        };\n    }, [\n        autoPlay,\n        settings.isAutoPlayEnabled,\n        settings.autoPlaySpeed\n    ]); // Stable dependencies only\n    // Remove pulsing animation to eliminate flickering - will use CSS animations instead if needed\n    // Arc highlighting animation with connected ribbons\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"\\uD83D\\uDD04 ChordDiagram arc highlighting effect:\", {\n            autoPlay,\n            isAutoPlayEnabled: settings.isAutoPlayEnabled,\n            dataLength: data.length\n        });\n        if (!autoPlay || !settings.isAutoPlayEnabled || !data.length) {\n            console.log(\"❌ Arc highlighting disabled\");\n            // Reset to full opacity when animation is disabled\n            setAnimationPhase(\"full\");\n            setHighlightedArcIndex(null);\n            setHighlightedSide(null);\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n            return;\n        }\n        const animate = ()=>{\n            if (!animationRef.current.running || animationRef.current.isPaused) return;\n            console.log(\"\\uD83C\\uDFAF ChordDiagram arc animation:\", {\n                side: animationRef.current.currentSide,\n                index: animationRef.current.currentIndex\n            });\n            setAnimationPhase(\"highlighting\");\n            setHighlightedArcIndex(animationRef.current.currentIndex);\n            setHighlightedSide(animationRef.current.currentSide);\n            // Log what connections will be highlighted\n            const debugFilteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n            const debugLeftValues = currentSource === \"years_at_medtronic\" ? [\n                \"0-5\",\n                \"6-10\",\n                \"11-15\",\n                \"16-20\",\n                \"20+\"\n            ] : Array.from(new Set(debugFilteredData.map((d)=>d[currentSource]))).filter(Boolean);\n            const debugRightValues = currentTarget === \"years_at_medtronic\" ? [\n                \"0-5\",\n                \"6-10\",\n                \"11-15\",\n                \"16-20\",\n                \"20+\"\n            ] : Array.from(new Set(debugFilteredData.map((d)=>d[currentTarget]))).filter(Boolean);\n            const highlightedCategory = animationRef.current.currentSide === \"left\" ? debugLeftValues[animationRef.current.currentIndex] : debugRightValues[animationRef.current.currentIndex];\n            console.log(\"✨ Highlighting full relationship chain for:\", {\n                sourceCategory: highlightedCategory,\n                sourceSide: animationRef.current.currentSide,\n                sourceIndex: animationRef.current.currentIndex\n            });\n            // Calculate timing based on global settings\n            const stepDuration = Math.max(1000, (settings.autoPlaySpeed || 3000) / 4);\n            const pauseDuration = Math.max(200, stepDuration / 6);\n            // Get current data context\n            const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n            const leftValues = currentSource === \"years_at_medtronic\" ? [\n                \"0-5\",\n                \"6-10\",\n                \"11-15\",\n                \"16-20\",\n                \"20+\"\n            ] : Array.from(new Set(filteredData.map((d)=>d[currentSource]))).filter(Boolean);\n            const rightValues = currentTarget === \"years_at_medtronic\" ? [\n                \"0-5\",\n                \"6-10\",\n                \"11-15\",\n                \"16-20\",\n                \"20+\"\n            ] : Array.from(new Set(filteredData.map((d)=>d[currentTarget]))).filter(Boolean);\n            const currentSideLength = animationRef.current.currentSide === \"left\" ? leftValues.length : rightValues.length;\n            // Move to next position\n            if (animationRef.current.currentIndex < currentSideLength - 1) {\n                animationRef.current.timer = setTimeout(()=>{\n                    if (animationRef.current.running && !animationRef.current.isPaused) {\n                        animationRef.current.currentIndex++;\n                        animate();\n                    }\n                }, stepDuration + pauseDuration);\n            } else {\n                // Switch sides or complete cycle\n                if (animationRef.current.currentSide === \"left\") {\n                    animationRef.current.currentSide = \"right\";\n                    animationRef.current.currentIndex = 0;\n                    animationRef.current.timer = setTimeout(()=>{\n                        if (animationRef.current.running && !animationRef.current.isPaused) {\n                            animate();\n                        }\n                    }, stepDuration);\n                } else {\n                    // Complete cycle - show full diagram briefly, then restart\n                    setAnimationPhase(\"full\");\n                    setHighlightedArcIndex(null);\n                    setHighlightedSide(null);\n                    animationRef.current.timer = setTimeout(()=>{\n                        if (animationRef.current.running && !animationRef.current.isPaused) {\n                            animationRef.current.currentSide = \"left\";\n                            animationRef.current.currentIndex = 0;\n                            animate();\n                        }\n                    }, stepDuration * 2);\n                }\n            }\n        };\n        // Start animation if not already running\n        if (!animationRef.current.running) {\n            console.log(\"✅ Starting ChordDiagram arc highlighting animation\");\n            animationRef.current.running = true;\n            animationRef.current.currentIndex = 0;\n            animationRef.current.currentSide = \"left\";\n            animationRef.current.isPaused = false;\n            animate();\n        } else {\n            console.log(\"⚠️ Arc highlighting animation already running\");\n        }\n        return ()=>{\n            console.log(\"\\uD83E\\uDDF9 Cleaning up ChordDiagram arc highlighting animation\");\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n            setAnimationPhase(\"full\");\n            setHighlightedArcIndex(null);\n            setHighlightedSide(null);\n        };\n    }, [\n        autoPlay,\n        settings.isAutoPlayEnabled,\n        data.length,\n        currentSource,\n        currentTarget,\n        settings.autoPlaySpeed,\n        settings.useTestData\n    ]);\n    // Secondary chord animation system\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!autoPlay || !settings.isAutoPlayEnabled || !data.length || !showSecondaryChord) {\n            // Stop animation if conditions not met\n            console.log(\"\\uD83D\\uDED1 Stopping secondary chord animation:\", {\n                autoPlay,\n                isAutoPlayEnabled: settings.isAutoPlayEnabled,\n                hasData: data.length > 0,\n                showSecondaryChord\n            });\n            if (secondaryAnimationRef.current.timer) {\n                clearTimeout(secondaryAnimationRef.current.timer);\n                secondaryAnimationRef.current.timer = null;\n            }\n            secondaryAnimationRef.current.running = false;\n            return;\n        }\n        const animateSecondary = ()=>{\n            if (!secondaryAnimationRef.current.running || secondaryAnimationRef.current.isPaused) return;\n            // Get secondary chord data context first\n            const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n            const secondaryData = filteredData.filter((d)=>d.peak_performance);\n            const yearsCategories = [\n                \"0-5\",\n                \"6-10\",\n                \"11-15\",\n                \"16-20\",\n                \"20+\"\n            ];\n            const peakPerfCategories = Array.from(new Set(secondaryData.map((d)=>d.peak_performance))).filter(Boolean).sort();\n            const allCategories = [\n                ...yearsCategories,\n                ...peakPerfCategories\n            ];\n            console.log(\"\\uD83C\\uDFAF SecondaryChord arc animation:\", {\n                side: secondaryAnimationRef.current.currentSide,\n                index: secondaryAnimationRef.current.currentIndex\n            });\n            setSecondaryAnimationPhase(\"highlighting\");\n            // Calculate the actual arc index based on side and position\n            const actualArcIndex = secondaryAnimationRef.current.currentSide === \"left\" ? secondaryAnimationRef.current.currentIndex // Left side: direct index (0-4)\n             : yearsCategories.length + secondaryAnimationRef.current.currentIndex; // Right side: offset by years count\n            setSecondaryHighlightedArcIndex(actualArcIndex);\n            setSecondaryHighlightedSide(secondaryAnimationRef.current.currentSide);\n            // Calculate timing based on global settings\n            const stepDuration = Math.max(1000, (settings.autoPlaySpeed || 3000) / 4);\n            const pauseDuration = Math.max(200, stepDuration / 6);\n            const currentSideLength = secondaryAnimationRef.current.currentSide === \"left\" ? yearsCategories.length : peakPerfCategories.length;\n            // Move to next position\n            if (secondaryAnimationRef.current.currentIndex < currentSideLength - 1) {\n                secondaryAnimationRef.current.timer = setTimeout(()=>{\n                    if (secondaryAnimationRef.current.running && !secondaryAnimationRef.current.isPaused) {\n                        secondaryAnimationRef.current.currentIndex++;\n                        animateSecondary();\n                    }\n                }, stepDuration + pauseDuration);\n            } else {\n                // Switch sides or complete cycle\n                if (secondaryAnimationRef.current.currentSide === \"left\") {\n                    secondaryAnimationRef.current.currentSide = \"right\";\n                    secondaryAnimationRef.current.currentIndex = 0;\n                    secondaryAnimationRef.current.timer = setTimeout(()=>{\n                        if (secondaryAnimationRef.current.running && !secondaryAnimationRef.current.isPaused) {\n                            animateSecondary();\n                        }\n                    }, stepDuration);\n                } else {\n                    // Complete cycle - show full diagram briefly, then restart\n                    setSecondaryAnimationPhase(\"full\");\n                    setSecondaryHighlightedArcIndex(null);\n                    setSecondaryHighlightedSide(null);\n                    secondaryAnimationRef.current.timer = setTimeout(()=>{\n                        if (secondaryAnimationRef.current.running && !secondaryAnimationRef.current.isPaused) {\n                            secondaryAnimationRef.current.currentSide = \"left\";\n                            secondaryAnimationRef.current.currentIndex = 0;\n                            animateSecondary();\n                        }\n                    }, stepDuration * 2);\n                }\n            }\n        };\n        // Start animation if not already running\n        if (!secondaryAnimationRef.current.running) {\n            console.log(\"✅ Starting SecondaryChord arc highlighting animation\");\n            secondaryAnimationRef.current.running = true;\n            secondaryAnimationRef.current.currentIndex = 0;\n            secondaryAnimationRef.current.currentSide = \"left\";\n            secondaryAnimationRef.current.isPaused = false;\n            animateSecondary();\n        } else {\n            console.log(\"⚠️ Secondary arc highlighting animation already running\");\n        }\n        return ()=>{\n            console.log(\"\\uD83E\\uDDF9 Cleaning up SecondaryChord arc highlighting animation\");\n            if (secondaryAnimationRef.current.timer) {\n                clearTimeout(secondaryAnimationRef.current.timer);\n                secondaryAnimationRef.current.timer = null;\n            }\n            secondaryAnimationRef.current.running = false;\n            setSecondaryAnimationPhase(\"full\");\n            setSecondaryHighlightedArcIndex(null);\n            setSecondaryHighlightedSide(null);\n        };\n    }, [\n        autoPlay,\n        settings.isAutoPlayEnabled,\n        data.length,\n        showSecondaryChord,\n        settings.autoPlaySpeed,\n        settings.useTestData\n    ]);\n    // Re-render secondary chord when its animation state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (showSecondaryChord) {\n            renderSecondaryChord();\n        }\n    }, [\n        showSecondaryChord,\n        data,\n        settings.useTestData,\n        settings.isDarkMode\n    ]);\n    // Update visual styling of existing main chord elements when animation state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        // Update left arcs opacity and stroke based on animation state\n        svg.selectAll(\"path.left-arc\").transition().duration(300).style(\"opacity\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\") {\n                    if (i === highlightedArcIndex) {\n                        return 1.0; // Source arc is fully highlighted\n                    }\n                    return 0.4; // Dim other left arcs\n                }\n            }\n            return 0.8; // Default opacity\n        }).style(\"stroke-width\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && i === highlightedArcIndex) {\n                    return 3;\n                }\n            }\n            return 1;\n        }).style(\"stroke\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && i === highlightedArcIndex) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n        // Update right arcs opacity and stroke based on animation state\n        svg.selectAll(\"path.right-arc\").transition().duration(300).style(\"opacity\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\") {\n                    if (i === highlightedArcIndex) {\n                        return 1.0; // Source arc is fully highlighted\n                    }\n                    return 0.4; // Dim other right arcs\n                }\n            }\n            return 0.8; // Default opacity\n        }).style(\"stroke-width\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\" && i === highlightedArcIndex) {\n                    return 3;\n                }\n            }\n            return 1;\n        }).style(\"stroke\", (d, i)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\" && i === highlightedArcIndex) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n        // Update ribbons opacity and stroke based on animation state\n        svg.selectAll(\"path.ribbon\").transition().duration(300).style(\"opacity\", (d)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                if (highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                return 0.2; // Dim non-connected ribbons\n            }\n            return settings.isDarkMode ? 0.7 : 0.6;\n        }).style(\"stroke-width\", (d)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index || highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return 2.5;\n                }\n            }\n            return 0.5;\n        }).style(\"stroke\", (d)=>{\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index || highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n    }, [\n        animationPhase,\n        highlightedArcIndex,\n        highlightedSide,\n        settings.isDarkMode\n    ]);\n    // Update visual styling of existing secondary chord elements when animation state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!secondarySvgRef.current || !showSecondaryChord) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(secondarySvgRef.current);\n        // Update secondary chord elements based on their animation state\n        svg.selectAll(\"path.chord-group\").transition().duration(300).style(\"opacity\", (d, i)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === i) {\n                    return 1.0; // Source arc is fully highlighted\n                }\n                return 0.4; // Dim other arcs\n            }\n            return 0.8;\n        }).style(\"stroke-width\", (d, i)=>{\n            if (secondaryAnimationPhase === \"highlighting\" && secondaryHighlightedArcIndex === i) {\n                return 3;\n            }\n            return 1;\n        }).style(\"stroke\", (d, i)=>{\n            if (secondaryAnimationPhase === \"highlighting\" && secondaryHighlightedArcIndex === i) {\n                return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n            }\n            return \"none\";\n        });\n        svg.selectAll(\"path.chord\").transition().duration(300).style(\"opacity\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                return 0.2; // Dim non-connected ribbons\n            }\n            return settings.isDarkMode ? 0.7 : 0.6;\n        }).style(\"stroke-width\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return 2.5;\n                }\n            }\n            return 0.5;\n        }).style(\"stroke\", (d)=>{\n            if (secondaryAnimationPhase === \"highlighting\") {\n                if (secondaryHighlightedArcIndex === d.source.index || secondaryHighlightedArcIndex === d.target.index) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n    }, [\n        secondaryAnimationPhase,\n        secondaryHighlightedArcIndex,\n        secondaryHighlightedSide,\n        settings.isDarkMode,\n        showSecondaryChord\n    ]);\n    // Remove conflicting opacity update system - opacity will be handled in main rendering\n    // Pause/Resume animation functions (similar to AlluvialDiagram)\n    const pauseAnimation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((reason)=>{\n        // Pause main chord animation\n        if (animationRef.current.running && !animationRef.current.isPaused) {\n            console.log(\"⏸️ Pausing Main Chord animation:\", reason);\n            animationRef.current.isPaused = true;\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n        }\n        // Pause secondary chord animation\n        if (secondaryAnimationRef.current.running && !secondaryAnimationRef.current.isPaused) {\n            console.log(\"⏸️ Pausing Secondary Chord animation:\", reason);\n            secondaryAnimationRef.current.isPaused = true;\n            if (secondaryAnimationRef.current.timer) {\n                clearTimeout(secondaryAnimationRef.current.timer);\n                secondaryAnimationRef.current.timer = null;\n            }\n        }\n    }, []);\n    const resumeAnimation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((reason)=>{\n        // Resume main chord animation\n        if (animationRef.current.running && animationRef.current.isPaused) {\n            console.log(\"▶️ Resuming Main Chord animation:\", reason);\n            animationRef.current.isPaused = false;\n            // Restart the animation timer immediately\n            const restartMainAnimation = ()=>{\n                if (!animationRef.current.running || animationRef.current.isPaused) return;\n                console.log(\"\\uD83D\\uDD04 Restarting Main Chord animation after pause\");\n                setAnimationPhase(\"highlighting\");\n                setHighlightedArcIndex(animationRef.current.currentIndex);\n                setHighlightedSide(animationRef.current.currentSide);\n                // Calculate timing based on global settings\n                const stepDuration = Math.max(1000, (settings.autoPlaySpeed || 3000) / 4);\n                const pauseDuration = Math.max(200, stepDuration / 6);\n                // Get current data context\n                const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n                const leftValues = currentSource === \"years_at_medtronic\" ? [\n                    \"0-5\",\n                    \"6-10\",\n                    \"11-15\",\n                    \"16-20\",\n                    \"20+\"\n                ] : Array.from(new Set(filteredData.map((d)=>d[currentSource]))).filter(Boolean);\n                const rightValues = currentTarget === \"years_at_medtronic\" ? [\n                    \"0-5\",\n                    \"6-10\",\n                    \"11-15\",\n                    \"16-20\",\n                    \"20+\"\n                ] : Array.from(new Set(filteredData.map((d)=>d[currentTarget]))).filter(Boolean);\n                const currentSideLength = animationRef.current.currentSide === \"left\" ? leftValues.length : rightValues.length;\n                // Continue animation from current position\n                animationRef.current.timer = setTimeout(()=>{\n                    if (animationRef.current.running && !animationRef.current.isPaused) {\n                        if (animationRef.current.currentIndex < currentSideLength - 1) {\n                            animationRef.current.currentIndex++;\n                        } else {\n                            // Switch sides or restart\n                            if (animationRef.current.currentSide === \"left\") {\n                                animationRef.current.currentSide = \"right\";\n                                animationRef.current.currentIndex = 0;\n                            } else {\n                                animationRef.current.currentSide = \"left\";\n                                animationRef.current.currentIndex = 0;\n                            }\n                        }\n                        restartMainAnimation();\n                    }\n                }, stepDuration);\n            };\n            restartMainAnimation();\n        }\n        // Resume secondary chord animation\n        if (secondaryAnimationRef.current.running && secondaryAnimationRef.current.isPaused) {\n            console.log(\"▶️ Resuming Secondary Chord animation:\", reason);\n            secondaryAnimationRef.current.isPaused = false;\n            // Restart the secondary animation timer immediately\n            const restartSecondaryAnimation = ()=>{\n                if (!secondaryAnimationRef.current.running || secondaryAnimationRef.current.isPaused) return;\n                console.log(\"\\uD83D\\uDD04 Restarting Secondary Chord animation after pause\");\n                // Get secondary chord data context\n                const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n                const secondaryData = filteredData.filter((d)=>d.peak_performance);\n                const yearsCategories = [\n                    \"0-5\",\n                    \"6-10\",\n                    \"11-15\",\n                    \"16-20\",\n                    \"20+\"\n                ];\n                const peakPerfCategories = Array.from(new Set(secondaryData.map((d)=>d.peak_performance))).filter(Boolean).sort();\n                // Calculate the actual arc index based on side and position\n                const actualArcIndex = secondaryAnimationRef.current.currentSide === \"left\" ? secondaryAnimationRef.current.currentIndex : yearsCategories.length + secondaryAnimationRef.current.currentIndex;\n                setSecondaryAnimationPhase(\"highlighting\");\n                setSecondaryHighlightedArcIndex(actualArcIndex);\n                setSecondaryHighlightedSide(secondaryAnimationRef.current.currentSide);\n                // Calculate timing based on global settings\n                const stepDuration = Math.max(1000, (settings.autoPlaySpeed || 3000) / 4);\n                const currentSideLength = secondaryAnimationRef.current.currentSide === \"left\" ? yearsCategories.length : peakPerfCategories.length;\n                // Continue animation from current position\n                secondaryAnimationRef.current.timer = setTimeout(()=>{\n                    if (secondaryAnimationRef.current.running && !secondaryAnimationRef.current.isPaused) {\n                        if (secondaryAnimationRef.current.currentIndex < currentSideLength - 1) {\n                            secondaryAnimationRef.current.currentIndex++;\n                        } else {\n                            // Switch sides or restart\n                            if (secondaryAnimationRef.current.currentSide === \"left\") {\n                                secondaryAnimationRef.current.currentSide = \"right\";\n                                secondaryAnimationRef.current.currentIndex = 0;\n                            } else {\n                                secondaryAnimationRef.current.currentSide = \"left\";\n                                secondaryAnimationRef.current.currentIndex = 0;\n                            }\n                        }\n                        restartSecondaryAnimation();\n                    }\n                }, stepDuration);\n            };\n            restartSecondaryAnimation();\n        }\n    }, [\n        settings.autoPlaySpeed,\n        settings.useTestData,\n        data,\n        currentSource,\n        currentTarget\n    ]);\n    // Check if container is too small\n    const margin = {\n        top: 80,\n        right: 80,\n        bottom: 100,\n        left: 80\n    };\n    const chartWidth = width - margin.left - margin.right;\n    const chartHeight = height - margin.top - margin.bottom;\n    const isContainerTooSmall = chartWidth < 200 || chartHeight < 200;\n    // Render circular chord diagram\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current || !data.length || isLoading || isContainerTooSmall) return;\n        // Clear previous content\n        d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current).selectAll(\"*\").remove();\n        // Filter data based on global settings\n        const filteredData = settings.useTestData ? data : data.filter((item)=>!item.test_data);\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        // Adjust size based on whether we're showing two chords\n        const effectiveWidth = showSecondaryChord ? width * 0.45 : width;\n        const effectiveHeight = showSecondaryChord ? height * 0.8 : height * 0.85;\n        const effectiveChartWidth = effectiveWidth - margin.left - margin.right;\n        const effectiveChartHeight = effectiveHeight - margin.top - margin.bottom;\n        const radius = Math.max(120, Math.min(effectiveChartWidth, effectiveChartHeight) / 2 - 60);\n        // Create definitions for gradients\n        const defs = svg.append(\"defs\");\n        // Define fixed order for years at Medtronic\n        const YEARS_GROUPS = [\n            \"0-5\",\n            \"6-10\",\n            \"11-15\",\n            \"16-20\",\n            \"20+\"\n        ];\n        // Get unique values for left and right sides, using fixed order for years\n        const leftValues = currentSource === \"years_at_medtronic\" ? YEARS_GROUPS : Array.from(new Set(filteredData.map((d)=>d[currentSource]))).filter(Boolean);\n        const rightValues = currentTarget === \"years_at_medtronic\" ? YEARS_GROUPS : Array.from(new Set(filteredData.map((d)=>d[currentTarget]))).filter(Boolean);\n        // Process data for chord layout\n        const chordData = (0,_shared_chordUtils__WEBPACK_IMPORTED_MODULE_5__.processChordData)(filteredData, currentSource, currentTarget);\n        // Separate source and target categories\n        const sourceCategories = new Set();\n        const targetCategories = new Set();\n        filteredData.forEach((d)=>{\n            if (currentSource === \"years_at_medtronic\") {\n                sourceCategories.add((0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0));\n            } else {\n                sourceCategories.add(d[currentSource] || \"Unknown\");\n            }\n            if (currentTarget === \"years_at_medtronic\") {\n                targetCategories.add((0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0));\n            } else {\n                targetCategories.add(d[currentTarget] || \"Unknown\");\n            }\n        });\n        // Convert to arrays and sort\n        const sourceArray = Array.from(sourceCategories).sort();\n        const targetArray = Array.from(targetCategories).sort();\n        // Calculate totals for each category\n        const leftTotals = sourceArray.map((cat)=>filteredData.filter((d)=>{\n                const value = currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentSource];\n                return value === cat;\n            }).length);\n        const rightTotals = targetArray.map((cat)=>filteredData.filter((d)=>{\n                const value = currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentTarget];\n                return value === cat;\n            }).length);\n        const leftTotalSum = leftTotals.reduce((sum, val)=>sum + val, 0);\n        const rightTotalSum = rightTotals.reduce((sum, val)=>sum + val, 0);\n        // Create connection matrix\n        const connectionMatrix = sourceArray.map((sourceCat)=>targetArray.map((targetCat)=>{\n                return filteredData.filter((d)=>{\n                    const source = currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentSource];\n                    const target = currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentTarget];\n                    return source === sourceCat && target === targetCat;\n                }).length;\n            }));\n        // Check if this is a category change that should trigger animation\n        const isCategoryChange = lastCategoryChange.source !== currentSource || lastCategoryChange.target !== currentTarget;\n        // Add smooth transitions for category changes\n        const transition = d3__WEBPACK_IMPORTED_MODULE_2__.transition().duration(isCategoryChange ? 750 : 200).ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut);\n        // Faster transition for hover interactions\n        const hoverTransition = d3__WEBPACK_IMPORTED_MODULE_2__.transition().duration(75).ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeQuadOut);\n        // --- True left/right bipartite layout with better spacing ---\n        // Left arcs: 180°+gap to 360°-gap (Math.PI+gap to 2*Math.PI-gap)\n        // Right arcs: 0+gap to 180°-gap (0+gap to Math.PI-gap)\n        const arcGap = Math.PI * 0.12; // Larger gap for better label spacing\n        const leftStart = Math.PI + arcGap; // 180° + gap\n        const leftEnd = 2 * Math.PI - arcGap; // 360° - gap\n        const rightStart = 0 + arcGap; // 0° + gap\n        const rightEnd = Math.PI - arcGap; // 180° - gap\n        const leftArcSpan = leftEnd - leftStart; // 180° - 2*gap\n        const rightArcSpan = rightEnd - rightStart; // 180° - 2*gap\n        // Add minimum spacing between arcs to prevent label overlap\n        const minArcSpacing = Math.PI * 0.02; // Minimum 2° between arcs\n        // Assign arc angles for left arcs with proper spacing\n        let leftAngle = leftStart;\n        const leftArcs = leftValues.map((value, i)=>{\n            const count = filteredData.filter((d)=>currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) === value : d[currentSource] === value).length;\n            // Calculate arc span with spacing consideration\n            const availableSpan = leftArcSpan - minArcSpacing * (leftValues.length - 1);\n            const arcSpan = currentSource === \"years_at_medtronic\" ? availableSpan / leftValues.length : Math.max(minArcSpacing, availableSpan * (count / (leftTotalSum || 1)));\n            const startAngle = leftAngle;\n            const endAngle = leftAngle + arcSpan;\n            leftAngle = endAngle + minArcSpacing; // Add spacing between arcs\n            const color = getNodeColor(value, currentSource, settings.categoryColors, settings.isDarkMode);\n            const opacity = count === 0 ? 0.15 : 0.8;\n            return {\n                name: value,\n                value: count,\n                startAngle,\n                endAngle,\n                color,\n                opacity\n            };\n        });\n        // Assign arc angles for right arcs with proper spacing\n        let rightAngle = rightStart;\n        const rightArcs = rightValues.map((value, i)=>{\n            const count = filteredData.filter((d)=>currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_8__.getYearsCategory)(d.years_at_medtronic || 0) === value : d[currentTarget] === value).length;\n            // Calculate arc span with spacing consideration\n            const availableSpan = rightArcSpan - minArcSpacing * (rightValues.length - 1);\n            const arcSpan = currentTarget === \"years_at_medtronic\" ? availableSpan / rightValues.length : Math.max(minArcSpacing, availableSpan * (count / (rightTotalSum || 1)));\n            const startAngle = rightAngle;\n            const endAngle = rightAngle + arcSpan;\n            rightAngle = endAngle + minArcSpacing; // Add spacing between arcs\n            const color = getNodeColor(value, currentTarget, settings.categoryColors, settings.isDarkMode);\n            const opacity = count === 0 ? 0.15 : 0.8;\n            return {\n                name: value,\n                value: count,\n                startAngle,\n                endAngle,\n                color,\n                opacity\n            };\n        });\n        // Draw arcs (use per-arc opacity)\n        const innerRadius = Math.max(60, radius * 0.75);\n        const outerRadius = Math.max(80, radius * 0.95);\n        const arcGen = d3__WEBPACK_IMPORTED_MODULE_2__.arc().innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius((d)=>{\n            // Only round the outer corners (outerRadius), not the inner\n            // D3 v7+ supports cornerRadius as a function\n            // We'll return 0 for inner, 8 for outer\n            // But d3.arc() only supports one value, so we need to use custom path if we want true squared inner corners\n            // As a workaround, set cornerRadius to 0 if the arc is small, else 8\n            return 0;\n        });\n        // Position the chart group with margins to prevent cropping\n        const g = svg.append(\"g\").attr(\"transform\", \"translate(\".concat(margin.left + effectiveChartWidth / 2, \", \").concat(margin.top + effectiveChartHeight / 2, \")\"));\n        // Add gradients for arcs\n        leftArcs.forEach((arc, i)=>{\n            var _d3_color;\n            const baseColor = arc.color;\n            const lighterColor = ((_d3_color = d3__WEBPACK_IMPORTED_MODULE_2__.color(baseColor)) === null || _d3_color === void 0 ? void 0 : _d3_color.brighter(0.3).toString()) || baseColor;\n            defs.append(\"linearGradient\").attr(\"id\", \"left-arc-gradient-\".concat(i)).attr(\"gradientUnits\", \"userSpaceOnUse\").attr(\"x1\", 0).attr(\"y1\", 0).attr(\"x2\", 0).attr(\"y2\", 1).selectAll(\"stop\").data([\n                {\n                    offset: \"0%\",\n                    color: baseColor\n                },\n                {\n                    offset: \"100%\",\n                    color: lighterColor\n                }\n            ]).enter().append(\"stop\").attr(\"offset\", (d)=>d.offset).attr(\"stop-color\", (d)=>d.color);\n        });\n        rightArcs.forEach((arc, i)=>{\n            var _d3_color;\n            const baseColor = arc.color;\n            const lighterColor = ((_d3_color = d3__WEBPACK_IMPORTED_MODULE_2__.color(baseColor)) === null || _d3_color === void 0 ? void 0 : _d3_color.brighter(0.3).toString()) || baseColor;\n            defs.append(\"linearGradient\").attr(\"id\", \"right-arc-gradient-\".concat(i)).attr(\"gradientUnits\", \"userSpaceOnUse\").attr(\"x1\", 0).attr(\"y1\", 0).attr(\"x2\", 0).attr(\"y2\", 1).selectAll(\"stop\").data([\n                {\n                    offset: \"0%\",\n                    color: baseColor\n                },\n                {\n                    offset: \"100%\",\n                    color: lighterColor\n                }\n            ]).enter().append(\"stop\").attr(\"offset\", (d)=>d.offset).attr(\"stop-color\", (d)=>d.color);\n        });\n        // Create left arcs with event handlers first\n        const leftArcSelection = g.selectAll(\"path.left-arc\").data(leftArcs).enter().append(\"path\").attr(\"class\", \"left-arc\").attr(\"d\", (d)=>arcGen({\n                startAngle: d.startAngle,\n                endAngle: d.endAngle\n            })).attr(\"fill\", (d, i)=>\"url(#left-arc-gradient-\".concat(i, \")\")).attr(\"opacity\", 0).on(\"mouseenter\", function(event, d) {\n            if (d.value === 0) return;\n            pauseAnimation(\"left arc hover\");\n            // Trigger the same highlighting as auto-cycle animation\n            const arcIndex = leftArcs.findIndex((arc)=>arc.name === d.name);\n            setAnimationPhase(\"highlighting\");\n            setHighlightedArcIndex(arcIndex);\n            setHighlightedSide(\"left\");\n            // Apply immediate hover transitions\n            g.selectAll(\"path.left-arc, path.right-arc, path.ribbon\").transition(hoverTransition).attr(\"opacity\", function(hoverD) {\n                const element = d3__WEBPACK_IMPORTED_MODULE_2__.select(this);\n                if (element.classed(\"left-arc\")) {\n                    const i = leftArcs.findIndex((arc)=>arc.name === hoverD.name);\n                    return i === arcIndex ? 1.0 : 0.4;\n                } else if (element.classed(\"right-arc\")) {\n                    const i = rightArcs.findIndex((arc)=>arc.name === hoverD.name);\n                    const matrixValue = connectionMatrix[arcIndex] && connectionMatrix[arcIndex][i];\n                    return matrixValue > 0 ? 0.95 : 0.3;\n                } else if (element.classed(\"ribbon\")) {\n                    return hoverD.source.index === arcIndex ? 0.95 : 0.2;\n                }\n                return 0.3;\n            });\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: (d.name || \"Unknown\").toString().replace(/_/g, \" \")\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1336,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Count: \",\n                                d.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1337,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 1335,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", ()=>{\n            resumeAnimation(\"left arc hover end\");\n            setTooltip(null);\n            // Reset highlighting when animation resumes\n            setAnimationPhase(\"full\");\n            setHighlightedArcIndex(null);\n            setHighlightedSide(null);\n            // Apply immediate reset transitions\n            g.selectAll(\"path.left-arc, path.right-arc, path.ribbon\").transition(hoverTransition).attr(\"opacity\", function(resetD) {\n                const element = d3__WEBPACK_IMPORTED_MODULE_2__.select(this);\n                if (element.classed(\"left-arc\") || element.classed(\"right-arc\")) {\n                    return Math.max(0.8, resetD.opacity);\n                } else if (element.classed(\"ribbon\")) {\n                    return settings.isDarkMode ? 0.7 : 0.6;\n                }\n                return 0.8;\n            });\n        });\n        // Apply transition animations separately\n        leftArcSelection.transition(transition).attr(\"opacity\", (d, i)=>{\n            // Apply full relationship chain highlighting\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\") {\n                    // Highlight the source arc\n                    if (i === highlightedArcIndex) {\n                        return 1.0; // Source arc is fully highlighted\n                    }\n                    // Check if this arc is connected to the highlighted right arc\n                    if (highlightedSide === \"left\" && highlightedArcIndex !== null) {\n                        return 0.4; // Dim other left arcs\n                    }\n                } else if (highlightedSide === \"right\" && highlightedArcIndex !== null) {\n                    var _leftArcs_i, _rightArcs_highlightedArcIndex;\n                    // When right arc is highlighted, highlight left arcs connected to it\n                    const matrixValue = connectionMatrix[i] && connectionMatrix[i][highlightedArcIndex];\n                    const isConnectedToHighlightedRight = matrixValue > 0;\n                    console.log(\"\\uD83D\\uDD17 Left arc \".concat(i, \" (\").concat((_leftArcs_i = leftArcs[i]) === null || _leftArcs_i === void 0 ? void 0 : _leftArcs_i.name, \") connected to right arc \").concat(highlightedArcIndex, \" (\").concat((_rightArcs_highlightedArcIndex = rightArcs[highlightedArcIndex]) === null || _rightArcs_highlightedArcIndex === void 0 ? void 0 : _rightArcs_highlightedArcIndex.name, \")?\"), isConnectedToHighlightedRight, \"Matrix value:\", matrixValue);\n                    return isConnectedToHighlightedRight ? 0.95 : 0.3; // Higher contrast\n                }\n            }\n            // Use stable base opacity without pulsing to prevent flickering\n            return Math.max(0.8, d.opacity);\n        }).attr(\"stroke-width\", (d, i)=>{\n            // Enhanced stroke for relationship chain\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && i === highlightedArcIndex) {\n                    return 3; // Thickest stroke for source arc\n                }\n                // Stroke for connected arcs when right side is highlighted\n                if (highlightedSide === \"right\" && highlightedArcIndex !== null) {\n                    const matrixValue = connectionMatrix[i] && connectionMatrix[i][highlightedArcIndex];\n                    if (matrixValue > 0) {\n                        return 2; // Medium stroke for connected arcs\n                    }\n                }\n            }\n            return 1;\n        }).attr(\"stroke\", (d, i)=>{\n            // Enhanced stroke color for relationship chain\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && i === highlightedArcIndex) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n                // Stroke for connected arcs when right side is highlighted\n                if (highlightedSide === \"right\" && highlightedArcIndex !== null) {\n                    const matrixValue = connectionMatrix[i] && connectionMatrix[i][highlightedArcIndex];\n                    if (matrixValue > 0) {\n                        return settings.isDarkMode ? \"rgba(255,255,255,0.3)\" : \"rgba(0,0,0,0.2)\";\n                    }\n                }\n            }\n            return \"none\";\n        });\n        // Create right arcs with event handlers first\n        const rightArcSelection = g.selectAll(\"path.right-arc\").data(rightArcs).enter().append(\"path\").attr(\"class\", \"right-arc\").attr(\"d\", (d)=>arcGen({\n                startAngle: d.startAngle,\n                endAngle: d.endAngle\n            })).attr(\"fill\", (d, i)=>\"url(#right-arc-gradient-\".concat(i, \")\")).attr(\"opacity\", 0).on(\"mouseenter\", function(event, d) {\n            if (d.value === 0) return;\n            pauseAnimation(\"arc hover\");\n            // Trigger the same highlighting as auto-cycle animation\n            const arcIndex = rightArcs.findIndex((arc)=>arc.name === d.name);\n            console.log(\"\\uD83C\\uDFAF Hover triggering right arc highlighting:\", {\n                arcName: d.name,\n                arcIndex: arcIndex\n            });\n            setAnimationPhase(\"highlighting\");\n            setHighlightedArcIndex(arcIndex);\n            setHighlightedSide(\"right\");\n            // Apply immediate hover transitions\n            g.selectAll(\"path.left-arc, path.right-arc, path.ribbon\").transition(hoverTransition).attr(\"opacity\", function(hoverD) {\n                const element = d3__WEBPACK_IMPORTED_MODULE_2__.select(this);\n                if (element.classed(\"right-arc\")) {\n                    const i = rightArcs.findIndex((arc)=>arc.name === hoverD.name);\n                    return i === arcIndex ? 1.0 : 0.4;\n                } else if (element.classed(\"left-arc\")) {\n                    const i = leftArcs.findIndex((arc)=>arc.name === hoverD.name);\n                    const matrixValue = connectionMatrix[i] && connectionMatrix[i][arcIndex];\n                    return matrixValue > 0 ? 0.95 : 0.3;\n                } else if (element.classed(\"ribbon\")) {\n                    return hoverD.target.index === arcIndex ? 0.95 : 0.2;\n                }\n                return 0.3;\n            });\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: (d.name || \"Unknown\").toString().replace(/_/g, \" \")\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1471,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Count: \",\n                                d.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1472,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 1470,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", ()=>{\n            resumeAnimation(\"arc hover end\");\n            setTooltip(null);\n            // Reset highlighting when animation resumes\n            setAnimationPhase(\"full\");\n            setHighlightedArcIndex(null);\n            setHighlightedSide(null);\n            // Apply immediate reset transitions\n            g.selectAll(\"path.left-arc, path.right-arc, path.ribbon\").transition(hoverTransition).attr(\"opacity\", function(resetD) {\n                const element = d3__WEBPACK_IMPORTED_MODULE_2__.select(this);\n                if (element.classed(\"left-arc\") || element.classed(\"right-arc\")) {\n                    return Math.max(0.8, resetD.opacity);\n                } else if (element.classed(\"ribbon\")) {\n                    return settings.isDarkMode ? 0.7 : 0.6;\n                }\n                return 0.8;\n            });\n        });\n        // Apply transition animations separately\n        rightArcSelection.transition(transition).attr(\"opacity\", (d, i)=>{\n            // Apply full relationship chain highlighting\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\") {\n                    // Highlight the source arc\n                    if (i === highlightedArcIndex) {\n                        return 1.0; // Source arc is fully highlighted\n                    }\n                    return 0.4; // Dim other right arcs\n                } else if (highlightedSide === \"left\" && highlightedArcIndex !== null) {\n                    var _rightArcs_i, _leftArcs_highlightedArcIndex;\n                    // When left arc is highlighted, highlight right arcs connected to it\n                    const matrixValue = connectionMatrix[highlightedArcIndex] && connectionMatrix[highlightedArcIndex][i];\n                    const isConnectedToHighlightedLeft = matrixValue > 0;\n                    console.log(\"\\uD83D\\uDD17 Right arc \".concat(i, \" (\").concat((_rightArcs_i = rightArcs[i]) === null || _rightArcs_i === void 0 ? void 0 : _rightArcs_i.name, \") connected to left arc \").concat(highlightedArcIndex, \" (\").concat((_leftArcs_highlightedArcIndex = leftArcs[highlightedArcIndex]) === null || _leftArcs_highlightedArcIndex === void 0 ? void 0 : _leftArcs_highlightedArcIndex.name, \")?\"), isConnectedToHighlightedLeft, \"Matrix value:\", matrixValue);\n                    return isConnectedToHighlightedLeft ? 0.95 : 0.3; // Higher contrast\n                }\n            }\n            // Use stable base opacity without pulsing to prevent flickering\n            return Math.max(0.8, d.opacity);\n        }).attr(\"stroke-width\", (d, i)=>{\n            // Enhanced stroke for relationship chain\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\" && i === highlightedArcIndex) {\n                    return 3; // Thickest stroke for source arc\n                }\n                // Stroke for connected arcs when left side is highlighted\n                if (highlightedSide === \"left\" && highlightedArcIndex !== null) {\n                    const matrixValue = connectionMatrix[highlightedArcIndex] && connectionMatrix[highlightedArcIndex][i];\n                    if (matrixValue > 0) {\n                        return 2; // Medium stroke for connected arcs\n                    }\n                }\n            }\n            return 1;\n        }).attr(\"stroke\", (d, i)=>{\n            // Enhanced stroke color for relationship chain\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"right\" && i === highlightedArcIndex) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n                // Stroke for connected arcs when left side is highlighted\n                if (highlightedSide === \"left\" && highlightedArcIndex !== null) {\n                    const matrixValue = connectionMatrix[highlightedArcIndex] && connectionMatrix[highlightedArcIndex][i];\n                    if (matrixValue > 0) {\n                        return settings.isDarkMode ? \"rgba(255,255,255,0.3)\" : \"rgba(0,0,0,0.2)\";\n                    }\n                }\n            }\n            return \"none\";\n        });\n        // Draw ribbons for connections (distributed along arc, proportional thickness)\n        // Use d3.ribbon() for each connection, but set the width by using the full segment for each connection\n        const ribbonRadius = Math.max(60, radius * 0.75); // Ensure minimum radius for ribbons\n        const ribbonGen = d3__WEBPACK_IMPORTED_MODULE_2__.ribbon().radius(ribbonRadius);\n        const connections = [];\n        for(let i = 0; i < sourceArray.length; i++){\n            for(let j = 0; j < targetArray.length; j++){\n                const value = connectionMatrix[i][j];\n                if (value > 0) {\n                    // Find the segment for this connection on both arcs\n                    const leftSeg = leftArcs[i];\n                    const rightSeg = rightArcs[j];\n                    // Compute arc midpoints for gradient direction\n                    const leftMidAngle = (leftSeg.startAngle + leftSeg.endAngle) / 2 - Math.PI / 2;\n                    const rightMidAngle = (rightSeg.startAngle + rightSeg.endAngle) / 2 - Math.PI / 2;\n                    const leftX = Math.cos(leftMidAngle) * ribbonRadius;\n                    const leftY = Math.sin(leftMidAngle) * ribbonRadius;\n                    const rightX = Math.cos(rightMidAngle) * ribbonRadius;\n                    const rightY = Math.sin(rightMidAngle) * ribbonRadius;\n                    // Add gradient for this ribbon\n                    const leftColor = leftArcs[i].color || d3__WEBPACK_IMPORTED_MODULE_2__.schemeCategory10[i % 10];\n                    const rightColor = rightArcs[j].color || d3__WEBPACK_IMPORTED_MODULE_2__.schemeCategory10[(j + 5) % 10];\n                    defs.append(\"linearGradient\").attr(\"id\", \"ribbon-gradient-\".concat(i, \"-\").concat(j)).attr(\"gradientUnits\", \"userSpaceOnUse\").attr(\"x1\", leftX).attr(\"y1\", leftY).attr(\"x2\", rightX).attr(\"y2\", rightY).selectAll(\"stop\").data([\n                        {\n                            offset: \"0%\",\n                            color: leftColor\n                        },\n                        {\n                            offset: \"100%\",\n                            color: rightColor\n                        }\n                    ]).enter().append(\"stop\").attr(\"offset\", (d)=>d.offset).attr(\"stop-color\", (d)=>d.color);\n                    connections.push({\n                        source: {\n                            startAngle: leftSeg.startAngle,\n                            endAngle: leftSeg.endAngle,\n                            index: i\n                        },\n                        target: {\n                            startAngle: rightSeg.startAngle,\n                            endAngle: rightSeg.endAngle,\n                            index: j\n                        },\n                        value,\n                        left: leftArcs[i],\n                        right: rightArcs[j],\n                        gradientId: \"ribbon-gradient-\".concat(i, \"-\").concat(j)\n                    });\n                }\n            }\n        }\n        // Create ribbons with event handlers first\n        const ribbonSelection = g.selectAll(\"path.ribbon\").data(connections).enter().append(\"path\").attr(\"class\", \"ribbon\").attr(\"d\", function(d) {\n            const path = ribbonGen({\n                source: d.source,\n                target: d.target\n            });\n            return typeof path === \"string\" ? path : \"\";\n        }).attr(\"fill\", (d)=>\"url(#\".concat(d.gradientId, \")\")).attr(\"opacity\", 0).on(\"mouseenter\", function(event, d) {\n            pauseAnimation(\"ribbon hover\");\n            // Trigger highlighting for the source side of this ribbon (same as auto-cycle)\n            console.log(\"\\uD83C\\uDFAF Hover triggering ribbon highlighting:\", {\n                leftArcName: d.left.name,\n                rightArcName: d.right.name,\n                sourceIndex: d.source.index,\n                targetIndex: d.target.index\n            });\n            setAnimationPhase(\"highlighting\");\n            setHighlightedArcIndex(d.source.index);\n            setHighlightedSide(\"left\");\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: [\n                                (d.left.name || \"Unknown\").toString().replace(/_/g, \" \"),\n                                \" ↔ \",\n                                (d.right.name || \"Unknown\").toString().replace(/_/g, \" \")\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1643,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Connections: \",\n                                d.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1646,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 1642,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", function(event, d) {\n            resumeAnimation(\"ribbon hover end\");\n            setTooltip(null);\n            // Reset highlighting when animation resumes\n            setAnimationPhase(\"full\");\n            setHighlightedArcIndex(null);\n            setHighlightedSide(null);\n        });\n        // Apply transition animations separately\n        ribbonSelection.transition(transition).attr(\"opacity\", (d)=>{\n            // Highlight ribbons connected to highlighted arcs with enhanced visibility\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                if (highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return 0.95; // Make connected ribbons very prominent\n                }\n                return 0.2; // Dim non-connected ribbons more for better contrast\n            }\n            // Use stable base opacity without pulsing\n            return settings.isDarkMode ? 0.7 : 0.6;\n        }).attr(\"stroke-width\", (d)=>{\n            // Enhanced stroke for highlighted ribbons to show connections clearly\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index || highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return 2.5; // Slightly thicker for better visibility\n                }\n            }\n            return 0.5;\n        }).attr(\"stroke\", (d)=>{\n            // Enhanced stroke color for highlighted connections\n            if (animationPhase === \"highlighting\") {\n                if (highlightedSide === \"left\" && highlightedArcIndex === d.source.index || highlightedSide === \"right\" && highlightedArcIndex === d.target.index) {\n                    return settings.isDarkMode ? \"rgba(255,255,255,0.4)\" : \"rgba(0,0,0,0.3)\";\n                }\n            }\n            return \"none\";\n        });\n        // --- Label placement: properly spaced around circle ---\n        const labelRadius = Math.max(120, radius * 1.45); // Even more space for full text labels\n        const labelGroup = svg.append(\"g\").attr(\"transform\", \"translate(\".concat(margin.left + effectiveChartWidth / 2, \", \").concat(margin.top + effectiveChartHeight / 2, \")\"));\n        // Combine all arcs for unified label placement\n        const allArcs = [\n            ...leftArcs.map((arc)=>({\n                    ...arc,\n                    side: \"left\"\n                })),\n            ...rightArcs.map((arc)=>({\n                    ...arc,\n                    side: \"right\"\n                }))\n        ];\n        // Add labels with smart positioning to avoid overlap\n        labelGroup.selectAll(\"text.arc-label\").data(allArcs).enter().append(\"text\").attr(\"class\", \"arc-label\").attr(\"transform\", (d)=>{\n            const angle = (d.startAngle + d.endAngle) / 2 - Math.PI / 2;\n            const x = labelRadius * Math.cos(angle);\n            const y = labelRadius * Math.sin(angle);\n            const rotation = angle * 180 / Math.PI;\n            // Rotate text for better readability\n            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {\n                return \"translate(\".concat(x, \", \").concat(y, \") rotate(\").concat(rotation + 180, \")\");\n            } else {\n                return \"translate(\".concat(x, \", \").concat(y, \") rotate(\").concat(rotation, \")\");\n            }\n        }).attr(\"text-anchor\", (d)=>{\n            const angle = (d.startAngle + d.endAngle) / 2 - Math.PI / 2;\n            if (angle > Math.PI / 2 || angle < -Math.PI / 2) {\n                return \"end\";\n            } else {\n                return \"start\";\n            }\n        }).attr(\"alignment-baseline\", \"middle\").style(\"font-family\", labelFontFamily).style(\"font-weight\", labelFontWeight).style(\"font-size\", (d)=>{\n            // Dynamic font size based on number of labels - larger since we're showing full text\n            const totalLabels = allArcs.length;\n            if (totalLabels > 12) return \"13px\";\n            if (totalLabels > 10) return \"14px\";\n            if (totalLabels > 8) return \"15px\";\n            return \"\".concat(Math.max(16, labelFontSize), \"px\");\n        }).style(\"fill\", labelColor).style(\"text-transform\", \"uppercase\").text((d)=>{\n            const text = (d.name || \"Unknown\").toString().replace(/_/g, \" \");\n            // Show full text - no truncation\n            return text;\n        }).on(\"mouseenter\", function(event, d) {\n            pauseAnimation(\"label hover\");\n            const fullText = (d.name || \"Unknown\").toString().replace(/_/g, \" \");\n            setTooltip({\n                x: event.pageX,\n                y: event.pageY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                fontWeight: \"bold\",\n                                marginBottom: 4\n                            },\n                            children: fullText\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1759,\n                            columnNumber: 16\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Count: \",\n                                d.value\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1760,\n                            columnNumber: 16\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                \"Side: \",\n                                d.side\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1761,\n                            columnNumber: 16\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                    lineNumber: 1758,\n                    columnNumber: 14\n                }, this)\n            });\n        }).on(\"mouseleave\", ()=>{\n            resumeAnimation(\"label hover end\");\n            setTooltip(null);\n        });\n        // Update insights\n        const totalConnections = connections.reduce((sum, d)=>sum + d.value, 0);\n        const strongestConnection = connections.length > 0 ? connections.reduce((max, d)=>d.value > max.value ? d : max, connections[0]) : null;\n        setInsights([\n            {\n                title: \"Total Responses\",\n                value: filteredData.length.toString()\n            },\n            {\n                title: \"Current View\",\n                value: \"\".concat(currentSource, \" ↔ \").concat(currentTarget)\n            },\n            strongestConnection ? {\n                title: \"Strongest Connection\",\n                value: \"\".concat(strongestConnection.left.name || \"Unknown\", \" ↔ \").concat(strongestConnection.right.name || \"Unknown\"),\n                description: \"\".concat(strongestConnection.value, \" connections\")\n            } : {\n                title: \"Strongest Connection\",\n                value: \"No connections found\",\n                description: \"\"\n            },\n            {\n                title: \"Total Connections\",\n                value: totalConnections.toString()\n            }\n        ]);\n    }, [\n        data,\n        currentSource,\n        currentTarget,\n        settings.useTestData,\n        settings.categoryColors,\n        isLoading,\n        lastCategoryChange,\n        isContainerTooSmall,\n        chartWidth,\n        chartHeight,\n        showSecondaryChord,\n        settings.isDarkMode\n    ]);\n    // Render secondary chord when peak performance is involved\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (showSecondaryChord) {\n            renderSecondaryChord();\n        }\n    }, [\n        showSecondaryChord,\n        data,\n        settings.useTestData,\n        settings.isDarkMode,\n        labelColor\n    ]);\n    // Tooltip rendering\n    const tooltipEl = tooltip ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: \"absolute\",\n            left: tooltip.x + 16,\n            top: tooltip.y + 16,\n            background: \"rgba(20,20,30,0.98)\",\n            color: \"#fff\",\n            padding: \"10px 16px\",\n            borderRadius: 8,\n            pointerEvents: \"none\",\n            zIndex: 100,\n            fontFamily: \"Avenir Next World, sans-serif\",\n            fontWeight: 600,\n            fontSize: 16,\n            boxShadow: \"0 4px 24px 0 rgba(16, 16, 235, 0.12)\",\n            maxWidth: 320\n        },\n        role: \"tooltip\",\n        \"aria-live\": \"polite\",\n        children: tooltip.content\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n        lineNumber: 1800,\n        columnNumber: 5\n    }, this) : null;\n    // Apply theme based on global settings\n    const themeClass = settings.isDarkMode ? \"dark\" : \"\";\n    const backgroundColor = settings.isDarkMode ? \"#1a1a1a\" : \"#ffffff\";\n    const textColor = settings.isDarkMode ? \"#ffffff\" : \"#0A0A0F\";\n    // Handle case where container is too small\n    if (isContainerTooSmall) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"w-full h-full flex items-center justify-center \".concat(themeClass),\n            style: {\n                backgroundColor\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-center\",\n                style: {\n                    color: textColor\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-lg mb-2\",\n                        children: \"Container too small\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                        lineNumber: 1834,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-sm opacity-70\",\n                        children: \"Minimum size: 200x200px\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                        lineNumber: 1835,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                lineNumber: 1833,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n            lineNumber: 1832,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full h-full flex flex-col items-center justify-center \".concat(themeClass),\n        style: {\n            backgroundColor\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_shared_GlobalControlsNav__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                lineNumber: 1843,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full h-full flex flex-col items-center justify-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full flex flex-col items-center justify-center mb-4\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_shared_QuestionSelector__WEBPACK_IMPORTED_MODULE_4__.QuestionSelector, {\n                            availableFields: availableFields,\n                            currentSource: currentSource,\n                            currentTarget: currentTarget,\n                            onChange: (source, target)=>{\n                                const corrected = ensureDifferentCategories(source, target);\n                                setCurrentSource(corrected.source);\n                                setCurrentTarget(corrected.target);\n                                setLastCategoryChange(corrected);\n                            }\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                            lineNumber: 1846,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                        lineNumber: 1845,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full flex justify-center items-center relative\",\n                        style: {\n                            height: height * 0.85\n                        },\n                        children: [\n                            showSecondaryChord ? // Two-chord layout when peak performance is involved\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-full flex justify-center items-center gap-16\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex flex-col items-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                className: \"text-lg font-bold mb-4\",\n                                                style: {\n                                                    color: textColor\n                                                },\n                                                children: \"Main Relationships\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                                lineNumber: 1866,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                                ref: svgRef,\n                                                width: width * 0.45,\n                                                height: height * 0.8,\n                                                style: {\n                                                    display: \"block\",\n                                                    background: \"transparent\",\n                                                    color: textColor\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                                lineNumber: 1869,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                        lineNumber: 1865,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex flex-col items-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                className: \"text-lg font-bold mb-4\",\n                                                style: {\n                                                    color: textColor\n                                                },\n                                                children: \"Years \\xd7 Performance Types\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                                lineNumber: 1877,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                                ref: secondarySvgRef,\n                                                width: width * 0.45,\n                                                height: height * 0.8,\n                                                style: {\n                                                    display: \"block\",\n                                                    background: \"transparent\",\n                                                    color: textColor\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                                lineNumber: 1880,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                        lineNumber: 1876,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                lineNumber: 1864,\n                                columnNumber: 13\n                            }, this) : // Single chord layout when peak performance is not involved\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                ref: svgRef,\n                                width: width,\n                                height: height * 0.85,\n                                style: {\n                                    display: \"block\",\n                                    margin: \"0 auto\",\n                                    background: \"transparent\",\n                                    color: textColor\n                                }\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                                lineNumber: 1890,\n                                columnNumber: 13\n                            }, this),\n                            tooltipEl\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                        lineNumber: 1858,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n                lineNumber: 1844,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\ChordDiagram.tsx\",\n        lineNumber: 1842,\n        columnNumber: 5\n    }, this);\n}\n_s(ChordDiagram, \"PRY4Nrx3/+HD/tvlaYz0Z7rlZnY=\", false, function() {\n    return [\n        _shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_3__.useVisualizationData,\n        _lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__.useAppContext\n    ];\n});\n_c = ChordDiagram;\nvar _c;\n$RefreshReg$(_c, \"ChordDiagram\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0RhdGFWaXN1YWxpemF0aW9uL0Nob3JkRGlhZ3JhbS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUV3RTtBQUMvQztBQUU0QztBQUdSO0FBV2hDO0FBQzRCO0FBQ2E7QUFDZjtBQVd2RCxvRUFBb0U7QUFDcEUsU0FBU2EsYUFBYUMsUUFBZ0IsRUFBRUMsUUFBZ0IsRUFBRUMsWUFBaUI7UUFBRUMsYUFBQUEsaUVBQXNCO0lBQ2pHLE1BQU1DLGNBQWNELGFBQWFELGFBQWFHLElBQUksR0FBR0gsYUFBYUksS0FBSztJQUV2RSxJQUFJTCxhQUFhLHNCQUFzQjtZQUM5Qkc7UUFBUCxPQUFPQSxFQUFBQSxrQ0FBQUEsWUFBWUcsa0JBQWtCLGNBQTlCSCxzREFBQUEsK0JBQWdDLENBQUNKLFNBQVMsS0FBSTtJQUN2RDtJQUVBLGlFQUFpRTtJQUNqRSxJQUFJQyxhQUFhLGtCQUFrQjtZQUMxQkc7UUFBUCxPQUFPQSxFQUFBQSw4QkFBQUEsWUFBWUksY0FBYyxjQUExQkosa0RBQUFBLDJCQUE0QixDQUFDSixTQUFTLEtBQUk7SUFDbkQ7SUFDQSxJQUFJQyxhQUFhLG9CQUFvQjtZQUM1Qkc7UUFBUCxPQUFPQSxFQUFBQSxnQ0FBQUEsWUFBWUssZ0JBQWdCLGNBQTVCTCxvREFBQUEsNkJBQThCLENBQUNKLFNBQVMsS0FBSTtJQUNyRDtJQUNBLElBQUlDLGFBQWEsY0FBYztZQUN0Qkc7UUFBUCxPQUFPQSxFQUFBQSwwQkFBQUEsWUFBWU0sVUFBVSxjQUF0Qk4sOENBQUFBLHVCQUF3QixDQUFDSixTQUFTLEtBQUk7SUFDL0M7SUFDQSxJQUFJQyxhQUFhLGFBQWE7WUFDckJHO1FBQVAsT0FBT0EsRUFBQUEseUJBQUFBLFlBQVlPLFNBQVMsY0FBckJQLDZDQUFBQSxzQkFBdUIsQ0FBQ0osU0FBUyxLQUFJO0lBQzlDO0lBQ0EsT0FBTztBQUNUO0FBRWUsU0FBU1ksYUFBYSxLQU9qQjtRQVBpQixFQUNu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NUs7d0NBQUk2SyxXQUFVOzswREFDYiw4REFBQ0c7Z0RBQUdILFdBQVU7Z0RBQXlCM0wsT0FBTztvREFBRXdILE9BQU9rRTtnREFBVTswREFBRzs7Ozs7OzBEQUdwRSw4REFBQ3pQO2dEQUNDOFAsS0FBS2pUO2dEQUNMUCxPQUFPQSxRQUFRO2dEQUNmQyxRQUFRQSxTQUFTO2dEQUNqQndILE9BQU87b0RBQUVnTSxTQUFTO29EQUFTbkIsWUFBWTtvREFBZXJELE9BQU9rRTtnREFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7dUNBSzdFLDREQUE0RDswQ0FDNUQsOERBQUN6UDtnQ0FDQzhQLEtBQUtsVDtnQ0FDTE4sT0FBT0E7Z0NBQ1BDLFFBQVFBLFNBQVM7Z0NBQ2pCd0gsT0FBTztvQ0FBRWdNLFNBQVM7b0NBQVNySCxRQUFRO29DQUFVa0csWUFBWTtvQ0FBZXJELE9BQU9rRTtnQ0FBVTs7Ozs7OzRCQUc1RmY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLWDtHQXB6RHdCclM7O1FBVWFwQiw4RUFBb0JBO1FBS2xDSSxrRUFBYUE7OztLQWZaZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvRGF0YVZpc3VhbGl6YXRpb24vQ2hvcmREaWFncmFtLnRzeD82ZDZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgeyBhcmMgfSBmcm9tICdkMy1zaGFwZSc7XG5pbXBvcnQgeyB1c2VWaXN1YWxpemF0aW9uRGF0YSB9IGZyb20gJy4vc2hhcmVkL3VzZVZpc3VhbGl6YXRpb25EYXRhJztcbmltcG9ydCB7IFZpc3VhbGl6YXRpb25Db250YWluZXIgfSBmcm9tICcuL3NoYXJlZC9WaXN1YWxpemF0aW9uQ29udGFpbmVyJztcbmltcG9ydCB7IERhdGFJbnNpZ2h0UGFuZWwgfSBmcm9tICcuL3NoYXJlZC9EYXRhSW5zaWdodFBhbmVsJztcbmltcG9ydCB7IFF1ZXN0aW9uU2VsZWN0b3IgfSBmcm9tICcuL3NoYXJlZC9RdWVzdGlvblNlbGVjdG9yJztcbmltcG9ydCB7IFxuICBwcm9jZXNzQ2hvcmREYXRhLCBcbiAgY2hvcmRDb25maWcsIFxuICBjeWNsaW5nTW9kZXMsIFxuICBnZXRDaG9yZENvbG9yLFxuICBjaG9yZEFuaW1hdGlvbnMsXG4gIGZpbHRlckNvbm5lY3RlZENhdGVnb3JpZXMsXG4gIHR5cGUgQ2hvcmRNYXRyaXgsXG4gIHR5cGUgQ2hvcmRHcm91cCxcbiAgdHlwZSBDaG9yZExpbmtcbn0gZnJvbSAnLi9zaGFyZWQvY2hvcmRVdGlscyc7XG5pbXBvcnQgeyB1c2VBcHBDb250ZXh0IH0gZnJvbSAnQC9saWIvY29udGV4dC9BcHBDb250ZXh0JztcbmltcG9ydCBHbG9iYWxDb250cm9sc05hdiBmcm9tICdAL2NvbXBvbmVudHMvc2hhcmVkL0dsb2JhbENvbnRyb2xzTmF2JztcbmltcG9ydCB7IGdldFllYXJzQ2F0ZWdvcnkgfSBmcm9tICcuL3NoYXJlZC9jb2xvclV0aWxzJztcblxuaW50ZXJmYWNlIENob3JkRGlhZ3JhbVByb3BzIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgYXV0b1BsYXk/OiBib29sZWFuO1xuICBvblJlbGF0aW9uc2hpcENoYW5nZT86IChzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpID0+IHZvaWQ7XG4gIGVuYWJsZVJvdGF0aW9uPzogYm9vbGVhbjtcbiAgc2hvd0FsbENvbm5lY3Rpb25zPzogYm9vbGVhbjtcbn1cblxuLy8gSGVscGVyIHRvIGdldCBjb2xvciBmb3IgYSBub2RlIHVzaW5nIGdsb2JhbCBjb250ZXh0ICh0aGVtZS1hd2FyZSlcbmZ1bmN0aW9uIGdldE5vZGVDb2xvcihub2RlTmFtZTogc3RyaW5nLCBjYXRlZ29yeTogc3RyaW5nLCBnbG9iYWxDb2xvcnM6IGFueSwgaXNEYXJrTW9kZTogYm9vbGVhbiA9IGZhbHNlKTogc3RyaW5nIHtcbiAgY29uc3QgdGhlbWVDb2xvcnMgPSBpc0RhcmtNb2RlID8gZ2xvYmFsQ29sb3JzLmRhcmsgOiBnbG9iYWxDb2xvcnMubGlnaHQ7XG4gIFxuICBpZiAoY2F0ZWdvcnkgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgcmV0dXJuIHRoZW1lQ29sb3JzLnllYXJzX2F0X21lZHRyb25pYz8uW25vZGVOYW1lXSB8fCAnI0ZGNkI2Qic7XG4gIH1cbiAgXG4gIC8vIFVzZSBnbG9iYWwgY29sb3JzIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGRlZmF1bHRzXG4gIGlmIChjYXRlZ29yeSA9PT0gJ2xlYXJuaW5nX3N0eWxlJykge1xuICAgIHJldHVybiB0aGVtZUNvbG9ycy5sZWFybmluZ19zdHlsZT8uW25vZGVOYW1lXSB8fCAnIzYwYTVmYSc7XG4gIH1cbiAgaWYgKGNhdGVnb3J5ID09PSAncGVha19wZXJmb3JtYW5jZScpIHtcbiAgICByZXR1cm4gdGhlbWVDb2xvcnMucGVha19wZXJmb3JtYW5jZT8uW25vZGVOYW1lXSB8fCAnIzRGOEVGNyc7XG4gIH1cbiAgaWYgKGNhdGVnb3J5ID09PSAnbW90aXZhdGlvbicpIHtcbiAgICByZXR1cm4gdGhlbWVDb2xvcnMubW90aXZhdGlvbj8uW25vZGVOYW1lXSB8fCAnIzk0NjdiZCc7XG4gIH1cbiAgaWYgKGNhdGVnb3J5ID09PSAnc2hhcGVkX2J5Jykge1xuICAgIHJldHVybiB0aGVtZUNvbG9ycy5zaGFwZWRfYnk/Lltub2RlTmFtZV0gfHwgJyMxZjc3YjQnO1xuICB9XG4gIHJldHVybiAnIzg4ODRkOCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENob3JkRGlhZ3JhbSh7XG4gIHdpZHRoID0gMTQwMCxcbiAgaGVpZ2h0ID0gMTAwMCxcbiAgYXV0b1BsYXkgPSB0cnVlLFxuICBvblJlbGF0aW9uc2hpcENoYW5nZSxcbiAgZW5hYmxlUm90YXRpb24gPSB0cnVlLFxuICBzaG93QWxsQ29ubmVjdGlvbnMgPSBmYWxzZSxcbn06IENob3JkRGlhZ3JhbVByb3BzKSB7XG4gIGNvbnN0IHN2Z1JlZiA9IHVzZVJlZjxTVkdTVkdFbGVtZW50PihudWxsKTtcbiAgY29uc3Qgc2Vjb25kYXJ5U3ZnUmVmID0gdXNlUmVmPFNWR1NWR0VsZW1lbnQ+KG51bGwpO1xuICBjb25zdCB7IGRhdGEsIGlzTG9hZGluZywgZXJyb3IgfSA9IHVzZVZpc3VhbGl6YXRpb25EYXRhKCk7XG4gIGNvbnN0IFtjdXJyZW50U291cmNlLCBzZXRDdXJyZW50U291cmNlXSA9IHVzZVN0YXRlKCd5ZWFyc19hdF9tZWR0cm9uaWMnKTtcbiAgY29uc3QgW2N1cnJlbnRUYXJnZXQsIHNldEN1cnJlbnRUYXJnZXRdID0gdXNlU3RhdGUoJ2xlYXJuaW5nX3N0eWxlJyk7XG4gIGNvbnN0IFtpbnNpZ2h0cywgc2V0SW5zaWdodHNdID0gdXNlU3RhdGU8QXJyYXk8eyB0aXRsZTogc3RyaW5nOyB2YWx1ZTogc3RyaW5nOyBkZXNjcmlwdGlvbj86IHN0cmluZyB9Pj4oW10pO1xuICBjb25zdCBbdG9vbHRpcCwgc2V0VG9vbHRpcF0gPSB1c2VTdGF0ZTx7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBjb250ZW50OiBSZWFjdC5SZWFjdE5vZGUgfSB8IG51bGw+KG51bGwpO1xuICBjb25zdCB7IHNldHRpbmdzIH0gPSB1c2VBcHBDb250ZXh0KCk7XG4gIGNvbnN0IFtsYXN0Q2F0ZWdvcnlDaGFuZ2UsIHNldExhc3RDYXRlZ29yeUNoYW5nZV0gPSB1c2VTdGF0ZTx7IHNvdXJjZTogc3RyaW5nOyB0YXJnZXQ6IHN0cmluZyB9Pih7IHNvdXJjZTogY3VycmVudFNvdXJjZSwgdGFyZ2V0OiBjdXJyZW50VGFyZ2V0IH0pO1xuICBjb25zdCBbc2hvd1NlY29uZGFyeUNob3JkLCBzZXRTaG93U2Vjb25kYXJ5Q2hvcmRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gQW5pbWF0aW9uIHN0YXRlIG1hbmFnZW1lbnQgKHNpbWlsYXIgdG8gQWxsdXZpYWxEaWFncmFtKVxuICBjb25zdCBbYW5pbWF0aW9uUGhhc2UsIHNldEFuaW1hdGlvblBoYXNlXSA9IHVzZVN0YXRlPCdmdWxsJyB8ICdoaWdobGlnaHRpbmcnIHwgJ3RyYW5zaXRpb25pbmcnPignZnVsbCcpO1xuICBjb25zdCBbaGlnaGxpZ2h0ZWRBcmNJbmRleCwgc2V0SGlnaGxpZ2h0ZWRBcmNJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2hpZ2hsaWdodGVkU2lkZSwgc2V0SGlnaGxpZ2h0ZWRTaWRlXSA9IHVzZVN0YXRlPCdsZWZ0JyB8ICdyaWdodCcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzQW5pbWF0aW5nLCBzZXRJc0FuaW1hdGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgXG4gIC8vIFNlY29uZGFyeSBjaG9yZCBhbmltYXRpb24gc3RhdGVcbiAgY29uc3QgW3NlY29uZGFyeUFuaW1hdGlvblBoYXNlLCBzZXRTZWNvbmRhcnlBbmltYXRpb25QaGFzZV0gPSB1c2VTdGF0ZTwnZnVsbCcgfCAnaGlnaGxpZ2h0aW5nJyB8ICd0cmFuc2l0aW9uaW5nJz4oJ2Z1bGwnKTtcbiAgY29uc3QgW3NlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXgsIHNldFNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzZWNvbmRhcnlIaWdobGlnaHRlZFNpZGUsIHNldFNlY29uZGFyeUhpZ2hsaWdodGVkU2lkZV0gPSB1c2VTdGF0ZTwnbGVmdCcgfCAncmlnaHQnIHwgbnVsbD4obnVsbCk7XG4gIFxuICAvLyBBbmltYXRpb24gdGltaW5nIHJlZlxuICBjb25zdCBhbmltYXRpb25SZWYgPSB1c2VSZWY8e1xuICAgIHRpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGw7XG4gICAgcnVubmluZzogYm9vbGVhbjtcbiAgICBjdXJyZW50SW5kZXg6IG51bWJlcjtcbiAgICBjdXJyZW50U2lkZTogJ2xlZnQnIHwgJ3JpZ2h0JztcbiAgICBpc1BhdXNlZDogYm9vbGVhbjtcbiAgfT4oe1xuICAgIHRpbWVyOiBudWxsLFxuICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgIGN1cnJlbnRJbmRleDogMCxcbiAgICBjdXJyZW50U2lkZTogJ2xlZnQnLFxuICAgIGlzUGF1c2VkOiBmYWxzZVxuICB9KTtcblxuICAvLyBTZWNvbmRhcnkgY2hvcmQgYW5pbWF0aW9uIHRpbWluZyByZWZcbiAgY29uc3Qgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmID0gdXNlUmVmPHtcbiAgICB0aW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsO1xuICAgIHJ1bm5pbmc6IGJvb2xlYW47XG4gICAgY3VycmVudEluZGV4OiBudW1iZXI7XG4gICAgY3VycmVudFNpZGU6ICdsZWZ0JyB8ICdyaWdodCc7XG4gICAgaXNQYXVzZWQ6IGJvb2xlYW47XG4gIH0+KHtcbiAgICB0aW1lcjogbnVsbCxcbiAgICBydW5uaW5nOiBmYWxzZSxcbiAgICBjdXJyZW50SW5kZXg6IDAsXG4gICAgY3VycmVudFNpZGU6ICdsZWZ0JyxcbiAgICBpc1BhdXNlZDogZmFsc2VcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGF2YWlsYWJsZSBmaWVsZHMgZm9yIHRoZSBzZWxlY3RvclxuICBjb25zdCBhdmFpbGFibGVGaWVsZHMgPSBbXG4gICAgeyB2YWx1ZTogJ3llYXJzX2F0X21lZHRyb25pYycsIGxhYmVsOiAnWWVhcnMgYXQgTWVkdHJvbmljJyB9LFxuICAgIHsgdmFsdWU6ICdwZWFrX3BlcmZvcm1hbmNlJywgbGFiZWw6ICdQZWFrIFBlcmZvcm1hbmNlJyB9LFxuICAgIHsgdmFsdWU6ICdsZWFybmluZ19zdHlsZScsIGxhYmVsOiAnTGVhcm5pbmcgU3R5bGUnIH0sXG4gICAgeyB2YWx1ZTogJ21vdGl2YXRpb24nLCBsYWJlbDogJ01vdGl2YXRpb24nIH0sXG4gICAgeyB2YWx1ZTogJ3NoYXBlZF9ieScsIGxhYmVsOiAnU2hhcGVkIEJ5JyB9XG4gIF07XG5cbiAgLy8gVHlwb2dyYXBoeSBjb25zdGFudHMgKHRoZW1lLWF3YXJlKVxuICBjb25zdCBsYWJlbEZvbnRTaXplID0gMjA7XG4gIGNvbnN0IGxhYmVsRm9udFdlaWdodCA9IDcwMDtcbiAgY29uc3QgbGFiZWxDb2xvciA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzE3MEY1Ric7XG4gIGNvbnN0IGxhYmVsRm9udEZhbWlseSA9ICdBdmVuaXIgTmV4dCBXb3JsZCwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNGIFByb1wiLCBcIlJvYm90b1wiLCBzYW5zLXNlcmlmJztcblxuICAvLyBDaGVjayBpZiBwZWFrIHBlcmZvcm1hbmNlIGlzIGludm9sdmVkIGFuZCBzaG93IHNlY29uZGFyeSBjaG9yZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGlzUGVha1BlcmZvcm1hbmNlSW52b2x2ZWQgPSBjdXJyZW50U291cmNlID09PSAncGVha19wZXJmb3JtYW5jZScgfHwgY3VycmVudFRhcmdldCA9PT0gJ3BlYWtfcGVyZm9ybWFuY2UnO1xuICAgIHNldFNob3dTZWNvbmRhcnlDaG9yZChpc1BlYWtQZXJmb3JtYW5jZUludm9sdmVkKTtcbiAgfSwgW2N1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXRdKTtcblxuICAvLyBTZWNvbmRhcnkgY2hvcmQgZGlhZ3JhbSBmb3IgcGVhayBwZXJmb3JtYW5jZSBicmVha2Rvd25cbiAgY29uc3QgcmVuZGVyU2Vjb25kYXJ5Q2hvcmQgPSAoKSA9PiB7XG4gICAgaWYgKCFzZWNvbmRhcnlTdmdSZWYuY3VycmVudCB8fCAhZGF0YS5sZW5ndGggfHwgaXNMb2FkaW5nKSByZXR1cm47XG5cbiAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3Qoc2Vjb25kYXJ5U3ZnUmVmLmN1cnJlbnQpO1xuICAgIHN2Zy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcblxuICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IHNldHRpbmdzLnVzZVRlc3REYXRhIFxuICAgICAgPyBkYXRhIFxuICAgICAgOiBkYXRhLmZpbHRlcihpdGVtID0+ICEoaXRlbSBhcyBhbnkpLnRlc3RfZGF0YSk7XG5cbiAgICAvLyBHZXQgYWxsIGRhdGEgZm9yIHNlY29uZGFyeSBjaG9yZCAoWWVhcnMgYXQgTWVkdHJvbmljIHZzIFBlYWsgUGVyZm9ybWFuY2UgY2F0ZWdvcmllcylcbiAgICBjb25zdCBzZWNvbmRhcnlEYXRhID0gZmlsdGVyZWREYXRhLmZpbHRlcihkID0+IChkIGFzIGFueSkucGVha19wZXJmb3JtYW5jZSk7XG4gICAgXG4gICAgaWYgKHNlY29uZGFyeURhdGEubGVuZ3RoIDwgNSkgcmV0dXJuO1xuXG4gICAgLy8gVXNlIHNhbWUgZGltZW5zaW9ucyBhcyBtYWluIGNob3JkIGZvciBjb25zaXN0ZW5jeVxuICAgIGNvbnN0IHNlY29uZGFyeVdpZHRoID0gc2hvd1NlY29uZGFyeUNob3JkID8gd2lkdGggKiAwLjQ1IDogd2lkdGg7XG4gICAgY29uc3Qgc2Vjb25kYXJ5SGVpZ2h0ID0gc2hvd1NlY29uZGFyeUNob3JkID8gaGVpZ2h0ICogMC44IDogaGVpZ2h0ICogMC44NTtcbiAgICBjb25zdCBzZWNvbmRhcnlNYXJnaW4gPSB7IHRvcDogODAsIHJpZ2h0OiA4MCwgYm90dG9tOiAxMDAsIGxlZnQ6IDgwIH07XG4gICAgY29uc3Qgc2Vjb25kYXJ5Q2hhcnRXaWR0aCA9IHNlY29uZGFyeVdpZHRoIC0gc2Vjb25kYXJ5TWFyZ2luLmxlZnQgLSBzZWNvbmRhcnlNYXJnaW4ucmlnaHQ7XG4gICAgY29uc3Qgc2Vjb25kYXJ5Q2hhcnRIZWlnaHQgPSBzZWNvbmRhcnlIZWlnaHQgLSBzZWNvbmRhcnlNYXJnaW4udG9wIC0gc2Vjb25kYXJ5TWFyZ2luLmJvdHRvbTtcbiAgICBjb25zdCBzZWNvbmRhcnlSYWRpdXMgPSBNYXRoLm1heCgxMjAsIE1hdGgubWluKHNlY29uZGFyeUNoYXJ0V2lkdGgsIHNlY29uZGFyeUNoYXJ0SGVpZ2h0KSAvIDIgLSA2MCk7XG5cbiAgICAvLyBZZWFycyBjYXRlZ29yaWVzIGFuZCBQZWFrIFBlcmZvcm1hbmNlIGNhdGVnb3JpZXNcbiAgICBjb25zdCB5ZWFyc0NhdGVnb3JpZXMgPSBbJzAtNScsICc2LTEwJywgJzExLTE1JywgJzE2LTIwJywgJzIwKyddO1xuICAgIGNvbnN0IHBlYWtQZXJmQ2F0ZWdvcmllcyA9IEFycmF5LmZyb20obmV3IFNldChzZWNvbmRhcnlEYXRhLm1hcChkID0+IChkIGFzIGFueSkucGVha19wZXJmb3JtYW5jZSkpKS5maWx0ZXIoQm9vbGVhbikuc29ydCgpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBiaXBhcnRpdGUgbWF0cml4OiBZZWFycyB2cyBQZWFrIFBlcmZvcm1hbmNlXG4gICAgY29uc3QgYWxsQ2F0ZWdvcmllcyA9IFsuLi55ZWFyc0NhdGVnb3JpZXMsIC4uLnBlYWtQZXJmQ2F0ZWdvcmllc107XG4gICAgY29uc3QgbWF0cml4ID0gYWxsQ2F0ZWdvcmllcy5tYXAoKHNvdXJjZUNhdGVnb3J5LCBzb3VyY2VJbmRleCkgPT4gXG4gICAgICBhbGxDYXRlZ29yaWVzLm1hcCgodGFyZ2V0Q2F0ZWdvcnksIHRhcmdldEluZGV4KSA9PiB7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGNvbm5lY3Rpb25zIGJldHdlZW4geWVhcnMgYW5kIHBlYWsgcGVyZm9ybWFuY2UgKG5vdCB3aXRoaW4gc2FtZSB0eXBlKVxuICAgICAgICBjb25zdCBzb3VyY2VJc1llYXJzID0gc291cmNlSW5kZXggPCB5ZWFyc0NhdGVnb3JpZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCB0YXJnZXRJc1llYXJzID0gdGFyZ2V0SW5kZXggPCB5ZWFyc0NhdGVnb3JpZXMubGVuZ3RoO1xuICAgICAgICBcbiAgICAgICAgLy8gT25seSBjb25uZWN0IHllYXJzIHRvIHBlYWsgcGVyZm9ybWFuY2VcbiAgICAgICAgaWYgKHNvdXJjZUlzWWVhcnMgPT09IHRhcmdldElzWWVhcnMpIHJldHVybiAwO1xuICAgICAgICBcbiAgICAgICAgLy8gQ291bnQgcGVvcGxlIHdobyBtYXRjaCB0aGlzIHllYXIgKyBwZXJmb3JtYW5jZSBjb21iaW5hdGlvblxuICAgICAgICBjb25zdCB5ZWFyc0NhdCA9IHNvdXJjZUlzWWVhcnMgPyBzb3VyY2VDYXRlZ29yeSA6IHRhcmdldENhdGVnb3J5O1xuICAgICAgICBjb25zdCBwZXJmQ2F0ID0gc291cmNlSXNZZWFycyA/IHRhcmdldENhdGVnb3J5IDogc291cmNlQ2F0ZWdvcnk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2Vjb25kYXJ5RGF0YS5maWx0ZXIoZCA9PiB7XG4gICAgICAgICAgY29uc3QgeWVhcnMgPSBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApO1xuICAgICAgICAgIGNvbnN0IHBlcmYgPSAoZCBhcyBhbnkpLnBlYWtfcGVyZm9ybWFuY2U7XG4gICAgICAgICAgcmV0dXJuIHllYXJzID09PSB5ZWFyc0NhdCAmJiBwZXJmID09PSBwZXJmQ2F0O1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBDcmVhdGUgY2hvcmQgbGF5b3V0XG4gICAgY29uc3QgY2hvcmRMYXlvdXQgPSBkMy5jaG9yZCgpLnBhZEFuZ2xlKDAuMDUpO1xuICAgIGNvbnN0IGNob3JkRGF0YSA9IGNob3JkTGF5b3V0KG1hdHJpeCk7XG5cbiAgICBjb25zdCBnID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtzZWNvbmRhcnlNYXJnaW4ubGVmdCArIHNlY29uZGFyeUNoYXJ0V2lkdGggLyAyfSwgJHtzZWNvbmRhcnlNYXJnaW4udG9wICsgc2Vjb25kYXJ5Q2hhcnRIZWlnaHQgLyAyfSlgKTtcblxuICAgIC8vIERyYXcgYXJjc1xuICAgIGNvbnN0IGFyYyA9IGQzLmFyYygpXG4gICAgICAuaW5uZXJSYWRpdXMoc2Vjb25kYXJ5UmFkaXVzICogMC43NSlcbiAgICAgIC5vdXRlclJhZGl1cyhzZWNvbmRhcnlSYWRpdXMgKiAwLjk1KTtcblxuICAgIGNvbnN0IHJpYmJvbiA9IGQzLnJpYmJvbigpLnJhZGl1cyhzZWNvbmRhcnlSYWRpdXMgKiAwLjc1KTtcblxuICAgIC8vIENvbG9yczogZGlmZmVyZW50IGh1ZXMgZm9yIHllYXJzIHZzIHBlYWsgcGVyZm9ybWFuY2UgdHlwZXNcbiAgICBjb25zdCB5ZWFyc0NvbG9ycyA9IFsnIzAwNzdDQycsICcjMDBBM0UwJywgJyM0RkMzRjcnLCAnIzgxQzc4NCcsICcjQUVENTgxJ107IC8vIEJsdWVzL0dyZWVucyBmb3IgeWVhcnNcbiAgICBjb25zdCBwZXJmQ29sb3JzID0gWycjRkY2QjZCJywgJyNGRkQxNjYnLCAnIzA2RDZBMCcsICcjMTE4QUIyJywgJyNGRjlGMUMnLCAnIzRFQ0RDNCddOyAvLyBWYXJpb3VzIGNvbG9ycyBmb3IgcGVyZm9ybWFuY2UgdHlwZXNcbiAgICBjb25zdCBjb2xvcnMgPSBbLi4ueWVhcnNDb2xvcnMsIC4uLnBlcmZDb2xvcnMuc2xpY2UoMCwgcGVha1BlcmZDYXRlZ29yaWVzLmxlbmd0aCldO1xuXG4gICAgLy8gRHJhdyBncm91cHMgKGFyY3MpIHdpdGggYW5pbWF0aW9uIGFuZCBob3ZlciBlZmZlY3RzXG4gICAgY29uc3QgZ3JvdXBTZWxlY3Rpb24gPSBnLnNlbGVjdEFsbCgnLmNob3JkLWdyb3VwJylcbiAgICAgIC5kYXRhKGNob3JkRGF0YS5ncm91cHMpXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAnY2hvcmQtZ3JvdXAnKVxuICAgICAgLmF0dHIoJ2QnLCBhcmMgYXMgYW55KVxuICAgICAgLnN0eWxlKCdmaWxsJywgKGQsIGkpID0+IGNvbG9yc1tpICUgY29sb3JzLmxlbmd0aF0pXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxuICAgICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZXZlbnQsIGQ6IGFueSkge1xuICAgICAgICBwYXVzZUFuaW1hdGlvbignc2Vjb25kYXJ5IGFyYyBob3ZlcicpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJpZ2dlciBoaWdobGlnaHRpbmcgZm9yIHNlY29uZGFyeSBjaG9yZFxuICAgICAgICBjb25zb2xlLmxvZygn8J+OryBTZWNvbmRhcnkgY2hvcmQgYXJjIGhvdmVyOicsIHtcbiAgICAgICAgICBncm91cEluZGV4OiBkLmluZGV4LFxuICAgICAgICAgIGNhdGVnb3J5OiBhbGxDYXRlZ29yaWVzW2QuaW5kZXhdXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc2V0U2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4KGQuaW5kZXgpO1xuICAgICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZFNpZGUoZC5pbmRleCA8IHllYXJzQ2F0ZWdvcmllcy5sZW5ndGggPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgXG4gICAgICAgIHNldFRvb2x0aXAoe1xuICAgICAgICAgIHg6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgIHk6IGV2ZW50LnBhZ2VZLFxuICAgICAgICAgIGNvbnRlbnQ6IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5Cb3R0b206IDQgfX0+e2FsbENhdGVnb3JpZXNbZC5pbmRleF0/LnRvU3RyaW5nKCkucmVwbGFjZSgvXy9nLCAnICcpIHx8ICcnfTwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2PntkLmluZGV4IDwgeWVhcnNDYXRlZ29yaWVzLmxlbmd0aCA/ICdZZWFycyBhdCBNZWR0cm9uaWMnIDogJ1BlYWsgUGVyZm9ybWFuY2UgVHlwZSd9PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXY+VmFsdWU6IHtkLnZhbHVlfTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgIHJlc3VtZUFuaW1hdGlvbignc2Vjb25kYXJ5IGFyYyBob3ZlciBlbmQnKTtcbiAgICAgICAgc2V0VG9vbHRpcChudWxsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IGhpZ2hsaWdodGluZyB3aGVuIGFuaW1hdGlvbiByZXN1bWVzXG4gICAgICAgIHNldFNlY29uZGFyeUFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICAgIHNldFNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXgobnVsbCk7XG4gICAgICAgIHNldFNlY29uZGFyeUhpZ2hsaWdodGVkU2lkZShudWxsKTtcbiAgICAgIH0pO1xuXG4gICAgLy8gQXBwbHkgdHJhbnNpdGlvbiBhbmltYXRpb25zIHRvIGdyb3Vwc1xuICAgIGdyb3VwU2VsZWN0aW9uXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oNzUwKVxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgKGQsIGkpID0+IHtcbiAgICAgICAgLy8gQXBwbHkgZnVsbCByZWxhdGlvbnNoaXAgY2hhaW4gaGlnaGxpZ2h0aW5nXG4gICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gaSkge1xuICAgICAgICAgICAgcmV0dXJuIDEuMDsgLy8gU291cmNlIGFyYyBpcyBmdWxseSBoaWdobGlnaHRlZFxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGFyYyBpcyBjb25uZWN0ZWQgdG8gdGhlIGhpZ2hsaWdodGVkIGFyY1xuICAgICAgICAgIGlmIChzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpc0Nvbm5lY3RlZCA9IGNob3JkRGF0YS5zb21lKGNob3JkID0+IFxuICAgICAgICAgICAgICAoY2hvcmQuc291cmNlLmluZGV4ID09PSBpICYmIGNob3JkLnRhcmdldC5pbmRleCA9PT0gc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCkgfHxcbiAgICAgICAgICAgICAgKGNob3JkLnNvdXJjZS5pbmRleCA9PT0gc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCAmJiBjaG9yZC50YXJnZXQuaW5kZXggPT09IGkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkID8gMC45NSA6IDAuMztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuODtcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycgJiYgc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gaSkge1xuICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlJywgKGQsIGkpID0+IHtcbiAgICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJyAmJiBzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4ID09PSBpKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJyA6ICdyZ2JhKDAsMCwwLDAuMyknO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICB9KTtcblxuICAgIC8vIERyYXcgY2hvcmRzIChyaWJib25zKSB3aXRoIGFuaW1hdGlvbiBhbmQgaG92ZXIgZWZmZWN0c1xuICAgIGNvbnN0IGNob3JkU2VsZWN0aW9uID0gZy5zZWxlY3RBbGwoJy5jaG9yZCcpXG4gICAgICAuZGF0YShjaG9yZERhdGEpXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAnY2hvcmQnKVxuICAgICAgLmF0dHIoJ2QnLCByaWJib24gYXMgYW55KVxuICAgICAgLnN0eWxlKCdmaWxsJywgZCA9PiBjb2xvcnNbZC5zb3VyY2UuaW5kZXggJSBjb2xvcnMubGVuZ3RoXSlcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXG4gICAgICAub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbihldmVudDogYW55LCBkOiBhbnkpIHtcbiAgICAgICAgcGF1c2VBbmltYXRpb24oJ3NlY29uZGFyeSByaWJib24gaG92ZXInKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyaWdnZXIgaGlnaGxpZ2h0aW5nIGZvciB0aGUgc291cmNlIHNpZGUgb2YgdGhpcyByaWJib25cbiAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gU2Vjb25kYXJ5IHJpYmJvbiBob3ZlcjonLCB7XG4gICAgICAgICAgc291cmNlSW5kZXg6IGQuc291cmNlLmluZGV4LFxuICAgICAgICAgIHRhcmdldEluZGV4OiBkLnRhcmdldC5pbmRleCxcbiAgICAgICAgICBzb3VyY2VDYXRlZ29yeTogYWxsQ2F0ZWdvcmllc1tkLnNvdXJjZS5pbmRleF0sXG4gICAgICAgICAgdGFyZ2V0Q2F0ZWdvcnk6IGFsbENhdGVnb3JpZXNbZC50YXJnZXQuaW5kZXhdXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc2V0U2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4KGQuc291cmNlLmluZGV4KTtcbiAgICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRTaWRlKGQuc291cmNlLmluZGV4IDwgeWVhcnNDYXRlZ29yaWVzLmxlbmd0aCA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuICAgICAgICBcbiAgICAgICAgc2V0VG9vbHRpcCh7XG4gICAgICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgeTogZXZlbnQucGFnZVksXG4gICAgICAgICAgY29udGVudDogKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcsIG1hcmdpbkJvdHRvbTogNCB9fT5cbiAgICAgICAgICAgICAgICB7YWxsQ2F0ZWdvcmllc1tkLnNvdXJjZS5pbmRleF19IOKGlCB7YWxsQ2F0ZWdvcmllc1tkLnRhcmdldC5pbmRleF19XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2PkNvbm5lY3Rpb25zOiB7ZC5zb3VyY2UudmFsdWV9PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bWVBbmltYXRpb24oJ3NlY29uZGFyeSByaWJib24gaG92ZXIgZW5kJyk7XG4gICAgICAgIHNldFRvb2x0aXAobnVsbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXNldCBoaWdobGlnaHRpbmcgd2hlbiBhbmltYXRpb24gcmVzdW1lc1xuICAgICAgICBzZXRTZWNvbmRhcnlBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4KG51bGwpO1xuICAgICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZFNpZGUobnVsbCk7XG4gICAgICB9KTtcblxuICAgIC8vIEFwcGx5IHRyYW5zaXRpb24gYW5pbWF0aW9ucyB0byBjaG9yZHNcbiAgICBjaG9yZFNlbGVjdGlvblxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDc1MClcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGQgPT4ge1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQuc291cmNlLmluZGV4IHx8IHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQudGFyZ2V0LmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gMC45NTsgLy8gTWFrZSBjb25uZWN0ZWQgcmliYm9ucyB2ZXJ5IHByb21pbmVudFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMC4yOyAvLyBEaW0gbm9uLWNvbm5lY3RlZCByaWJib25zXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjcgOiAwLjY7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBkID0+IHtcbiAgICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnNvdXJjZS5pbmRleCB8fCBzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnRhcmdldC5pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDIuNTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoJ3N0cm9rZScsIGQgPT4ge1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQuc291cmNlLmluZGV4IHx8IHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQudGFyZ2V0LmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknIDogJ3JnYmEoMCwwLDAsMC4zKSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICB9KTtcblxuICAgIC8vIEFkZCBsYWJlbHMgd2l0aCBwcm9wZXIgc3BhY2luZyBhbmQgcm90YXRpb25cbiAgICBjb25zdCBzZWNvbmRhcnlMYWJlbFJhZGl1cyA9IE1hdGgubWF4KDEyMCwgc2Vjb25kYXJ5UmFkaXVzICogMS40NSk7XG4gICAgZy5zZWxlY3RBbGwoJy5jaG9yZC1sYWJlbCcpXG4gICAgICAuZGF0YShjaG9yZERhdGEuZ3JvdXBzKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Nob3JkLWxhYmVsJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoZC5zdGFydEFuZ2xlICsgZC5lbmRBbmdsZSkgLyAyIC0gTWF0aC5QSSAvIDI7XG4gICAgICAgIGNvbnN0IHggPSBzZWNvbmRhcnlMYWJlbFJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgY29uc3QgeSA9IHNlY29uZGFyeUxhYmVsUmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGFuZ2xlICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJvdGF0ZSB0ZXh0IGZvciBiZXR0ZXIgcmVhZGFiaWxpdHlcbiAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgfHwgYW5nbGUgPCAtTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCAke3l9KSByb3RhdGUoJHtyb3RhdGlvbiArIDE4MH0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCAke3l9KSByb3RhdGUoJHtyb3RhdGlvbn0pYDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIGQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgfHwgYW5nbGUgPCAtTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpXG4gICAgICAuc3R5bGUoJ2ZvbnQtZmFtaWx5JywgbGFiZWxGb250RmFtaWx5KVxuICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsIGxhYmVsRm9udFdlaWdodClcbiAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgZCA9PiB7XG4gICAgICAgIC8vIER5bmFtaWMgZm9udCBzaXplIGJhc2VkIG9uIG51bWJlciBvZiBsYWJlbHNcbiAgICAgICAgY29uc3QgdG90YWxMYWJlbHMgPSBhbGxDYXRlZ29yaWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKHRvdGFsTGFiZWxzID4gMTIpIHJldHVybiAnMTNweCc7XG4gICAgICAgIGlmICh0b3RhbExhYmVscyA+IDEwKSByZXR1cm4gJzE0cHgnO1xuICAgICAgICBpZiAodG90YWxMYWJlbHMgPiA4KSByZXR1cm4gJzE1cHgnO1xuICAgICAgICByZXR1cm4gJzE2cHgnO1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnZmlsbCcsIGxhYmVsQ29sb3IpXG4gICAgICAuc3R5bGUoJ3RleHQtdHJhbnNmb3JtJywgJ3VwcGVyY2FzZScpXG4gICAgICAudGV4dCgoZCwgaSkgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0gYWxsQ2F0ZWdvcmllc1tpXT8udG9TdHJpbmcoKS5yZXBsYWNlKC9fL2csICcgJykgfHwgJyc7XG4gICAgICAgIC8vIFNob3cgZnVsbCB0ZXh0IGZvciBzZWNvbmRhcnkgY2hvcmQgbGFiZWxzXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfSlcbiAgICAgIC5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKGV2ZW50LCBkKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxUZXh0ID0gYWxsQ2F0ZWdvcmllc1tkLmluZGV4XT8udG9TdHJpbmcoKS5yZXBsYWNlKC9fL2csICcgJykgfHwgJyc7XG4gICAgICAgIHNldFRvb2x0aXAoe1xuICAgICAgICAgIHg6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgIHk6IGV2ZW50LnBhZ2VZLFxuICAgICAgICAgIGNvbnRlbnQ6IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5Cb3R0b206IDQgfX0+e2Z1bGxUZXh0fTwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2PntkLmluZGV4IDwgeWVhcnNDYXRlZ29yaWVzLmxlbmd0aCA/ICdZZWFycyBhdCBNZWR0cm9uaWMnIDogJ1BlYWsgUGVyZm9ybWFuY2UgVHlwZSd9PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5vbignbW91c2VsZWF2ZScsICgpID0+IHNldFRvb2x0aXAobnVsbCkpO1xuXG5cbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZW5zdXJlIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBkaWZmZXJlbnRcbiAgY29uc3QgZW5zdXJlRGlmZmVyZW50Q2F0ZWdvcmllcyA9IChzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpOiB7IHNvdXJjZTogc3RyaW5nOyB0YXJnZXQ6IHN0cmluZyB9ID0+IHtcbiAgICBpZiAoc291cmNlID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIEZpbmQgYSBkaWZmZXJlbnQgdGFyZ2V0XG4gICAgICBjb25zdCBkaWZmZXJlbnRPcHRpb24gPSBhdmFpbGFibGVGaWVsZHMuZmluZChmaWVsZCA9PiBmaWVsZC52YWx1ZSAhPT0gc291cmNlKTtcbiAgICAgIHJldHVybiB7IHNvdXJjZSwgdGFyZ2V0OiBkaWZmZXJlbnRPcHRpb24gPyBkaWZmZXJlbnRPcHRpb24udmFsdWUgOiAnbGVhcm5pbmdfc3R5bGUnIH07XG4gICAgfVxuICAgIHJldHVybiB7IHNvdXJjZSwgdGFyZ2V0IH07XG4gIH07XG5cbiAgLy8gRW5zdXJlIGluaXRpYWwgc3RhdGUgZG9lc24ndCBoYXZlIHNhbWUgY2F0ZWdvcmllc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvcnJlY3RlZCA9IGVuc3VyZURpZmZlcmVudENhdGVnb3JpZXMoY3VycmVudFNvdXJjZSwgY3VycmVudFRhcmdldCk7XG4gICAgaWYgKGNvcnJlY3RlZC5zb3VyY2UgIT09IGN1cnJlbnRTb3VyY2UgfHwgY29ycmVjdGVkLnRhcmdldCAhPT0gY3VycmVudFRhcmdldCkge1xuICAgICAgc2V0Q3VycmVudFNvdXJjZShjb3JyZWN0ZWQuc291cmNlKTtcbiAgICAgIHNldEN1cnJlbnRUYXJnZXQoY29ycmVjdGVkLnRhcmdldCk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gVHJhY2sgY3VycmVudCBtb2RlIGluZGV4IHdpdGggcmVmIHRvIGF2b2lkIGRlcGVuZGVuY3kgaXNzdWVzXG4gIGNvbnN0IGN1cnJlbnRNb2RlSW5kZXhSZWYgPSB1c2VSZWYoMCk7XG4gIFxuICAvLyBVcGRhdGUgbW9kZSBpbmRleCB3aGVuIHNvdXJjZS90YXJnZXQgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1vZGVJbmRleCA9IGN5Y2xpbmdNb2Rlcy5maW5kSW5kZXgoXG4gICAgICBtb2RlID0+IG1vZGUuc291cmNlID09PSBjdXJyZW50U291cmNlICYmIG1vZGUudGFyZ2V0ID09PSBjdXJyZW50VGFyZ2V0XG4gICAgKTtcbiAgICBpZiAobW9kZUluZGV4ICE9PSAtMSkge1xuICAgICAgY3VycmVudE1vZGVJbmRleFJlZi5jdXJyZW50ID0gbW9kZUluZGV4O1xuICAgIH1cbiAgfSwgW2N1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXRdKTtcblxuICAvLyBBdXRvLWN5Y2xpbmcgbG9naWMgd2l0aCBzdGFibGUgZGVwZW5kZW5jaWVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ/CfjrUgQ2hvcmREaWFncmFtIGF1dG8tY3ljbGluZyB1c2VFZmZlY3Q6Jywge1xuICAgICAgYXV0b1BsYXksXG4gICAgICBpc0F1dG9QbGF5RW5hYmxlZDogc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQsXG4gICAgICBhdXRvUGxheVNwZWVkOiBzZXR0aW5ncy5hdXRvUGxheVNwZWVkXG4gICAgfSk7XG5cbiAgICBpZiAoIWF1dG9QbGF5IHx8ICFzZXR0aW5ncy5pc0F1dG9QbGF5RW5hYmxlZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBDaG9yZERpYWdyYW0gYXV0by1jeWNsaW5nIGRpc2FibGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ+KchSBDaG9yZERpYWdyYW0gc3RhcnRpbmcgYXV0by1jeWNsaW5nJyk7XG5cbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IG5leHRNb2RlSW5kZXggPSAoY3VycmVudE1vZGVJbmRleFJlZi5jdXJyZW50ICsgMSkgJSBjeWNsaW5nTW9kZXMubGVuZ3RoO1xuICAgICAgY29uc3QgbmV4dE1vZGUgPSBjeWNsaW5nTW9kZXNbbmV4dE1vZGVJbmRleF07XG4gICAgICBcbiAgICAgIC8vIFNhZmV0eSBjaGVjazogZW5zdXJlIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmIChuZXh0TW9kZS5zb3VyY2UgPT09IG5leHRNb2RlLnRhcmdldCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1NraXBwaW5nIGludmFsaWQgY3ljbGluZyBtb2RlIHdpdGggc2FtZSBzb3VyY2UgYW5kIHRhcmdldDonLCBuZXh0TW9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/CflIQgQ2hvcmREaWFncmFtIGN5Y2xpbmcgdG86Jywge1xuICAgICAgICBmcm9tOiBgbW9kZSAke2N1cnJlbnRNb2RlSW5kZXhSZWYuY3VycmVudH1gLFxuICAgICAgICB0bzogYCR7bmV4dE1vZGUuc291cmNlfSDihpIgJHtuZXh0TW9kZS50YXJnZXR9YCxcbiAgICAgICAgbW9kZUluZGV4OiBuZXh0TW9kZUluZGV4XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY3VycmVudE1vZGVJbmRleFJlZi5jdXJyZW50ID0gbmV4dE1vZGVJbmRleDtcbiAgICAgIHNldEN1cnJlbnRTb3VyY2UobmV4dE1vZGUuc291cmNlKTtcbiAgICAgIHNldEN1cnJlbnRUYXJnZXQobmV4dE1vZGUudGFyZ2V0KTtcbiAgICAgIHNldExhc3RDYXRlZ29yeUNoYW5nZSh7IHNvdXJjZTogbmV4dE1vZGUuc291cmNlLCB0YXJnZXQ6IG5leHRNb2RlLnRhcmdldCB9KTtcbiAgICAgIG9uUmVsYXRpb25zaGlwQ2hhbmdlPy4obmV4dE1vZGUuc291cmNlLCBuZXh0TW9kZS50YXJnZXQpO1xuICAgIH0sIHNldHRpbmdzLmF1dG9QbGF5U3BlZWQgfHwgNjAwMCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ/Cfp7kgQ2hvcmREaWFncmFtIGNsZWFuaW5nIHVwIGF1dG8tY3ljbGluZyBpbnRlcnZhbCcpO1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgfTtcbiAgfSwgW2F1dG9QbGF5LCBzZXR0aW5ncy5pc0F1dG9QbGF5RW5hYmxlZCwgc2V0dGluZ3MuYXV0b1BsYXlTcGVlZF0pOyAvLyBTdGFibGUgZGVwZW5kZW5jaWVzIG9ubHlcblxuICAvLyBSZW1vdmUgcHVsc2luZyBhbmltYXRpb24gdG8gZWxpbWluYXRlIGZsaWNrZXJpbmcgLSB3aWxsIHVzZSBDU1MgYW5pbWF0aW9ucyBpbnN0ZWFkIGlmIG5lZWRlZFxuXG4gIC8vIEFyYyBoaWdobGlnaHRpbmcgYW5pbWF0aW9uIHdpdGggY29ubmVjdGVkIHJpYmJvbnNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UhCBDaG9yZERpYWdyYW0gYXJjIGhpZ2hsaWdodGluZyBlZmZlY3Q6Jywge1xuICAgICAgYXV0b1BsYXksXG4gICAgICBpc0F1dG9QbGF5RW5hYmxlZDogc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQsXG4gICAgICBkYXRhTGVuZ3RoOiBkYXRhLmxlbmd0aFxuICAgIH0pO1xuXG4gICAgaWYgKCFhdXRvUGxheSB8fCAhc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIEFyYyBoaWdobGlnaHRpbmcgZGlzYWJsZWQnKTtcbiAgICAgIC8vIFJlc2V0IHRvIGZ1bGwgb3BhY2l0eSB3aGVuIGFuaW1hdGlvbiBpcyBkaXNhYmxlZFxuICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgIHNldEhpZ2hsaWdodGVkQXJjSW5kZXgobnVsbCk7XG4gICAgICBzZXRIaWdobGlnaHRlZFNpZGUobnVsbCk7XG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKTtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICBpZiAoIWFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgfHwgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHJldHVybjtcblxuICAgICAgY29uc29sZS5sb2coJ/Cfjq8gQ2hvcmREaWFncmFtIGFyYyBhbmltYXRpb246Jywge1xuICAgICAgICBzaWRlOiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSxcbiAgICAgICAgaW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleFxuICAgICAgfSk7XG5cbiAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgIHNldEhpZ2hsaWdodGVkQXJjSW5kZXgoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4KTtcbiAgICAgIHNldEhpZ2hsaWdodGVkU2lkZShhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSk7XG4gICAgICBcbiAgICAgIC8vIExvZyB3aGF0IGNvbm5lY3Rpb25zIHdpbGwgYmUgaGlnaGxpZ2h0ZWRcbiAgICAgIGNvbnN0IGRlYnVnRmlsdGVyZWREYXRhID0gc2V0dGluZ3MudXNlVGVzdERhdGEgPyBkYXRhIDogZGF0YS5maWx0ZXIoaXRlbSA9PiAhKGl0ZW0gYXMgYW55KS50ZXN0X2RhdGEpO1xuICAgICAgY29uc3QgZGVidWdMZWZ0VmFsdWVzID0gY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYydcbiAgICAgICAgPyBbJzAtNScsICc2LTEwJywgJzExLTE1JywgJzE2LTIwJywgJzIwKyddXG4gICAgICAgIDogQXJyYXkuZnJvbShuZXcgU2V0KGRlYnVnRmlsdGVyZWREYXRhLm1hcChkID0+IChkIGFzIGFueSlbY3VycmVudFNvdXJjZV0pKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgY29uc3QgZGVidWdSaWdodFZhbHVlcyA9IGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICAgID8gWycwLTUnLCAnNi0xMCcsICcxMS0xNScsICcxNi0yMCcsICcyMCsnXVxuICAgICAgICA6IEFycmF5LmZyb20obmV3IFNldChkZWJ1Z0ZpbHRlcmVkRGF0YS5tYXAoZCA9PiAoZCBhcyBhbnkpW2N1cnJlbnRUYXJnZXRdKSkpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGlnaGxpZ2h0ZWRDYXRlZ29yeSA9IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcgXG4gICAgICAgID8gZGVidWdMZWZ0VmFsdWVzW2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleF1cbiAgICAgICAgOiBkZWJ1Z1JpZ2h0VmFsdWVzW2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleF07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinKggSGlnaGxpZ2h0aW5nIGZ1bGwgcmVsYXRpb25zaGlwIGNoYWluIGZvcjonLCB7XG4gICAgICAgIHNvdXJjZUNhdGVnb3J5OiBoaWdobGlnaHRlZENhdGVnb3J5LFxuICAgICAgICBzb3VyY2VTaWRlOiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSxcbiAgICAgICAgc291cmNlSW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aW1pbmcgYmFzZWQgb24gZ2xvYmFsIHNldHRpbmdzXG4gICAgICBjb25zdCBzdGVwRHVyYXRpb24gPSBNYXRoLm1heCgxMDAwLCAoc2V0dGluZ3MuYXV0b1BsYXlTcGVlZCB8fCAzMDAwKSAvIDQpO1xuICAgICAgY29uc3QgcGF1c2VEdXJhdGlvbiA9IE1hdGgubWF4KDIwMCwgc3RlcER1cmF0aW9uIC8gNik7XG5cbiAgICAgIC8vIEdldCBjdXJyZW50IGRhdGEgY29udGV4dFxuICAgICAgY29uc3QgZmlsdGVyZWREYXRhID0gc2V0dGluZ3MudXNlVGVzdERhdGEgPyBkYXRhIDogZGF0YS5maWx0ZXIoaXRlbSA9PiAhKGl0ZW0gYXMgYW55KS50ZXN0X2RhdGEpO1xuICAgICAgY29uc3QgbGVmdFZhbHVlcyA9IGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICAgID8gWycwLTUnLCAnNi0xMCcsICcxMS0xNScsICcxNi0yMCcsICcyMCsnXVxuICAgICAgICA6IEFycmF5LmZyb20obmV3IFNldChmaWx0ZXJlZERhdGEubWFwKGQgPT4gKGQgYXMgYW55KVtjdXJyZW50U291cmNlXSkpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICBjb25zdCByaWdodFZhbHVlcyA9IGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICAgID8gWycwLTUnLCAnNi0xMCcsICcxMS0xNScsICcxNi0yMCcsICcyMCsnXVxuICAgICAgICA6IEFycmF5LmZyb20obmV3IFNldChmaWx0ZXJlZERhdGEubWFwKGQgPT4gKGQgYXMgYW55KVtjdXJyZW50VGFyZ2V0XSkpKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRTaWRlTGVuZ3RoID0gYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUgPT09ICdsZWZ0JyA/IGxlZnRWYWx1ZXMubGVuZ3RoIDogcmlnaHRWYWx1ZXMubGVuZ3RoO1xuXG4gICAgICAvLyBNb3ZlIHRvIG5leHQgcG9zaXRpb25cbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggPCBjdXJyZW50U2lkZUxlbmd0aCAtIDEpIHtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyAmJiAhYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RlcER1cmF0aW9uICsgcGF1c2VEdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTd2l0Y2ggc2lkZXMgb3IgY29tcGxldGUgY3ljbGVcbiAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdyaWdodCc7XG4gICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBzdGVwRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENvbXBsZXRlIGN5Y2xlIC0gc2hvdyBmdWxsIGRpYWdyYW0gYnJpZWZseSwgdGhlbiByZXN0YXJ0XG4gICAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgICAgICBzZXRIaWdobGlnaHRlZEFyY0luZGV4KG51bGwpO1xuICAgICAgICAgIHNldEhpZ2hsaWdodGVkU2lkZShudWxsKTtcbiAgICAgICAgICBcbiAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID0gJ2xlZnQnO1xuICAgICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgICBhbmltYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgc3RlcER1cmF0aW9uICogMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gU3RhcnQgYW5pbWF0aW9uIGlmIG5vdCBhbHJlYWR5IHJ1bm5pbmdcbiAgICBpZiAoIWFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU3RhcnRpbmcgQ2hvcmREaWFncmFtIGFyYyBoaWdobGlnaHRpbmcgYW5pbWF0aW9uJyk7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdsZWZ0JztcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICBhbmltYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gQXJjIGhpZ2hsaWdodGluZyBhbmltYXRpb24gYWxyZWFkeSBydW5uaW5nJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn6e5IENsZWFuaW5nIHVwIENob3JkRGlhZ3JhbSBhcmMgaGlnaGxpZ2h0aW5nIGFuaW1hdGlvbicpO1xuICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICBzZXRIaWdobGlnaHRlZEFyY0luZGV4KG51bGwpO1xuICAgICAgc2V0SGlnaGxpZ2h0ZWRTaWRlKG51bGwpO1xuICAgIH07XG4gIH0sIFthdXRvUGxheSwgc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQsIGRhdGEubGVuZ3RoLCBjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0LCBzZXR0aW5ncy5hdXRvUGxheVNwZWVkLCBzZXR0aW5ncy51c2VUZXN0RGF0YV0pO1xuXG4gIC8vIFNlY29uZGFyeSBjaG9yZCBhbmltYXRpb24gc3lzdGVtXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFhdXRvUGxheSB8fCAhc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQgfHwgIWRhdGEubGVuZ3RoIHx8ICFzaG93U2Vjb25kYXJ5Q2hvcmQpIHtcbiAgICAgIC8vIFN0b3AgYW5pbWF0aW9uIGlmIGNvbmRpdGlvbnMgbm90IG1ldFxuICAgICAgY29uc29sZS5sb2coJ/Cfm5EgU3RvcHBpbmcgc2Vjb25kYXJ5IGNob3JkIGFuaW1hdGlvbjonLCB7XG4gICAgICAgIGF1dG9QbGF5LFxuICAgICAgICBpc0F1dG9QbGF5RW5hYmxlZDogc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQsXG4gICAgICAgIGhhc0RhdGE6IGRhdGEubGVuZ3RoID4gMCxcbiAgICAgICAgc2hvd1NlY29uZGFyeUNob3JkXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRlU2Vjb25kYXJ5ID0gKCkgPT4ge1xuICAgICAgaWYgKCFzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nIHx8IHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSByZXR1cm47XG5cbiAgICAgIC8vIEdldCBzZWNvbmRhcnkgY2hvcmQgZGF0YSBjb250ZXh0IGZpcnN0XG4gICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBzZXR0aW5ncy51c2VUZXN0RGF0YSA/IGRhdGEgOiBkYXRhLmZpbHRlcihpdGVtID0+ICEoaXRlbSBhcyBhbnkpLnRlc3RfZGF0YSk7XG4gICAgICBjb25zdCBzZWNvbmRhcnlEYXRhID0gZmlsdGVyZWREYXRhLmZpbHRlcihkID0+IChkIGFzIGFueSkucGVha19wZXJmb3JtYW5jZSk7XG4gICAgICBjb25zdCB5ZWFyc0NhdGVnb3JpZXMgPSBbJzAtNScsICc2LTEwJywgJzExLTE1JywgJzE2LTIwJywgJzIwKyddO1xuICAgICAgY29uc3QgcGVha1BlcmZDYXRlZ29yaWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHNlY29uZGFyeURhdGEubWFwKGQgPT4gKGQgYXMgYW55KS5wZWFrX3BlcmZvcm1hbmNlKSkpLmZpbHRlcihCb29sZWFuKS5zb3J0KCk7XG4gICAgICBjb25zdCBhbGxDYXRlZ29yaWVzID0gWy4uLnllYXJzQ2F0ZWdvcmllcywgLi4ucGVha1BlcmZDYXRlZ29yaWVzXTtcblxuICAgICAgY29uc29sZS5sb2coJ/Cfjq8gU2Vjb25kYXJ5Q2hvcmQgYXJjIGFuaW1hdGlvbjonLCB7XG4gICAgICAgIHNpZGU6IHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlLFxuICAgICAgICBpbmRleDogc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4XG4gICAgICB9KTtcblxuICAgICAgc2V0U2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGFjdHVhbCBhcmMgaW5kZXggYmFzZWQgb24gc2lkZSBhbmQgcG9zaXRpb25cbiAgICAgIGNvbnN0IGFjdHVhbEFyY0luZGV4ID0gc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUgPT09ICdsZWZ0JyBcbiAgICAgICAgPyBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggLy8gTGVmdCBzaWRlOiBkaXJlY3QgaW5kZXggKDAtNClcbiAgICAgICAgOiB5ZWFyc0NhdGVnb3JpZXMubGVuZ3RoICsgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4OyAvLyBSaWdodCBzaWRlOiBvZmZzZXQgYnkgeWVhcnMgY291bnRcbiAgICAgIFxuICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleChhY3R1YWxBcmNJbmRleCk7XG4gICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZFNpZGUoc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGltaW5nIGJhc2VkIG9uIGdsb2JhbCBzZXR0aW5nc1xuICAgICAgY29uc3Qgc3RlcER1cmF0aW9uID0gTWF0aC5tYXgoMTAwMCwgKHNldHRpbmdzLmF1dG9QbGF5U3BlZWQgfHwgMzAwMCkgLyA0KTtcbiAgICAgIGNvbnN0IHBhdXNlRHVyYXRpb24gPSBNYXRoLm1heCgyMDAsIHN0ZXBEdXJhdGlvbiAvIDYpO1xuXG4gICAgICBjb25zdCBjdXJyZW50U2lkZUxlbmd0aCA9IHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcgPyB5ZWFyc0NhdGVnb3JpZXMubGVuZ3RoIDogcGVha1BlcmZDYXRlZ29yaWVzLmxlbmd0aDtcblxuICAgICAgLy8gTW92ZSB0byBuZXh0IHBvc2l0aW9uXG4gICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4IDwgY3VycmVudFNpZGVMZW5ndGggLSAxKSB7XG4gICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIXNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgIGFuaW1hdGVTZWNvbmRhcnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHN0ZXBEdXJhdGlvbiArIHBhdXNlRHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3dpdGNoIHNpZGVzIG9yIGNvbXBsZXRlIGN5Y2xlXG4gICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNpZGUgPSAncmlnaHQnO1xuICAgICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nICYmICFzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICBhbmltYXRlU2Vjb25kYXJ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgc3RlcER1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDb21wbGV0ZSBjeWNsZSAtIHNob3cgZnVsbCBkaWFncmFtIGJyaWVmbHksIHRoZW4gcmVzdGFydFxuICAgICAgICAgIHNldFNlY29uZGFyeUFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleChudWxsKTtcbiAgICAgICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZFNpZGUobnVsbCk7XG4gICAgICAgICAgXG4gICAgICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nICYmICFzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgYW5pbWF0ZVNlY29uZGFyeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHN0ZXBEdXJhdGlvbiAqIDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFN0YXJ0IGFuaW1hdGlvbiBpZiBub3QgYWxyZWFkeSBydW5uaW5nXG4gICAgaWYgKCFzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIFN0YXJ0aW5nIFNlY29uZGFyeUNob3JkIGFyYyBoaWdobGlnaHRpbmcgYW5pbWF0aW9uJyk7XG4gICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdsZWZ0JztcbiAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICBhbmltYXRlU2Vjb25kYXJ5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gU2Vjb25kYXJ5IGFyYyBoaWdobGlnaHRpbmcgYW5pbWF0aW9uIGFscmVhZHkgcnVubmluZycpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygn8J+nuSBDbGVhbmluZyB1cCBTZWNvbmRhcnlDaG9yZCBhcmMgaGlnaGxpZ2h0aW5nIGFuaW1hdGlvbicpO1xuICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHNldFNlY29uZGFyeUFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICBzZXRTZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4KG51bGwpO1xuICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRTaWRlKG51bGwpO1xuICAgIH07XG4gIH0sIFthdXRvUGxheSwgc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQsIGRhdGEubGVuZ3RoLCBzaG93U2Vjb25kYXJ5Q2hvcmQsIHNldHRpbmdzLmF1dG9QbGF5U3BlZWQsIHNldHRpbmdzLnVzZVRlc3REYXRhXSk7XG5cbiAgLy8gUmUtcmVuZGVyIHNlY29uZGFyeSBjaG9yZCB3aGVuIGl0cyBhbmltYXRpb24gc3RhdGUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzaG93U2Vjb25kYXJ5Q2hvcmQpIHtcbiAgICAgIHJlbmRlclNlY29uZGFyeUNob3JkKCk7XG4gICAgfVxuICB9LCBbc2hvd1NlY29uZGFyeUNob3JkLCBkYXRhLCBzZXR0aW5ncy51c2VUZXN0RGF0YSwgc2V0dGluZ3MuaXNEYXJrTW9kZV0pO1xuXG4gIC8vIFVwZGF0ZSB2aXN1YWwgc3R5bGluZyBvZiBleGlzdGluZyBtYWluIGNob3JkIGVsZW1lbnRzIHdoZW4gYW5pbWF0aW9uIHN0YXRlIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN2Z1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3Qoc3ZnUmVmLmN1cnJlbnQpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBsZWZ0IGFyY3Mgb3BhY2l0eSBhbmQgc3Ryb2tlIGJhc2VkIG9uIGFuaW1hdGlvbiBzdGF0ZVxuICAgIHN2Zy5zZWxlY3RBbGwoJ3BhdGgubGVmdC1hcmMnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDMwMClcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIChkOiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gMS4wOyAvLyBTb3VyY2UgYXJjIGlzIGZ1bGx5IGhpZ2hsaWdodGVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC40OyAvLyBEaW0gb3RoZXIgbGVmdCBhcmNzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwLjg7IC8vIERlZmF1bHQgb3BhY2l0eVxuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgKGQ6IGFueSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlJywgKGQ6IGFueSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJyA6ICdyZ2JhKDAsMCwwLDAuMyknO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgcmlnaHQgYXJjcyBvcGFjaXR5IGFuZCBzdHJva2UgYmFzZWQgb24gYW5pbWF0aW9uIHN0YXRlXG4gICAgc3ZnLnNlbGVjdEFsbCgncGF0aC5yaWdodC1hcmMnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDMwMClcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIChkOiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgaWYgKGkgPT09IGhpZ2hsaWdodGVkQXJjSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDEuMDsgLy8gU291cmNlIGFyYyBpcyBmdWxseSBoaWdobGlnaHRlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNDsgLy8gRGltIG90aGVyIHJpZ2h0IGFyY3NcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuODsgLy8gRGVmYXVsdCBvcGFjaXR5XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAoZDogYW55LCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlJywgKGQ6IGFueSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAncmlnaHQnICYmIGkgPT09IGhpZ2hsaWdodGVkQXJjSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScgOiAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHJpYmJvbnMgb3BhY2l0eSBhbmQgc3Ryb2tlIGJhc2VkIG9uIGFuaW1hdGlvbiBzdGF0ZVxuICAgIHN2Zy5zZWxlY3RBbGwoJ3BhdGgucmliYm9uJylcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbigzMDApXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCAoZDogYW55KSA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjk1OyAvLyBNYWtlIGNvbm5lY3RlZCByaWJib25zIHZlcnkgcHJvbWluZW50XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjk1OyAvLyBNYWtlIGNvbm5lY3RlZCByaWJib25zIHZlcnkgcHJvbWluZW50XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwLjI7IC8vIERpbSBub24tY29ubmVjdGVkIHJpYmJvbnNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuNyA6IDAuNjtcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIChkOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmICgoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXgpIHx8XG4gICAgICAgICAgICAgIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMi41O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMC41O1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnc3Ryb2tlJywgKGQ6IGFueSkgPT4ge1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKChoaWdobGlnaHRlZFNpZGUgPT09ICdsZWZ0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnNvdXJjZS5pbmRleCkgfHxcbiAgICAgICAgICAgICAgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ3JpZ2h0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnRhcmdldC5pbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScgOiAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG5cbiAgfSwgW2FuaW1hdGlvblBoYXNlLCBoaWdobGlnaHRlZEFyY0luZGV4LCBoaWdobGlnaHRlZFNpZGUsIHNldHRpbmdzLmlzRGFya01vZGVdKTtcblxuICAvLyBVcGRhdGUgdmlzdWFsIHN0eWxpbmcgb2YgZXhpc3Rpbmcgc2Vjb25kYXJ5IGNob3JkIGVsZW1lbnRzIHdoZW4gYW5pbWF0aW9uIHN0YXRlIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNlY29uZGFyeVN2Z1JlZi5jdXJyZW50IHx8ICFzaG93U2Vjb25kYXJ5Q2hvcmQpIHJldHVybjtcblxuICAgIGNvbnN0IHN2ZyA9IGQzLnNlbGVjdChzZWNvbmRhcnlTdmdSZWYuY3VycmVudCk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHNlY29uZGFyeSBjaG9yZCBlbGVtZW50cyBiYXNlZCBvbiB0aGVpciBhbmltYXRpb24gc3RhdGVcbiAgICBzdmcuc2VsZWN0QWxsKCdwYXRoLmNob3JkLWdyb3VwJylcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbigzMDApXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCAoZDogYW55LCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4ID09PSBpKSB7XG4gICAgICAgICAgICByZXR1cm4gMS4wOyAvLyBTb3VyY2UgYXJjIGlzIGZ1bGx5IGhpZ2hsaWdodGVkXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwLjQ7IC8vIERpbSBvdGhlciBhcmNzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuODtcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIChkOiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnICYmIHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGkpIHtcbiAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoJ3N0cm9rZScsIChkOiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnICYmIHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGkpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknIDogJ3JnYmEoMCwwLDAsMC4zKSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG4gICAgc3ZnLnNlbGVjdEFsbCgncGF0aC5jaG9yZCcpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMzAwKVxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgKGQ6IGFueSkgPT4ge1xuICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQuc291cmNlLmluZGV4IHx8IHNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQudGFyZ2V0LmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gMC45NTsgLy8gTWFrZSBjb25uZWN0ZWQgcmliYm9ucyB2ZXJ5IHByb21pbmVudFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMC4yOyAvLyBEaW0gbm9uLWNvbm5lY3RlZCByaWJib25zXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjcgOiAwLjY7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAoZDogYW55KSA9PiB7XG4gICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXggfHwgc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAyLjU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwLjU7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdzdHJva2UnLCAoZDogYW55KSA9PiB7XG4gICAgICAgIGlmIChzZWNvbmRhcnlBbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXggfHwgc2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScgOiAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG5cbiAgfSwgW3NlY29uZGFyeUFuaW1hdGlvblBoYXNlLCBzZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4LCBzZWNvbmRhcnlIaWdobGlnaHRlZFNpZGUsIHNldHRpbmdzLmlzRGFya01vZGUsIHNob3dTZWNvbmRhcnlDaG9yZF0pO1xuXG4gIC8vIFJlbW92ZSBjb25mbGljdGluZyBvcGFjaXR5IHVwZGF0ZSBzeXN0ZW0gLSBvcGFjaXR5IHdpbGwgYmUgaGFuZGxlZCBpbiBtYWluIHJlbmRlcmluZ1xuXG4gIC8vIFBhdXNlL1Jlc3VtZSBhbmltYXRpb24gZnVuY3Rpb25zIChzaW1pbGFyIHRvIEFsbHV2aWFsRGlhZ3JhbSlcbiAgY29uc3QgcGF1c2VBbmltYXRpb24gPSB1c2VDYWxsYmFjaygocmVhc29uOiBzdHJpbmcpID0+IHtcbiAgICAvLyBQYXVzZSBtYWluIGNob3JkIGFuaW1hdGlvblxuICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nICYmICFhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KPuO+4jyBQYXVzaW5nIE1haW4gQ2hvcmQgYW5pbWF0aW9uOicsIHJlYXNvbik7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCA9IHRydWU7XG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKTtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBQYXVzZSBzZWNvbmRhcnkgY2hvcmQgYW5pbWF0aW9uXG4gICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIXNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4o+477iPIFBhdXNpbmcgU2Vjb25kYXJ5IENob3JkIGFuaW1hdGlvbjonLCByZWFzb24pO1xuICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQgPSB0cnVlO1xuICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCByZXN1bWVBbmltYXRpb24gPSB1c2VDYWxsYmFjaygocmVhc29uOiBzdHJpbmcpID0+IHtcbiAgICAvLyBSZXN1bWUgbWFpbiBjaG9yZCBhbmltYXRpb25cbiAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyAmJiBhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KWtu+4jyBSZXN1bWluZyBNYWluIENob3JkIGFuaW1hdGlvbjonLCByZWFzb24pO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgLy8gUmVzdGFydCB0aGUgYW5pbWF0aW9uIHRpbWVyIGltbWVkaWF0ZWx5XG4gICAgICBjb25zdCByZXN0YXJ0TWFpbkFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nIHx8IGFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSByZXR1cm47XG5cbiAgICAgICAgY29uc29sZS5sb2coJ/CflIQgUmVzdGFydGluZyBNYWluIENob3JkIGFuaW1hdGlvbiBhZnRlciBwYXVzZScpO1xuICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnaGlnaGxpZ2h0aW5nJyk7XG4gICAgICAgIHNldEhpZ2hsaWdodGVkQXJjSW5kZXgoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4KTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRTaWRlKGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aW1pbmcgYmFzZWQgb24gZ2xvYmFsIHNldHRpbmdzXG4gICAgICAgIGNvbnN0IHN0ZXBEdXJhdGlvbiA9IE1hdGgubWF4KDEwMDAsIChzZXR0aW5ncy5hdXRvUGxheVNwZWVkIHx8IDMwMDApIC8gNCk7XG4gICAgICAgIGNvbnN0IHBhdXNlRHVyYXRpb24gPSBNYXRoLm1heCgyMDAsIHN0ZXBEdXJhdGlvbiAvIDYpO1xuXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGRhdGEgY29udGV4dFxuICAgICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBzZXR0aW5ncy51c2VUZXN0RGF0YSA/IGRhdGEgOiBkYXRhLmZpbHRlcihpdGVtID0+ICEoaXRlbSBhcyBhbnkpLnRlc3RfZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlZnRWYWx1ZXMgPSBjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJ1xuICAgICAgICAgID8gWycwLTUnLCAnNi0xMCcsICcxMS0xNScsICcxNi0yMCcsICcyMCsnXVxuICAgICAgICAgIDogQXJyYXkuZnJvbShuZXcgU2V0KGZpbHRlcmVkRGF0YS5tYXAoZCA9PiAoZCBhcyBhbnkpW2N1cnJlbnRTb3VyY2VdKSkpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgY29uc3QgcmlnaHRWYWx1ZXMgPSBjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJ1xuICAgICAgICAgID8gWycwLTUnLCAnNi0xMCcsICcxMS0xNScsICcxNi0yMCcsICcyMCsnXVxuICAgICAgICAgIDogQXJyYXkuZnJvbShuZXcgU2V0KGZpbHRlcmVkRGF0YS5tYXAoZCA9PiAoZCBhcyBhbnkpW2N1cnJlbnRUYXJnZXRdKSkpLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50U2lkZUxlbmd0aCA9IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcgPyBsZWZ0VmFsdWVzLmxlbmd0aCA6IHJpZ2h0VmFsdWVzLmxlbmd0aDtcblxuICAgICAgICAvLyBDb250aW51ZSBhbmltYXRpb24gZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4IDwgY3VycmVudFNpZGVMZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gU3dpdGNoIHNpZGVzIG9yIHJlc3RhcnRcbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN0YXJ0TWFpbkFuaW1hdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RlcER1cmF0aW9uKTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHJlc3RhcnRNYWluQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlc3VtZSBzZWNvbmRhcnkgY2hvcmQgYW5pbWF0aW9uXG4gICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfilrbvuI8gUmVzdW1pbmcgU2Vjb25kYXJ5IENob3JkIGFuaW1hdGlvbjonLCByZWFzb24pO1xuICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgLy8gUmVzdGFydCB0aGUgc2Vjb25kYXJ5IGFuaW1hdGlvbiB0aW1lciBpbW1lZGlhdGVseVxuICAgICAgY29uc3QgcmVzdGFydFNlY29uZGFyeUFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nIHx8IHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSByZXR1cm47XG5cbiAgICAgICAgY29uc29sZS5sb2coJ/CflIQgUmVzdGFydGluZyBTZWNvbmRhcnkgQ2hvcmQgYW5pbWF0aW9uIGFmdGVyIHBhdXNlJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgc2Vjb25kYXJ5IGNob3JkIGRhdGEgY29udGV4dFxuICAgICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBzZXR0aW5ncy51c2VUZXN0RGF0YSA/IGRhdGEgOiBkYXRhLmZpbHRlcihpdGVtID0+ICEoaXRlbSBhcyBhbnkpLnRlc3RfZGF0YSk7XG4gICAgICAgIGNvbnN0IHNlY29uZGFyeURhdGEgPSBmaWx0ZXJlZERhdGEuZmlsdGVyKGQgPT4gKGQgYXMgYW55KS5wZWFrX3BlcmZvcm1hbmNlKTtcbiAgICAgICAgY29uc3QgeWVhcnNDYXRlZ29yaWVzID0gWycwLTUnLCAnNi0xMCcsICcxMS0xNScsICcxNi0yMCcsICcyMCsnXTtcbiAgICAgICAgY29uc3QgcGVha1BlcmZDYXRlZ29yaWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHNlY29uZGFyeURhdGEubWFwKGQgPT4gKGQgYXMgYW55KS5wZWFrX3BlcmZvcm1hbmNlKSkpLmZpbHRlcihCb29sZWFuKS5zb3J0KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGFjdHVhbCBhcmMgaW5kZXggYmFzZWQgb24gc2lkZSBhbmQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgYWN0dWFsQXJjSW5kZXggPSBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9PT0gJ2xlZnQnIFxuICAgICAgICAgID8gc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4IFxuICAgICAgICAgIDogeWVhcnNDYXRlZ29yaWVzLmxlbmd0aCArIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleDtcbiAgICAgICAgXG4gICAgICAgIHNldFNlY29uZGFyeUFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgICAgc2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRBcmNJbmRleChhY3R1YWxBcmNJbmRleCk7XG4gICAgICAgIHNldFNlY29uZGFyeUhpZ2hsaWdodGVkU2lkZShzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgdGltaW5nIGJhc2VkIG9uIGdsb2JhbCBzZXR0aW5nc1xuICAgICAgICBjb25zdCBzdGVwRHVyYXRpb24gPSBNYXRoLm1heCgxMDAwLCAoc2V0dGluZ3MuYXV0b1BsYXlTcGVlZCB8fCAzMDAwKSAvIDQpO1xuICAgICAgICBjb25zdCBjdXJyZW50U2lkZUxlbmd0aCA9IHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcgPyB5ZWFyc0NhdGVnb3JpZXMubGVuZ3RoIDogcGVha1BlcmZDYXRlZ29yaWVzLmxlbmd0aDtcblxuICAgICAgICAvLyBDb250aW51ZSBhbmltYXRpb24gZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIXNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBpZiAoc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4IDwgY3VycmVudFNpZGVMZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gU3dpdGNoIHNpZGVzIG9yIHJlc3RhcnRcbiAgICAgICAgICAgICAgaWYgKHNlY29uZGFyeUFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5QW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U2lkZSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlBbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN0YXJ0U2Vjb25kYXJ5QW5pbWF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBzdGVwRHVyYXRpb24pO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgcmVzdGFydFNlY29uZGFyeUFuaW1hdGlvbigpO1xuICAgIH1cbiAgfSwgW3NldHRpbmdzLmF1dG9QbGF5U3BlZWQsIHNldHRpbmdzLnVzZVRlc3REYXRhLCBkYXRhLCBjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0XSk7XG5cbiAgLy8gQ2hlY2sgaWYgY29udGFpbmVyIGlzIHRvbyBzbWFsbFxuICBjb25zdCBtYXJnaW4gPSB7IHRvcDogODAsIHJpZ2h0OiA4MCwgYm90dG9tOiAxMDAsIGxlZnQ6IDgwIH07XG4gIGNvbnN0IGNoYXJ0V2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuICBjb25zdCBjaGFydEhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICBjb25zdCBpc0NvbnRhaW5lclRvb1NtYWxsID0gY2hhcnRXaWR0aCA8IDIwMCB8fCBjaGFydEhlaWdodCA8IDIwMDtcblxuICAvLyBSZW5kZXIgY2lyY3VsYXIgY2hvcmQgZGlhZ3JhbVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc3ZnUmVmLmN1cnJlbnQgfHwgIWRhdGEubGVuZ3RoIHx8IGlzTG9hZGluZyB8fCBpc0NvbnRhaW5lclRvb1NtYWxsKSByZXR1cm47XG5cbiAgICAvLyBDbGVhciBwcmV2aW91cyBjb250ZW50XG4gICAgZDMuc2VsZWN0KHN2Z1JlZi5jdXJyZW50KS5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcblxuICAgIC8vIEZpbHRlciBkYXRhIGJhc2VkIG9uIGdsb2JhbCBzZXR0aW5nc1xuICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IHNldHRpbmdzLnVzZVRlc3REYXRhIFxuICAgICAgPyBkYXRhIFxuICAgICAgOiBkYXRhLmZpbHRlcihpdGVtID0+ICEoaXRlbSBhcyBhbnkpLnRlc3RfZGF0YSk7XG5cbiAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3Qoc3ZnUmVmLmN1cnJlbnQpO1xuICAgIFxuICAgIC8vIEFkanVzdCBzaXplIGJhc2VkIG9uIHdoZXRoZXIgd2UncmUgc2hvd2luZyB0d28gY2hvcmRzXG4gICAgY29uc3QgZWZmZWN0aXZlV2lkdGggPSBzaG93U2Vjb25kYXJ5Q2hvcmQgPyB3aWR0aCAqIDAuNDUgOiB3aWR0aDtcbiAgICBjb25zdCBlZmZlY3RpdmVIZWlnaHQgPSBzaG93U2Vjb25kYXJ5Q2hvcmQgPyBoZWlnaHQgKiAwLjggOiBoZWlnaHQgKiAwLjg1O1xuICAgIGNvbnN0IGVmZmVjdGl2ZUNoYXJ0V2lkdGggPSBlZmZlY3RpdmVXaWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuICAgIGNvbnN0IGVmZmVjdGl2ZUNoYXJ0SGVpZ2h0ID0gZWZmZWN0aXZlSGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgXG4gICAgY29uc3QgcmFkaXVzID0gTWF0aC5tYXgoMTIwLCBNYXRoLm1pbihlZmZlY3RpdmVDaGFydFdpZHRoLCBlZmZlY3RpdmVDaGFydEhlaWdodCkgLyAyIC0gNjApO1xuXG4gICAgLy8gQ3JlYXRlIGRlZmluaXRpb25zIGZvciBncmFkaWVudHNcbiAgICBjb25zdCBkZWZzID0gc3ZnLmFwcGVuZCgnZGVmcycpO1xuXG4gICAgLy8gRGVmaW5lIGZpeGVkIG9yZGVyIGZvciB5ZWFycyBhdCBNZWR0cm9uaWNcbiAgICBjb25zdCBZRUFSU19HUk9VUFMgPSBbJzAtNScsICc2LTEwJywgJzExLTE1JywgJzE2LTIwJywgJzIwKyddO1xuXG4gICAgLy8gR2V0IHVuaXF1ZSB2YWx1ZXMgZm9yIGxlZnQgYW5kIHJpZ2h0IHNpZGVzLCB1c2luZyBmaXhlZCBvcmRlciBmb3IgeWVhcnNcbiAgICBjb25zdCBsZWZ0VmFsdWVzID0gY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYydcbiAgICAgID8gWUVBUlNfR1JPVVBTXG4gICAgICA6IEFycmF5LmZyb20obmV3IFNldChmaWx0ZXJlZERhdGEubWFwKGQgPT4gKGQgYXMgYW55KVtjdXJyZW50U291cmNlXSkpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgY29uc3QgcmlnaHRWYWx1ZXMgPSBjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJ1xuICAgICAgPyBZRUFSU19HUk9VUFNcbiAgICAgIDogQXJyYXkuZnJvbShuZXcgU2V0KGZpbHRlcmVkRGF0YS5tYXAoZCA9PiAoZCBhcyBhbnkpW2N1cnJlbnRUYXJnZXRdKSkpLmZpbHRlcihCb29sZWFuKTtcblxuICAgIC8vIFByb2Nlc3MgZGF0YSBmb3IgY2hvcmQgbGF5b3V0XG4gICAgY29uc3QgY2hvcmREYXRhID0gcHJvY2Vzc0Nob3JkRGF0YShmaWx0ZXJlZERhdGEsIGN1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXQpO1xuICAgIFxuICAgIC8vIFNlcGFyYXRlIHNvdXJjZSBhbmQgdGFyZ2V0IGNhdGVnb3JpZXNcbiAgICBjb25zdCBzb3VyY2VDYXRlZ29yaWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgdGFyZ2V0Q2F0ZWdvcmllcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIFxuICAgIGZpbHRlcmVkRGF0YS5mb3JFYWNoKChkOiBhbnkpID0+IHtcbiAgICAgIGlmIChjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgICAgICBzb3VyY2VDYXRlZ29yaWVzLmFkZChnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUNhdGVnb3JpZXMuYWRkKGRbY3VycmVudFNvdXJjZV0gfHwgJ1Vua25vd24nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgICAgIHRhcmdldENhdGVnb3JpZXMuYWRkKGdldFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Q2F0ZWdvcmllcy5hZGQoZFtjdXJyZW50VGFyZ2V0XSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ29udmVydCB0byBhcnJheXMgYW5kIHNvcnRcbiAgICBjb25zdCBzb3VyY2VBcnJheSA9IEFycmF5LmZyb20oc291cmNlQ2F0ZWdvcmllcykuc29ydCgpIGFzIHN0cmluZ1tdO1xuICAgIGNvbnN0IHRhcmdldEFycmF5ID0gQXJyYXkuZnJvbSh0YXJnZXRDYXRlZ29yaWVzKS5zb3J0KCkgYXMgc3RyaW5nW107XG5cbiAgICAvLyBDYWxjdWxhdGUgdG90YWxzIGZvciBlYWNoIGNhdGVnb3J5XG4gICAgY29uc3QgbGVmdFRvdGFscyA9IHNvdXJjZUFycmF5Lm1hcChjYXQgPT4gXG4gICAgICBmaWx0ZXJlZERhdGEuZmlsdGVyKChkOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJyBcbiAgICAgICAgICA/IGdldFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMCkgXG4gICAgICAgICAgOiBkW2N1cnJlbnRTb3VyY2VdO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IGNhdDtcbiAgICAgIH0pLmxlbmd0aFxuICAgICk7XG4gICAgXG4gICAgY29uc3QgcmlnaHRUb3RhbHMgPSB0YXJnZXRBcnJheS5tYXAoY2F0ID0+IFxuICAgICAgZmlsdGVyZWREYXRhLmZpbHRlcigoZDogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudFRhcmdldCA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycgXG4gICAgICAgICAgPyBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApIFxuICAgICAgICAgIDogZFtjdXJyZW50VGFyZ2V0XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBjYXQ7XG4gICAgICB9KS5sZW5ndGhcbiAgICApO1xuXG4gICAgY29uc3QgbGVmdFRvdGFsU3VtID0gbGVmdFRvdGFscy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApO1xuICAgIGNvbnN0IHJpZ2h0VG90YWxTdW0gPSByaWdodFRvdGFscy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApO1xuXG4gICAgLy8gQ3JlYXRlIGNvbm5lY3Rpb24gbWF0cml4XG4gICAgY29uc3QgY29ubmVjdGlvbk1hdHJpeCA9IHNvdXJjZUFycmF5Lm1hcChzb3VyY2VDYXQgPT4gXG4gICAgICB0YXJnZXRBcnJheS5tYXAodGFyZ2V0Q2F0ID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkRGF0YS5maWx0ZXIoKGQ6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnIFxuICAgICAgICAgICAgPyBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApIFxuICAgICAgICAgICAgOiBkW2N1cnJlbnRTb3VyY2VdO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnIFxuICAgICAgICAgICAgPyBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApIFxuICAgICAgICAgICAgOiBkW2N1cnJlbnRUYXJnZXRdO1xuICAgICAgICAgIHJldHVybiBzb3VyY2UgPT09IHNvdXJjZUNhdCAmJiB0YXJnZXQgPT09IHRhcmdldENhdDtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGNhdGVnb3J5IGNoYW5nZSB0aGF0IHNob3VsZCB0cmlnZ2VyIGFuaW1hdGlvblxuICAgIGNvbnN0IGlzQ2F0ZWdvcnlDaGFuZ2UgPSBsYXN0Q2F0ZWdvcnlDaGFuZ2Uuc291cmNlICE9PSBjdXJyZW50U291cmNlIHx8IGxhc3RDYXRlZ29yeUNoYW5nZS50YXJnZXQgIT09IGN1cnJlbnRUYXJnZXQ7XG4gICAgXG4gICAgLy8gQWRkIHNtb290aCB0cmFuc2l0aW9ucyBmb3IgY2F0ZWdvcnkgY2hhbmdlc1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSBkMy50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbihpc0NhdGVnb3J5Q2hhbmdlID8gNzUwIDogMjAwKVxuICAgICAgLmVhc2UoZDMuZWFzZUN1YmljSW5PdXQpO1xuICAgIFxuICAgIC8vIEZhc3RlciB0cmFuc2l0aW9uIGZvciBob3ZlciBpbnRlcmFjdGlvbnNcbiAgICBjb25zdCBob3ZlclRyYW5zaXRpb24gPSBkMy50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbig3NSlcbiAgICAgIC5lYXNlKGQzLmVhc2VRdWFkT3V0KTtcblxuICAgIC8vIC0tLSBUcnVlIGxlZnQvcmlnaHQgYmlwYXJ0aXRlIGxheW91dCB3aXRoIGJldHRlciBzcGFjaW5nIC0tLVxuICAgIC8vIExlZnQgYXJjczogMTgwwrArZ2FwIHRvIDM2MMKwLWdhcCAoTWF0aC5QSStnYXAgdG8gMipNYXRoLlBJLWdhcClcbiAgICAvLyBSaWdodCBhcmNzOiAwK2dhcCB0byAxODDCsC1nYXAgKDArZ2FwIHRvIE1hdGguUEktZ2FwKVxuICAgIGNvbnN0IGFyY0dhcCA9IE1hdGguUEkgKiAwLjEyOyAvLyBMYXJnZXIgZ2FwIGZvciBiZXR0ZXIgbGFiZWwgc3BhY2luZ1xuICAgIGNvbnN0IGxlZnRTdGFydCA9IE1hdGguUEkgKyBhcmNHYXA7ICAgICAgLy8gMTgwwrAgKyBnYXBcbiAgICBjb25zdCBsZWZ0RW5kID0gMiAqIE1hdGguUEkgLSBhcmNHYXA7ICAgIC8vIDM2MMKwIC0gZ2FwXG4gICAgY29uc3QgcmlnaHRTdGFydCA9IDAgKyBhcmNHYXA7ICAgICAgICAgICAvLyAwwrAgKyBnYXBcbiAgICBjb25zdCByaWdodEVuZCA9IE1hdGguUEkgLSBhcmNHYXA7ICAgICAgIC8vIDE4MMKwIC0gZ2FwXG4gICAgY29uc3QgbGVmdEFyY1NwYW4gPSBsZWZ0RW5kIC0gbGVmdFN0YXJ0OyAgICAgLy8gMTgwwrAgLSAyKmdhcFxuICAgIGNvbnN0IHJpZ2h0QXJjU3BhbiA9IHJpZ2h0RW5kIC0gcmlnaHRTdGFydDsgIC8vIDE4MMKwIC0gMipnYXBcblxuICAgIC8vIEFkZCBtaW5pbXVtIHNwYWNpbmcgYmV0d2VlbiBhcmNzIHRvIHByZXZlbnQgbGFiZWwgb3ZlcmxhcFxuICAgIGNvbnN0IG1pbkFyY1NwYWNpbmcgPSBNYXRoLlBJICogMC4wMjsgLy8gTWluaW11bSAywrAgYmV0d2VlbiBhcmNzXG5cbiAgICAvLyBBc3NpZ24gYXJjIGFuZ2xlcyBmb3IgbGVmdCBhcmNzIHdpdGggcHJvcGVyIHNwYWNpbmdcbiAgICBsZXQgbGVmdEFuZ2xlID0gbGVmdFN0YXJ0O1xuICAgIGNvbnN0IGxlZnRBcmNzID0gbGVmdFZhbHVlcy5tYXAoKHZhbHVlLCBpKSA9PiB7XG4gICAgICBjb25zdCBjb3VudCA9IGZpbHRlcmVkRGF0YS5maWx0ZXIoZCA9PlxuICAgICAgICBjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJ1xuICAgICAgICAgID8gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSA9PT0gdmFsdWVcbiAgICAgICAgICA6IChkIGFzIGFueSlbY3VycmVudFNvdXJjZV0gPT09IHZhbHVlXG4gICAgICApLmxlbmd0aDtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGFyYyBzcGFuIHdpdGggc3BhY2luZyBjb25zaWRlcmF0aW9uXG4gICAgICBjb25zdCBhdmFpbGFibGVTcGFuID0gbGVmdEFyY1NwYW4gLSAobWluQXJjU3BhY2luZyAqIChsZWZ0VmFsdWVzLmxlbmd0aCAtIDEpKTtcbiAgICAgIGNvbnN0IGFyY1NwYW4gPSBjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJ1xuICAgICAgICA/IGF2YWlsYWJsZVNwYW4gLyBsZWZ0VmFsdWVzLmxlbmd0aFxuICAgICAgICA6IE1hdGgubWF4KG1pbkFyY1NwYWNpbmcsIGF2YWlsYWJsZVNwYW4gKiAoY291bnQgLyAobGVmdFRvdGFsU3VtIHx8IDEpKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBsZWZ0QW5nbGU7XG4gICAgICBjb25zdCBlbmRBbmdsZSA9IGxlZnRBbmdsZSArIGFyY1NwYW47XG4gICAgICBsZWZ0QW5nbGUgPSBlbmRBbmdsZSArIG1pbkFyY1NwYWNpbmc7IC8vIEFkZCBzcGFjaW5nIGJldHdlZW4gYXJjc1xuICAgICAgXG4gICAgICBjb25zdCBjb2xvciA9IGdldE5vZGVDb2xvcih2YWx1ZSwgY3VycmVudFNvdXJjZSwgc2V0dGluZ3MuY2F0ZWdvcnlDb2xvcnMsIHNldHRpbmdzLmlzRGFya01vZGUpO1xuICAgICAgY29uc3Qgb3BhY2l0eSA9IGNvdW50ID09PSAwID8gMC4xNSA6IDAuODtcbiAgICAgIHJldHVybiB7IG5hbWU6IHZhbHVlLCB2YWx1ZTogY291bnQsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb2xvciwgb3BhY2l0eSB9O1xuICAgIH0pO1xuXG4gICAgLy8gQXNzaWduIGFyYyBhbmdsZXMgZm9yIHJpZ2h0IGFyY3Mgd2l0aCBwcm9wZXIgc3BhY2luZ1xuICAgIGxldCByaWdodEFuZ2xlID0gcmlnaHRTdGFydDtcbiAgICBjb25zdCByaWdodEFyY3MgPSByaWdodFZhbHVlcy5tYXAoKHZhbHVlLCBpKSA9PiB7XG4gICAgICBjb25zdCBjb3VudCA9IGZpbHRlcmVkRGF0YS5maWx0ZXIoZCA9PlxuICAgICAgICBjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJ1xuICAgICAgICAgID8gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSA9PT0gdmFsdWVcbiAgICAgICAgICA6IChkIGFzIGFueSlbY3VycmVudFRhcmdldF0gPT09IHZhbHVlXG4gICAgICApLmxlbmd0aDtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGFyYyBzcGFuIHdpdGggc3BhY2luZyBjb25zaWRlcmF0aW9uXG4gICAgICBjb25zdCBhdmFpbGFibGVTcGFuID0gcmlnaHRBcmNTcGFuIC0gKG1pbkFyY1NwYWNpbmcgKiAocmlnaHRWYWx1ZXMubGVuZ3RoIC0gMSkpO1xuICAgICAgY29uc3QgYXJjU3BhbiA9IGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICAgID8gYXZhaWxhYmxlU3BhbiAvIHJpZ2h0VmFsdWVzLmxlbmd0aFxuICAgICAgICA6IE1hdGgubWF4KG1pbkFyY1NwYWNpbmcsIGF2YWlsYWJsZVNwYW4gKiAoY291bnQgLyAocmlnaHRUb3RhbFN1bSB8fCAxKSkpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydEFuZ2xlID0gcmlnaHRBbmdsZTtcbiAgICAgIGNvbnN0IGVuZEFuZ2xlID0gcmlnaHRBbmdsZSArIGFyY1NwYW47XG4gICAgICByaWdodEFuZ2xlID0gZW5kQW5nbGUgKyBtaW5BcmNTcGFjaW5nOyAvLyBBZGQgc3BhY2luZyBiZXR3ZWVuIGFyY3NcbiAgICAgIFxuICAgICAgY29uc3QgY29sb3IgPSBnZXROb2RlQ29sb3IodmFsdWUsIGN1cnJlbnRUYXJnZXQsIHNldHRpbmdzLmNhdGVnb3J5Q29sb3JzLCBzZXR0aW5ncy5pc0RhcmtNb2RlKTtcbiAgICAgIGNvbnN0IG9wYWNpdHkgPSBjb3VudCA9PT0gMCA/IDAuMTUgOiAwLjg7XG4gICAgICByZXR1cm4geyBuYW1lOiB2YWx1ZSwgdmFsdWU6IGNvdW50LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY29sb3IsIG9wYWNpdHkgfTtcbiAgICB9KTtcblxuICAgIC8vIERyYXcgYXJjcyAodXNlIHBlci1hcmMgb3BhY2l0eSlcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KDYwLCByYWRpdXMgKiAwLjc1KTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDgwLCByYWRpdXMgKiAwLjk1KTtcbiAgICBjb25zdCBhcmNHZW4gPSBkMy5hcmMoKVxuICAgICAgLmlubmVyUmFkaXVzKGlubmVyUmFkaXVzKVxuICAgICAgLm91dGVyUmFkaXVzKG91dGVyUmFkaXVzKVxuICAgICAgLmNvcm5lclJhZGl1cygoZDogYW55KSA9PiB7XG4gICAgICAgIC8vIE9ubHkgcm91bmQgdGhlIG91dGVyIGNvcm5lcnMgKG91dGVyUmFkaXVzKSwgbm90IHRoZSBpbm5lclxuICAgICAgICAvLyBEMyB2Nysgc3VwcG9ydHMgY29ybmVyUmFkaXVzIGFzIGEgZnVuY3Rpb25cbiAgICAgICAgLy8gV2UnbGwgcmV0dXJuIDAgZm9yIGlubmVyLCA4IGZvciBvdXRlclxuICAgICAgICAvLyBCdXQgZDMuYXJjKCkgb25seSBzdXBwb3J0cyBvbmUgdmFsdWUsIHNvIHdlIG5lZWQgdG8gdXNlIGN1c3RvbSBwYXRoIGlmIHdlIHdhbnQgdHJ1ZSBzcXVhcmVkIGlubmVyIGNvcm5lcnNcbiAgICAgICAgLy8gQXMgYSB3b3JrYXJvdW5kLCBzZXQgY29ybmVyUmFkaXVzIHRvIDAgaWYgdGhlIGFyYyBpcyBzbWFsbCwgZWxzZSA4XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICAgXG4gICAgLy8gUG9zaXRpb24gdGhlIGNoYXJ0IGdyb3VwIHdpdGggbWFyZ2lucyB0byBwcmV2ZW50IGNyb3BwaW5nXG4gICAgY29uc3QgZyA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnQgKyBlZmZlY3RpdmVDaGFydFdpZHRoIC8gMn0sICR7bWFyZ2luLnRvcCArIGVmZmVjdGl2ZUNoYXJ0SGVpZ2h0IC8gMn0pYCk7XG5cbiAgICAvLyBBZGQgZ3JhZGllbnRzIGZvciBhcmNzXG4gICAgbGVmdEFyY3MuZm9yRWFjaCgoYXJjLCBpKSA9PiB7XG4gICAgICBjb25zdCBiYXNlQ29sb3IgPSBhcmMuY29sb3I7XG4gICAgICBjb25zdCBsaWdodGVyQ29sb3IgPSBkMy5jb2xvcihiYXNlQ29sb3IpPy5icmlnaHRlcigwLjMpLnRvU3RyaW5nKCkgfHwgYmFzZUNvbG9yO1xuICAgICAgZGVmcy5hcHBlbmQoJ2xpbmVhckdyYWRpZW50JylcbiAgICAgICAgLmF0dHIoJ2lkJywgYGxlZnQtYXJjLWdyYWRpZW50LSR7aX1gKVxuICAgICAgICAuYXR0cignZ3JhZGllbnRVbml0cycsICd1c2VyU3BhY2VPblVzZScpXG4gICAgICAgIC5hdHRyKCd4MScsIDApXG4gICAgICAgIC5hdHRyKCd5MScsIDApXG4gICAgICAgIC5hdHRyKCd4MicsIDApXG4gICAgICAgIC5hdHRyKCd5MicsIDEpXG4gICAgICAgIC5zZWxlY3RBbGwoJ3N0b3AnKVxuICAgICAgICAuZGF0YShbXG4gICAgICAgICAgeyBvZmZzZXQ6ICcwJScsIGNvbG9yOiBiYXNlQ29sb3IgfSxcbiAgICAgICAgICB7IG9mZnNldDogJzEwMCUnLCBjb2xvcjogbGlnaHRlckNvbG9yIH1cbiAgICAgICAgXSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgnc3RvcCcpXG4gICAgICAgIC5hdHRyKCdvZmZzZXQnLCBkID0+IGQub2Zmc2V0KVxuICAgICAgICAuYXR0cignc3RvcC1jb2xvcicsIGQgPT4gZC5jb2xvcik7XG4gICAgfSk7XG4gICAgcmlnaHRBcmNzLmZvckVhY2goKGFyYywgaSkgPT4ge1xuICAgICAgY29uc3QgYmFzZUNvbG9yID0gYXJjLmNvbG9yO1xuICAgICAgY29uc3QgbGlnaHRlckNvbG9yID0gZDMuY29sb3IoYmFzZUNvbG9yKT8uYnJpZ2h0ZXIoMC4zKS50b1N0cmluZygpIHx8IGJhc2VDb2xvcjtcbiAgICAgIGRlZnMuYXBwZW5kKCdsaW5lYXJHcmFkaWVudCcpXG4gICAgICAgIC5hdHRyKCdpZCcsIGByaWdodC1hcmMtZ3JhZGllbnQtJHtpfWApXG4gICAgICAgIC5hdHRyKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJylcbiAgICAgICAgLmF0dHIoJ3gxJywgMClcbiAgICAgICAgLmF0dHIoJ3kxJywgMClcbiAgICAgICAgLmF0dHIoJ3gyJywgMClcbiAgICAgICAgLmF0dHIoJ3kyJywgMSlcbiAgICAgICAgLnNlbGVjdEFsbCgnc3RvcCcpXG4gICAgICAgIC5kYXRhKFtcbiAgICAgICAgICB7IG9mZnNldDogJzAlJywgY29sb3I6IGJhc2VDb2xvciB9LFxuICAgICAgICAgIHsgb2Zmc2V0OiAnMTAwJScsIGNvbG9yOiBsaWdodGVyQ29sb3IgfVxuICAgICAgICBdKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdzdG9wJylcbiAgICAgICAgLmF0dHIoJ29mZnNldCcsIGQgPT4gZC5vZmZzZXQpXG4gICAgICAgIC5hdHRyKCdzdG9wLWNvbG9yJywgZCA9PiBkLmNvbG9yKTtcbiAgICB9KTtcbiAgICAvLyBDcmVhdGUgbGVmdCBhcmNzIHdpdGggZXZlbnQgaGFuZGxlcnMgZmlyc3RcbiAgICBjb25zdCBsZWZ0QXJjU2VsZWN0aW9uID0gZy5zZWxlY3RBbGwoJ3BhdGgubGVmdC1hcmMnKVxuICAgICAgLmRhdGEobGVmdEFyY3MpXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAnbGVmdC1hcmMnKVxuICAgICAgLmF0dHIoJ2QnLCBkID0+IGFyY0dlbih7IHN0YXJ0QW5nbGU6IGQuc3RhcnRBbmdsZSwgZW5kQW5nbGU6IGQuZW5kQW5nbGUgfSBhcyBhbnkpKVxuICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCwgaSkgPT4gYHVybCgjbGVmdC1hcmMtZ3JhZGllbnQtJHtpfSlgKVxuICAgICAgLmF0dHIoJ29wYWNpdHknLCAwKVxuICAgICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZXZlbnQsIGQ6IGFueSkge1xuICAgICAgICBpZiAoZC52YWx1ZSA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgcGF1c2VBbmltYXRpb24oJ2xlZnQgYXJjIGhvdmVyJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBzYW1lIGhpZ2hsaWdodGluZyBhcyBhdXRvLWN5Y2xlIGFuaW1hdGlvblxuICAgICAgICBjb25zdCBhcmNJbmRleCA9IGxlZnRBcmNzLmZpbmRJbmRleChhcmMgPT4gYXJjLm5hbWUgPT09IGQubmFtZSk7XG4gICAgICAgIFxuICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnaGlnaGxpZ2h0aW5nJyk7XG4gICAgICAgIHNldEhpZ2hsaWdodGVkQXJjSW5kZXgoYXJjSW5kZXgpO1xuICAgICAgICBzZXRIaWdobGlnaHRlZFNpZGUoJ2xlZnQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IGltbWVkaWF0ZSBob3ZlciB0cmFuc2l0aW9uc1xuICAgICAgICBnLnNlbGVjdEFsbCgncGF0aC5sZWZ0LWFyYywgcGF0aC5yaWdodC1hcmMsIHBhdGgucmliYm9uJylcbiAgICAgICAgICAudHJhbnNpdGlvbihob3ZlclRyYW5zaXRpb24pXG4gICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBmdW5jdGlvbih0aGlzLCBob3ZlckQ6IGFueSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzZWQoJ2xlZnQtYXJjJykpIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IGxlZnRBcmNzLmZpbmRJbmRleChhcmMgPT4gYXJjLm5hbWUgPT09IGhvdmVyRC5uYW1lKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGkgPT09IGFyY0luZGV4ID8gMS4wIDogMC40O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmNsYXNzZWQoJ3JpZ2h0LWFyYycpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGkgPSByaWdodEFyY3MuZmluZEluZGV4KGFyYyA9PiBhcmMubmFtZSA9PT0gaG92ZXJELm5hbWUpO1xuICAgICAgICAgICAgICBjb25zdCBtYXRyaXhWYWx1ZSA9IGNvbm5lY3Rpb25NYXRyaXhbYXJjSW5kZXhdICYmIGNvbm5lY3Rpb25NYXRyaXhbYXJjSW5kZXhdW2ldO1xuICAgICAgICAgICAgICByZXR1cm4gbWF0cml4VmFsdWUgPiAwID8gMC45NSA6IDAuMztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5jbGFzc2VkKCdyaWJib24nKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaG92ZXJELnNvdXJjZS5pbmRleCA9PT0gYXJjSW5kZXggPyAwLjk1IDogMC4yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuMztcbiAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHNldFRvb2x0aXAoe1xuICAgICAgICAgIHg6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgIHk6IGV2ZW50LnBhZ2VZLFxuICAgICAgICAgIGNvbnRlbnQ6IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5Cb3R0b206IDQgfX0+eyhkLm5hbWUgfHwgJ1Vua25vd24nKS50b1N0cmluZygpLnJlcGxhY2UoL18vZywgJyAnKX08L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdj5Db3VudDoge2QudmFsdWV9PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5vbignbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgcmVzdW1lQW5pbWF0aW9uKCdsZWZ0IGFyYyBob3ZlciBlbmQnKTtcbiAgICAgICAgc2V0VG9vbHRpcChudWxsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IGhpZ2hsaWdodGluZyB3aGVuIGFuaW1hdGlvbiByZXN1bWVzXG4gICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICAgIHNldEhpZ2hsaWdodGVkQXJjSW5kZXgobnVsbCk7XG4gICAgICAgIHNldEhpZ2hsaWdodGVkU2lkZShudWxsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IGltbWVkaWF0ZSByZXNldCB0cmFuc2l0aW9uc1xuICAgICAgICBnLnNlbGVjdEFsbCgncGF0aC5sZWZ0LWFyYywgcGF0aC5yaWdodC1hcmMsIHBhdGgucmliYm9uJylcbiAgICAgICAgICAudHJhbnNpdGlvbihob3ZlclRyYW5zaXRpb24pXG4gICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBmdW5jdGlvbih0aGlzLCByZXNldEQ6IGFueSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzZWQoJ2xlZnQtYXJjJykgfHwgZWxlbWVudC5jbGFzc2VkKCdyaWdodC1hcmMnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMC44LCByZXNldEQub3BhY2l0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuY2xhc3NlZCgncmliYm9uJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjcgOiAwLjY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC44O1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgXG4gICAgLy8gQXBwbHkgdHJhbnNpdGlvbiBhbmltYXRpb25zIHNlcGFyYXRlbHlcbiAgICBsZWZ0QXJjU2VsZWN0aW9uXG4gICAgICAudHJhbnNpdGlvbih0cmFuc2l0aW9uKVxuICAgICAgLmF0dHIoJ29wYWNpdHknLCAoZCwgaSkgPT4ge1xuICAgICAgICAvLyBBcHBseSBmdWxsIHJlbGF0aW9uc2hpcCBjaGFpbiBoaWdobGlnaHRpbmdcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IHRoZSBzb3VyY2UgYXJjXG4gICAgICAgICAgICBpZiAoaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gMS4wOyAvLyBTb3VyY2UgYXJjIGlzIGZ1bGx5IGhpZ2hsaWdodGVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGFyYyBpcyBjb25uZWN0ZWQgdG8gdGhlIGhpZ2hsaWdodGVkIHJpZ2h0IGFyY1xuICAgICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ2xlZnQnICYmIGhpZ2hsaWdodGVkQXJjSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDAuNDsgLy8gRGltIG90aGVyIGxlZnQgYXJjc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAncmlnaHQnICYmIGhpZ2hsaWdodGVkQXJjSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcmlnaHQgYXJjIGlzIGhpZ2hsaWdodGVkLCBoaWdobGlnaHQgbGVmdCBhcmNzIGNvbm5lY3RlZCB0byBpdFxuICAgICAgICAgICAgY29uc3QgbWF0cml4VmFsdWUgPSBjb25uZWN0aW9uTWF0cml4W2ldICYmIGNvbm5lY3Rpb25NYXRyaXhbaV1baGlnaGxpZ2h0ZWRBcmNJbmRleF07XG4gICAgICAgICAgICBjb25zdCBpc0Nvbm5lY3RlZFRvSGlnaGxpZ2h0ZWRSaWdodCA9IG1hdHJpeFZhbHVlID4gMDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SXIExlZnQgYXJjICR7aX0gKCR7bGVmdEFyY3NbaV0/Lm5hbWV9KSBjb25uZWN0ZWQgdG8gcmlnaHQgYXJjICR7aGlnaGxpZ2h0ZWRBcmNJbmRleH0gKCR7cmlnaHRBcmNzW2hpZ2hsaWdodGVkQXJjSW5kZXhdPy5uYW1lfSk/YCwgXG4gICAgICAgICAgICAgIGlzQ29ubmVjdGVkVG9IaWdobGlnaHRlZFJpZ2h0LCAnTWF0cml4IHZhbHVlOicsIG1hdHJpeFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBpc0Nvbm5lY3RlZFRvSGlnaGxpZ2h0ZWRSaWdodCA/IDAuOTUgOiAwLjM7IC8vIEhpZ2hlciBjb250cmFzdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVc2Ugc3RhYmxlIGJhc2Ugb3BhY2l0eSB3aXRob3V0IHB1bHNpbmcgdG8gcHJldmVudCBmbGlja2VyaW5nXG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLjgsIGQub3BhY2l0eSk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgIC8vIEVuaGFuY2VkIHN0cm9rZSBmb3IgcmVsYXRpb25zaGlwIGNoYWluXG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaSA9PT0gaGlnaGxpZ2h0ZWRBcmNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIDM7IC8vIFRoaWNrZXN0IHN0cm9rZSBmb3Igc291cmNlIGFyY1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTdHJva2UgZm9yIGNvbm5lY3RlZCBhcmNzIHdoZW4gcmlnaHQgc2lkZSBpcyBoaWdobGlnaHRlZFxuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbWF0cml4VmFsdWUgPSBjb25uZWN0aW9uTWF0cml4W2ldICYmIGNvbm5lY3Rpb25NYXRyaXhbaV1baGlnaGxpZ2h0ZWRBcmNJbmRleF07XG4gICAgICAgICAgICBpZiAobWF0cml4VmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiAyOyAvLyBNZWRpdW0gc3Ryb2tlIGZvciBjb25uZWN0ZWQgYXJjc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pXG4gICAgICAuYXR0cignc3Ryb2tlJywgKGQsIGkpID0+IHtcbiAgICAgICAgLy8gRW5oYW5jZWQgc3Ryb2tlIGNvbG9yIGZvciByZWxhdGlvbnNoaXAgY2hhaW5cbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdsZWZ0JyAmJiBpID09PSBoaWdobGlnaHRlZEFyY0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknIDogJ3JnYmEoMCwwLDAsMC4zKSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFN0cm9rZSBmb3IgY29ubmVjdGVkIGFyY3Mgd2hlbiByaWdodCBzaWRlIGlzIGhpZ2hsaWdodGVkXG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ3JpZ2h0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhWYWx1ZSA9IGNvbm5lY3Rpb25NYXRyaXhbaV0gJiYgY29ubmVjdGlvbk1hdHJpeFtpXVtoaWdobGlnaHRlZEFyY0luZGV4XTtcbiAgICAgICAgICAgIGlmIChtYXRyaXhWYWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmlzRGFya01vZGUgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjMpJyA6ICdyZ2JhKDAsMCwwLDAuMiknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgfSk7XG4gICAgLy8gQ3JlYXRlIHJpZ2h0IGFyY3Mgd2l0aCBldmVudCBoYW5kbGVycyBmaXJzdFxuICAgIGNvbnN0IHJpZ2h0QXJjU2VsZWN0aW9uID0gZy5zZWxlY3RBbGwoJ3BhdGgucmlnaHQtYXJjJylcbiAgICAgIC5kYXRhKHJpZ2h0QXJjcylcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdwYXRoJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdyaWdodC1hcmMnKVxuICAgICAgLmF0dHIoJ2QnLCBkID0+IGFyY0dlbih7IHN0YXJ0QW5nbGU6IGQuc3RhcnRBbmdsZSwgZW5kQW5nbGU6IGQuZW5kQW5nbGUgfSBhcyBhbnkpKVxuICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCwgaSkgPT4gYHVybCgjcmlnaHQtYXJjLWdyYWRpZW50LSR7aX0pYClcbiAgICAgIC5hdHRyKCdvcGFjaXR5JywgMClcbiAgICAgIC5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKGV2ZW50LCBkOiBhbnkpIHtcbiAgICAgICAgaWYgKGQudmFsdWUgPT09IDApIHJldHVybjtcbiAgICAgICAgcGF1c2VBbmltYXRpb24oJ2FyYyBob3ZlcicpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgc2FtZSBoaWdobGlnaHRpbmcgYXMgYXV0by1jeWNsZSBhbmltYXRpb25cbiAgICAgICAgY29uc3QgYXJjSW5kZXggPSByaWdodEFyY3MuZmluZEluZGV4KGFyYyA9PiBhcmMubmFtZSA9PT0gZC5uYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gSG92ZXIgdHJpZ2dlcmluZyByaWdodCBhcmMgaGlnaGxpZ2h0aW5nOicsIHtcbiAgICAgICAgICBhcmNOYW1lOiBkLm5hbWUsXG4gICAgICAgICAgYXJjSW5kZXg6IGFyY0luZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgICBzZXRIaWdobGlnaHRlZEFyY0luZGV4KGFyY0luZGV4KTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRTaWRlKCdyaWdodCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gQXBwbHkgaW1tZWRpYXRlIGhvdmVyIHRyYW5zaXRpb25zXG4gICAgICAgIGcuc2VsZWN0QWxsKCdwYXRoLmxlZnQtYXJjLCBwYXRoLnJpZ2h0LWFyYywgcGF0aC5yaWJib24nKVxuICAgICAgICAgIC50cmFuc2l0aW9uKGhvdmVyVHJhbnNpdGlvbilcbiAgICAgICAgICAuYXR0cignb3BhY2l0eScsIGZ1bmN0aW9uKHRoaXMsIGhvdmVyRDogYW55KSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NlZCgncmlnaHQtYXJjJykpIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IHJpZ2h0QXJjcy5maW5kSW5kZXgoYXJjID0+IGFyYy5uYW1lID09PSBob3ZlckQubmFtZSk7XG4gICAgICAgICAgICAgIHJldHVybiBpID09PSBhcmNJbmRleCA/IDEuMCA6IDAuNDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5jbGFzc2VkKCdsZWZ0LWFyYycpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGkgPSBsZWZ0QXJjcy5maW5kSW5kZXgoYXJjID0+IGFyYy5uYW1lID09PSBob3ZlckQubmFtZSk7XG4gICAgICAgICAgICAgIGNvbnN0IG1hdHJpeFZhbHVlID0gY29ubmVjdGlvbk1hdHJpeFtpXSAmJiBjb25uZWN0aW9uTWF0cml4W2ldW2FyY0luZGV4XTtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hdHJpeFZhbHVlID4gMCA/IDAuOTUgOiAwLjM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuY2xhc3NlZCgncmliYm9uJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhvdmVyRC50YXJnZXQuaW5kZXggPT09IGFyY0luZGV4ID8gMC45NSA6IDAuMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICB4OiBldmVudC5wYWdlWCxcbiAgICAgICAgICB5OiBldmVudC5wYWdlWSxcbiAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdib2xkJywgbWFyZ2luQm90dG9tOiA0IH19PnsoZC5uYW1lIHx8ICdVbmtub3duJykudG9TdHJpbmcoKS5yZXBsYWNlKC9fL2csICcgJyl9PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXY+Q291bnQ6IHtkLnZhbHVlfTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgIHJlc3VtZUFuaW1hdGlvbignYXJjIGhvdmVyIGVuZCcpO1xuICAgICAgICBzZXRUb29sdGlwKG51bGwpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgaGlnaGxpZ2h0aW5nIHdoZW4gYW5pbWF0aW9uIHJlc3VtZXNcbiAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRBcmNJbmRleChudWxsKTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRTaWRlKG51bGwpO1xuICAgICAgICBcbiAgICAgICAgLy8gQXBwbHkgaW1tZWRpYXRlIHJlc2V0IHRyYW5zaXRpb25zXG4gICAgICAgIGcuc2VsZWN0QWxsKCdwYXRoLmxlZnQtYXJjLCBwYXRoLnJpZ2h0LWFyYywgcGF0aC5yaWJib24nKVxuICAgICAgICAgIC50cmFuc2l0aW9uKGhvdmVyVHJhbnNpdGlvbilcbiAgICAgICAgICAuYXR0cignb3BhY2l0eScsIGZ1bmN0aW9uKHRoaXMsIHJlc2V0RDogYW55KSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NlZCgnbGVmdC1hcmMnKSB8fCBlbGVtZW50LmNsYXNzZWQoJ3JpZ2h0LWFyYycpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLjgsIHJlc2V0RC5vcGFjaXR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5jbGFzc2VkKCdyaWJib24nKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuNyA6IDAuNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjg7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICBcbiAgICAvLyBBcHBseSB0cmFuc2l0aW9uIGFuaW1hdGlvbnMgc2VwYXJhdGVseVxuICAgIHJpZ2h0QXJjU2VsZWN0aW9uXG4gICAgICAudHJhbnNpdGlvbih0cmFuc2l0aW9uKVxuICAgICAgLmF0dHIoJ29wYWNpdHknLCAoZCwgaSkgPT4ge1xuICAgICAgICAvLyBBcHBseSBmdWxsIHJlbGF0aW9uc2hpcCBjaGFpbiBoaWdobGlnaHRpbmdcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodCB0aGUgc291cmNlIGFyY1xuICAgICAgICAgICAgaWYgKGkgPT09IGhpZ2hsaWdodGVkQXJjSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDEuMDsgLy8gU291cmNlIGFyYyBpcyBmdWxseSBoaWdobGlnaHRlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNDsgLy8gRGltIG90aGVyIHJpZ2h0IGFyY3NcbiAgICAgICAgICB9IGVsc2UgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ2xlZnQnICYmIGhpZ2hsaWdodGVkQXJjSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gbGVmdCBhcmMgaXMgaGlnaGxpZ2h0ZWQsIGhpZ2hsaWdodCByaWdodCBhcmNzIGNvbm5lY3RlZCB0byBpdFxuICAgICAgICAgICAgY29uc3QgbWF0cml4VmFsdWUgPSBjb25uZWN0aW9uTWF0cml4W2hpZ2hsaWdodGVkQXJjSW5kZXhdICYmIGNvbm5lY3Rpb25NYXRyaXhbaGlnaGxpZ2h0ZWRBcmNJbmRleF1baV07XG4gICAgICAgICAgICBjb25zdCBpc0Nvbm5lY3RlZFRvSGlnaGxpZ2h0ZWRMZWZ0ID0gbWF0cml4VmFsdWUgPiAwO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflJcgUmlnaHQgYXJjICR7aX0gKCR7cmlnaHRBcmNzW2ldPy5uYW1lfSkgY29ubmVjdGVkIHRvIGxlZnQgYXJjICR7aGlnaGxpZ2h0ZWRBcmNJbmRleH0gKCR7bGVmdEFyY3NbaGlnaGxpZ2h0ZWRBcmNJbmRleF0/Lm5hbWV9KT9gLCBcbiAgICAgICAgICAgICAgaXNDb25uZWN0ZWRUb0hpZ2hsaWdodGVkTGVmdCwgJ01hdHJpeCB2YWx1ZTonLCBtYXRyaXhWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gaXNDb25uZWN0ZWRUb0hpZ2hsaWdodGVkTGVmdCA/IDAuOTUgOiAwLjM7IC8vIEhpZ2hlciBjb250cmFzdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVc2Ugc3RhYmxlIGJhc2Ugb3BhY2l0eSB3aXRob3V0IHB1bHNpbmcgdG8gcHJldmVudCBmbGlja2VyaW5nXG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLjgsIGQub3BhY2l0eSk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgIC8vIEVuaGFuY2VkIHN0cm9rZSBmb3IgcmVsYXRpb25zaGlwIGNoYWluXG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAncmlnaHQnICYmIGkgPT09IGhpZ2hsaWdodGVkQXJjSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAzOyAvLyBUaGlja2VzdCBzdHJva2UgZm9yIHNvdXJjZSBhcmNcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU3Ryb2tlIGZvciBjb25uZWN0ZWQgYXJjcyB3aGVuIGxlZnQgc2lkZSBpcyBoaWdobGlnaHRlZFxuICAgICAgICAgIGlmIChoaWdobGlnaHRlZFNpZGUgPT09ICdsZWZ0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhWYWx1ZSA9IGNvbm5lY3Rpb25NYXRyaXhbaGlnaGxpZ2h0ZWRBcmNJbmRleF0gJiYgY29ubmVjdGlvbk1hdHJpeFtoaWdobGlnaHRlZEFyY0luZGV4XVtpXTtcbiAgICAgICAgICAgIGlmIChtYXRyaXhWYWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDI7IC8vIE1lZGl1bSBzdHJva2UgZm9yIGNvbm5lY3RlZCBhcmNzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdzdHJva2UnLCAoZCwgaSkgPT4ge1xuICAgICAgICAvLyBFbmhhbmNlZCBzdHJva2UgY29sb3IgZm9yIHJlbGF0aW9uc2hpcCBjaGFpblxuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ3JpZ2h0JyAmJiBpID09PSBoaWdobGlnaHRlZEFyY0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknIDogJ3JnYmEoMCwwLDAsMC4zKSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFN0cm9rZSBmb3IgY29ubmVjdGVkIGFyY3Mgd2hlbiBsZWZ0IHNpZGUgaXMgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbWF0cml4VmFsdWUgPSBjb25uZWN0aW9uTWF0cml4W2hpZ2hsaWdodGVkQXJjSW5kZXhdICYmIGNvbm5lY3Rpb25NYXRyaXhbaGlnaGxpZ2h0ZWRBcmNJbmRleF1baV07XG4gICAgICAgICAgICBpZiAobWF0cml4VmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC4zKScgOiAncmdiYSgwLDAsMCwwLjIpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG4gICAgLy8gRHJhdyByaWJib25zIGZvciBjb25uZWN0aW9ucyAoZGlzdHJpYnV0ZWQgYWxvbmcgYXJjLCBwcm9wb3J0aW9uYWwgdGhpY2tuZXNzKVxuICAgIC8vIFVzZSBkMy5yaWJib24oKSBmb3IgZWFjaCBjb25uZWN0aW9uLCBidXQgc2V0IHRoZSB3aWR0aCBieSB1c2luZyB0aGUgZnVsbCBzZWdtZW50IGZvciBlYWNoIGNvbm5lY3Rpb25cbiAgICBjb25zdCByaWJib25SYWRpdXMgPSBNYXRoLm1heCg2MCwgcmFkaXVzICogMC43NSk7IC8vIEVuc3VyZSBtaW5pbXVtIHJhZGl1cyBmb3IgcmliYm9uc1xuICAgIGNvbnN0IHJpYmJvbkdlbiA9IGQzLnJpYmJvbigpLnJhZGl1cyhyaWJib25SYWRpdXMpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YXJnZXRBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbm5lY3Rpb25NYXRyaXhbaV1bal07XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBzZWdtZW50IGZvciB0aGlzIGNvbm5lY3Rpb24gb24gYm90aCBhcmNzXG4gICAgICAgICAgY29uc3QgbGVmdFNlZyA9IGxlZnRBcmNzW2ldO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0U2VnID0gcmlnaHRBcmNzW2pdO1xuICAgICAgICAgIC8vIENvbXB1dGUgYXJjIG1pZHBvaW50cyBmb3IgZ3JhZGllbnQgZGlyZWN0aW9uXG4gICAgICAgICAgY29uc3QgbGVmdE1pZEFuZ2xlID0gKGxlZnRTZWcuc3RhcnRBbmdsZSArIGxlZnRTZWcuZW5kQW5nbGUpIC8gMiAtIE1hdGguUEkgLyAyO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0TWlkQW5nbGUgPSAocmlnaHRTZWcuc3RhcnRBbmdsZSArIHJpZ2h0U2VnLmVuZEFuZ2xlKSAvIDIgLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgICBjb25zdCBsZWZ0WCA9IE1hdGguY29zKGxlZnRNaWRBbmdsZSkgKiByaWJib25SYWRpdXM7XG4gICAgICAgICAgY29uc3QgbGVmdFkgPSBNYXRoLnNpbihsZWZ0TWlkQW5nbGUpICogcmliYm9uUmFkaXVzO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0WCA9IE1hdGguY29zKHJpZ2h0TWlkQW5nbGUpICogcmliYm9uUmFkaXVzO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0WSA9IE1hdGguc2luKHJpZ2h0TWlkQW5nbGUpICogcmliYm9uUmFkaXVzO1xuICAgICAgICAgIC8vIEFkZCBncmFkaWVudCBmb3IgdGhpcyByaWJib25cbiAgICAgICAgICBjb25zdCBsZWZ0Q29sb3IgPSBsZWZ0QXJjc1tpXS5jb2xvciB8fCBkMy5zY2hlbWVDYXRlZ29yeTEwW2kgJSAxMF07XG4gICAgICAgICAgY29uc3QgcmlnaHRDb2xvciA9IHJpZ2h0QXJjc1tqXS5jb2xvciB8fCBkMy5zY2hlbWVDYXRlZ29yeTEwWyhqICsgNSkgJSAxMF07XG4gICAgICAgICAgZGVmcy5hcHBlbmQoJ2xpbmVhckdyYWRpZW50JylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIGByaWJib24tZ3JhZGllbnQtJHtpfS0ke2p9YClcbiAgICAgICAgICAgIC5hdHRyKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJylcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIGxlZnRYKVxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgbGVmdFkpXG4gICAgICAgICAgICAuYXR0cigneDInLCByaWdodFgpXG4gICAgICAgICAgICAuYXR0cigneTInLCByaWdodFkpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdzdG9wJylcbiAgICAgICAgICAgIC5kYXRhKFtcbiAgICAgICAgICAgICAgeyBvZmZzZXQ6ICcwJScsIGNvbG9yOiBsZWZ0Q29sb3IgfSxcbiAgICAgICAgICAgICAgeyBvZmZzZXQ6ICcxMDAlJywgY29sb3I6IHJpZ2h0Q29sb3IgfVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCdzdG9wJylcbiAgICAgICAgICAgIC5hdHRyKCdvZmZzZXQnLCBkID0+IGQub2Zmc2V0KVxuICAgICAgICAgICAgLmF0dHIoJ3N0b3AtY29sb3InLCBkID0+IGQuY29sb3IpO1xuICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IGxlZnRTZWcuc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgZW5kQW5nbGU6IGxlZnRTZWcuZW5kQW5nbGUsXG4gICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHJpZ2h0U2VnLnN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgIGVuZEFuZ2xlOiByaWdodFNlZy5lbmRBbmdsZSxcbiAgICAgICAgICAgICAgaW5kZXg6IGpcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnRBcmNzW2ldLFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0QXJjc1tqXSxcbiAgICAgICAgICAgIGdyYWRpZW50SWQ6IGByaWJib24tZ3JhZGllbnQtJHtpfS0ke2p9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENyZWF0ZSByaWJib25zIHdpdGggZXZlbnQgaGFuZGxlcnMgZmlyc3RcbiAgICBjb25zdCByaWJib25TZWxlY3Rpb24gPSBnLnNlbGVjdEFsbCgncGF0aC5yaWJib24nKVxuICAgICAgLmRhdGEoY29ubmVjdGlvbnMpXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAncmliYm9uJylcbiAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCkgeyBjb25zdCBwYXRoID0gcmliYm9uR2VuKHsgc291cmNlOiBkLnNvdXJjZSwgdGFyZ2V0OiBkLnRhcmdldCB9IGFzIGFueSk7IHJldHVybiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgPyBwYXRoIDogJyc7IH0pXG4gICAgICAuYXR0cignZmlsbCcsIGQgPT4gYHVybCgjJHtkLmdyYWRpZW50SWR9KWApXG4gICAgICAuYXR0cignb3BhY2l0eScsIDApXG4gICAgICAub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbihldmVudDogYW55LCBkOiBhbnkpIHtcbiAgICAgICAgcGF1c2VBbmltYXRpb24oJ3JpYmJvbiBob3ZlcicpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJpZ2dlciBoaWdobGlnaHRpbmcgZm9yIHRoZSBzb3VyY2Ugc2lkZSBvZiB0aGlzIHJpYmJvbiAoc2FtZSBhcyBhdXRvLWN5Y2xlKVxuICAgICAgICBjb25zb2xlLmxvZygn8J+OryBIb3ZlciB0cmlnZ2VyaW5nIHJpYmJvbiBoaWdobGlnaHRpbmc6Jywge1xuICAgICAgICAgIGxlZnRBcmNOYW1lOiBkLmxlZnQubmFtZSxcbiAgICAgICAgICByaWdodEFyY05hbWU6IGQucmlnaHQubmFtZSxcbiAgICAgICAgICBzb3VyY2VJbmRleDogZC5zb3VyY2UuaW5kZXgsXG4gICAgICAgICAgdGFyZ2V0SW5kZXg6IGQudGFyZ2V0LmluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgICBzZXRIaWdobGlnaHRlZEFyY0luZGV4KGQuc291cmNlLmluZGV4KTtcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRTaWRlKCdsZWZ0Jyk7XG4gICAgICAgIFxuICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICB4OiBldmVudC5wYWdlWCxcbiAgICAgICAgICB5OiBldmVudC5wYWdlWSxcbiAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdib2xkJywgbWFyZ2luQm90dG9tOiA0IH19PlxuICAgICAgICAgICAgICAgIHsoZC5sZWZ0Lm5hbWUgfHwgJ1Vua25vd24nKS50b1N0cmluZygpLnJlcGxhY2UoL18vZywgJyAnKX0g4oaUIHsoZC5yaWdodC5uYW1lIHx8ICdVbmtub3duJykudG9TdHJpbmcoKS5yZXBsYWNlKC9fL2csICcgJyl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2PkNvbm5lY3Rpb25zOiB7ZC52YWx1ZX08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oZXZlbnQsIGQpIHtcbiAgICAgICAgcmVzdW1lQW5pbWF0aW9uKCdyaWJib24gaG92ZXIgZW5kJyk7XG4gICAgICAgIHNldFRvb2x0aXAobnVsbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXNldCBoaWdobGlnaHRpbmcgd2hlbiBhbmltYXRpb24gcmVzdW1lc1xuICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgICBzZXRIaWdobGlnaHRlZEFyY0luZGV4KG51bGwpO1xuICAgICAgICBzZXRIaWdobGlnaHRlZFNpZGUobnVsbCk7XG4gICAgICB9KTtcbiAgICBcbiAgICAvLyBBcHBseSB0cmFuc2l0aW9uIGFuaW1hdGlvbnMgc2VwYXJhdGVseVxuICAgIHJpYmJvblNlbGVjdGlvblxuICAgICAgLnRyYW5zaXRpb24odHJhbnNpdGlvbilcbiAgICAgIC5hdHRyKCdvcGFjaXR5JywgZCA9PiB7XG4gICAgICAgIC8vIEhpZ2hsaWdodCByaWJib25zIGNvbm5lY3RlZCB0byBoaWdobGlnaHRlZCBhcmNzIHdpdGggZW5oYW5jZWQgdmlzaWJpbGl0eVxuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ2xlZnQnICYmIGhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQuc291cmNlLmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gMC45NTsgLy8gTWFrZSBjb25uZWN0ZWQgcmliYm9ucyB2ZXJ5IHByb21pbmVudFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRTaWRlID09PSAncmlnaHQnICYmIGhpZ2hsaWdodGVkQXJjSW5kZXggPT09IGQudGFyZ2V0LmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gMC45NTsgLy8gTWFrZSBjb25uZWN0ZWQgcmliYm9ucyB2ZXJ5IHByb21pbmVudFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMC4yOyAvLyBEaW0gbm9uLWNvbm5lY3RlZCByaWJib25zIG1vcmUgZm9yIGJldHRlciBjb250cmFzdFxuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBzdGFibGUgYmFzZSBvcGFjaXR5IHdpdGhvdXQgcHVsc2luZ1xuICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuNyA6IDAuNjtcbiAgICAgIH0pXG4gICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgZCA9PiB7XG4gICAgICAgIC8vIEVuaGFuY2VkIHN0cm9rZSBmb3IgaGlnaGxpZ2h0ZWQgcmliYm9ucyB0byBzaG93IGNvbm5lY3Rpb25zIGNsZWFybHlcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGlmICgoaGlnaGxpZ2h0ZWRTaWRlID09PSAnbGVmdCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC5zb3VyY2UuaW5kZXgpIHx8XG4gICAgICAgICAgICAgIChoaWdobGlnaHRlZFNpZGUgPT09ICdyaWdodCcgJiYgaGlnaGxpZ2h0ZWRBcmNJbmRleCA9PT0gZC50YXJnZXQuaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMi41OyAvLyBTbGlnaHRseSB0aGlja2VyIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMC41O1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdzdHJva2UnLCBkID0+IHtcbiAgICAgICAgLy8gRW5oYW5jZWQgc3Ryb2tlIGNvbG9yIGZvciBoaWdobGlnaHRlZCBjb25uZWN0aW9uc1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgaWYgKChoaWdobGlnaHRlZFNpZGUgPT09ICdsZWZ0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnNvdXJjZS5pbmRleCkgfHxcbiAgICAgICAgICAgICAgKGhpZ2hsaWdodGVkU2lkZSA9PT0gJ3JpZ2h0JyAmJiBoaWdobGlnaHRlZEFyY0luZGV4ID09PSBkLnRhcmdldC5pbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScgOiAncmdiYSgwLDAsMCwwLjMpJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH0pO1xuXG4gICAgLy8gLS0tIExhYmVsIHBsYWNlbWVudDogcHJvcGVybHkgc3BhY2VkIGFyb3VuZCBjaXJjbGUgLS0tXG4gICAgY29uc3QgbGFiZWxSYWRpdXMgPSBNYXRoLm1heCgxMjAsIHJhZGl1cyAqIDEuNDUpOyAvLyBFdmVuIG1vcmUgc3BhY2UgZm9yIGZ1bGwgdGV4dCBsYWJlbHNcbiAgICBjb25zdCBsYWJlbEdyb3VwID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdCArIGVmZmVjdGl2ZUNoYXJ0V2lkdGggLyAyfSwgJHttYXJnaW4udG9wICsgZWZmZWN0aXZlQ2hhcnRIZWlnaHQgLyAyfSlgKTtcbiAgICBcbiAgICAvLyBDb21iaW5lIGFsbCBhcmNzIGZvciB1bmlmaWVkIGxhYmVsIHBsYWNlbWVudFxuICAgIGNvbnN0IGFsbEFyY3MgPSBbLi4ubGVmdEFyY3MubWFwKGFyYyA9PiAoey4uLmFyYywgc2lkZTogJ2xlZnQnfSkpLCAuLi5yaWdodEFyY3MubWFwKGFyYyA9PiAoey4uLmFyYywgc2lkZTogJ3JpZ2h0J30pKV07XG4gICAgXG4gICAgLy8gQWRkIGxhYmVscyB3aXRoIHNtYXJ0IHBvc2l0aW9uaW5nIHRvIGF2b2lkIG92ZXJsYXBcbiAgICBsYWJlbEdyb3VwLnNlbGVjdEFsbCgndGV4dC5hcmMtbGFiZWwnKVxuICAgICAgLmRhdGEoYWxsQXJjcylcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdhcmMtbGFiZWwnKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgY29uc3QgeCA9IGxhYmVsUmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBjb25zdCB5ID0gbGFiZWxSYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gYW5nbGUgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICBcbiAgICAgICAgLy8gUm90YXRlIHRleHQgZm9yIGJldHRlciByZWFkYWJpbGl0eVxuICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiB8fCBhbmdsZSA8IC1NYXRoLlBJIC8gMikge1xuICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pIHJvdGF0ZSgke3JvdGF0aW9uICsgMTgwfSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pIHJvdGF0ZSgke3JvdGF0aW9ufSlgO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgZCA9PiB7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gKGQuc3RhcnRBbmdsZSArIGQuZW5kQW5nbGUpIC8gMiAtIE1hdGguUEkgLyAyO1xuICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiB8fCBhbmdsZSA8IC1NYXRoLlBJIC8gMikge1xuICAgICAgICAgIHJldHVybiAnZW5kJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcbiAgICAgIC5zdHlsZSgnZm9udC1mYW1pbHknLCBsYWJlbEZvbnRGYW1pbHkpXG4gICAgICAuc3R5bGUoJ2ZvbnQtd2VpZ2h0JywgbGFiZWxGb250V2VpZ2h0KVxuICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgZCA9PiB7XG4gICAgICAgICAvLyBEeW5hbWljIGZvbnQgc2l6ZSBiYXNlZCBvbiBudW1iZXIgb2YgbGFiZWxzIC0gbGFyZ2VyIHNpbmNlIHdlJ3JlIHNob3dpbmcgZnVsbCB0ZXh0XG4gICAgICAgICBjb25zdCB0b3RhbExhYmVscyA9IGFsbEFyY3MubGVuZ3RoO1xuICAgICAgICAgaWYgKHRvdGFsTGFiZWxzID4gMTIpIHJldHVybiAnMTNweCc7XG4gICAgICAgICBpZiAodG90YWxMYWJlbHMgPiAxMCkgcmV0dXJuICcxNHB4JztcbiAgICAgICAgIGlmICh0b3RhbExhYmVscyA+IDgpIHJldHVybiAnMTVweCc7XG4gICAgICAgICByZXR1cm4gYCR7TWF0aC5tYXgoMTYsIGxhYmVsRm9udFNpemUpfXB4YDtcbiAgICAgICB9KVxuICAgICAgIC5zdHlsZSgnZmlsbCcsIGxhYmVsQ29sb3IpXG4gICAgICAgLnN0eWxlKCd0ZXh0LXRyYW5zZm9ybScsICd1cHBlcmNhc2UnKVxuICAgICAgIC50ZXh0KGQgPT4ge1xuICAgICAgICAgY29uc3QgdGV4dCA9IChkLm5hbWUgfHwgJ1Vua25vd24nKS50b1N0cmluZygpLnJlcGxhY2UoL18vZywgJyAnKTtcbiAgICAgICAgIC8vIFNob3cgZnVsbCB0ZXh0IC0gbm8gdHJ1bmNhdGlvblxuICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgfSlcbiAgICAgICAub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbihldmVudCwgZCkge1xuICAgICAgICAgcGF1c2VBbmltYXRpb24oJ2xhYmVsIGhvdmVyJyk7XG4gICAgICAgICBjb25zdCBmdWxsVGV4dCA9IChkLm5hbWUgfHwgJ1Vua25vd24nKS50b1N0cmluZygpLnJlcGxhY2UoL18vZywgJyAnKTtcbiAgICAgICAgIHNldFRvb2x0aXAoe1xuICAgICAgICAgICB4OiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgeTogZXZlbnQucGFnZVksXG4gICAgICAgICAgIGNvbnRlbnQ6IChcbiAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcsIG1hcmdpbkJvdHRvbTogNCB9fT57ZnVsbFRleHR9PC9kaXY+XG4gICAgICAgICAgICAgICA8ZGl2PkNvdW50OiB7ZC52YWx1ZX08L2Rpdj5cbiAgICAgICAgICAgICAgIDxkaXY+U2lkZToge2Quc2lkZX08L2Rpdj5cbiAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgKVxuICAgICAgICAgfSk7XG4gICAgICAgfSlcbiAgICAgICAub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICByZXN1bWVBbmltYXRpb24oJ2xhYmVsIGhvdmVyIGVuZCcpO1xuICAgICAgICAgc2V0VG9vbHRpcChudWxsKTtcbiAgICAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBpbnNpZ2h0c1xuICAgIGNvbnN0IHRvdGFsQ29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucy5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgZC52YWx1ZSwgMCk7XG4gICAgY29uc3Qgc3Ryb25nZXN0Q29ubmVjdGlvbiA9IGNvbm5lY3Rpb25zLmxlbmd0aCA+IDAgXG4gICAgICA/IGNvbm5lY3Rpb25zLnJlZHVjZSgobWF4LCBkKSA9PiBkLnZhbHVlID4gbWF4LnZhbHVlID8gZCA6IG1heCwgY29ubmVjdGlvbnNbMF0pXG4gICAgICA6IG51bGw7XG4gICAgc2V0SW5zaWdodHMoW1xuICAgICAgeyB0aXRsZTogJ1RvdGFsIFJlc3BvbnNlcycsIHZhbHVlOiBmaWx0ZXJlZERhdGEubGVuZ3RoLnRvU3RyaW5nKCkgfSxcbiAgICAgIHsgdGl0bGU6ICdDdXJyZW50IFZpZXcnLCB2YWx1ZTogYCR7Y3VycmVudFNvdXJjZX0g4oaUICR7Y3VycmVudFRhcmdldH1gIH0sXG4gICAgICBzdHJvbmdlc3RDb25uZWN0aW9uXG4gICAgICAgID8geyBcbiAgICAgICAgICAgIHRpdGxlOiAnU3Ryb25nZXN0IENvbm5lY3Rpb24nLCBcbiAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJvbmdlc3RDb25uZWN0aW9uLmxlZnQubmFtZSB8fCAnVW5rbm93bid9IOKGlCAke3N0cm9uZ2VzdENvbm5lY3Rpb24ucmlnaHQubmFtZSB8fCAnVW5rbm93bid9YCwgXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7c3Ryb25nZXN0Q29ubmVjdGlvbi52YWx1ZX0gY29ubmVjdGlvbnNgIFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7IHRpdGxlOiAnU3Ryb25nZXN0IENvbm5lY3Rpb24nLCB2YWx1ZTogJ05vIGNvbm5lY3Rpb25zIGZvdW5kJywgZGVzY3JpcHRpb246ICcnIH0sXG4gICAgICB7IHRpdGxlOiAnVG90YWwgQ29ubmVjdGlvbnMnLCB2YWx1ZTogdG90YWxDb25uZWN0aW9ucy50b1N0cmluZygpIH0sXG4gICAgXSk7XG5cbiAgfSwgW2RhdGEsIGN1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXQsIHNldHRpbmdzLnVzZVRlc3REYXRhLCBzZXR0aW5ncy5jYXRlZ29yeUNvbG9ycywgaXNMb2FkaW5nLCBsYXN0Q2F0ZWdvcnlDaGFuZ2UsIGlzQ29udGFpbmVyVG9vU21hbGwsIGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0LCBzaG93U2Vjb25kYXJ5Q2hvcmQsIHNldHRpbmdzLmlzRGFya01vZGVdKTtcblxuICAvLyBSZW5kZXIgc2Vjb25kYXJ5IGNob3JkIHdoZW4gcGVhayBwZXJmb3JtYW5jZSBpcyBpbnZvbHZlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzaG93U2Vjb25kYXJ5Q2hvcmQpIHtcbiAgICAgIHJlbmRlclNlY29uZGFyeUNob3JkKCk7XG4gICAgfVxuICB9LCBbc2hvd1NlY29uZGFyeUNob3JkLCBkYXRhLCBzZXR0aW5ncy51c2VUZXN0RGF0YSwgc2V0dGluZ3MuaXNEYXJrTW9kZSwgbGFiZWxDb2xvcl0pO1xuXG4gIC8vIFRvb2x0aXAgcmVuZGVyaW5nXG4gIGNvbnN0IHRvb2x0aXBFbCA9IHRvb2x0aXAgPyAoXG4gICAgPGRpdlxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIGxlZnQ6IHRvb2x0aXAueCArIDE2LFxuICAgICAgICB0b3A6IHRvb2x0aXAueSArIDE2LFxuICAgICAgICBiYWNrZ3JvdW5kOiAncmdiYSgyMCwyMCwzMCwwLjk4KScsXG4gICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgIHBhZGRpbmc6ICcxMHB4IDE2cHgnLFxuICAgICAgICBib3JkZXJSYWRpdXM6IDgsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgekluZGV4OiAxMDAsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdBdmVuaXIgTmV4dCBXb3JsZCwgc2Fucy1zZXJpZicsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICAgICAgZm9udFNpemU6IDE2LFxuICAgICAgICBib3hTaGFkb3c6ICcwIDRweCAyNHB4IDAgcmdiYSgxNiwgMTYsIDIzNSwgMC4xMiknLFxuICAgICAgICBtYXhXaWR0aDogMzIwLFxuICAgICAgfX1cbiAgICAgIHJvbGU9XCJ0b29sdGlwXCJcbiAgICAgIGFyaWEtbGl2ZT1cInBvbGl0ZVwiXG4gICAgPlxuICAgICAge3Rvb2x0aXAuY29udGVudH1cbiAgICA8L2Rpdj5cbiAgKSA6IG51bGw7XG5cbiAgLy8gQXBwbHkgdGhlbWUgYmFzZWQgb24gZ2xvYmFsIHNldHRpbmdzXG4gIGNvbnN0IHRoZW1lQ2xhc3MgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ2RhcmsnIDogJyc7XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAnIzFhMWExYScgOiAnI2ZmZmZmZic7XG4gIGNvbnN0IHRleHRDb2xvciA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzBBMEEwRic7XG5cbiAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgY29udGFpbmVyIGlzIHRvbyBzbWFsbFxuICBpZiAoaXNDb250YWluZXJUb29TbWFsbCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YHctZnVsbCBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgJHt0aGVtZUNsYXNzfWB9IHN0eWxlPXt7IGJhY2tncm91bmRDb2xvciB9fT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlclwiIHN0eWxlPXt7IGNvbG9yOiB0ZXh0Q29sb3IgfX0+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1sZyBtYi0yXCI+Q29udGFpbmVyIHRvbyBzbWFsbDwvcD5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIG9wYWNpdHktNzBcIj5NaW5pbXVtIHNpemU6IDIwMHgyMDBweDwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17YHctZnVsbCBoLWZ1bGwgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgJHt0aGVtZUNsYXNzfWB9IHN0eWxlPXt7IGJhY2tncm91bmRDb2xvciB9fT5cbiAgICAgIDxHbG9iYWxDb250cm9sc05hdiAvPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG1iLTRcIj5cbiAgICAgICAgICA8UXVlc3Rpb25TZWxlY3RvclxuICAgICAgICAgICAgYXZhaWxhYmxlRmllbGRzPXthdmFpbGFibGVGaWVsZHN9XG4gICAgICAgICAgICBjdXJyZW50U291cmNlPXtjdXJyZW50U291cmNlfVxuICAgICAgICAgICAgY3VycmVudFRhcmdldD17Y3VycmVudFRhcmdldH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoc291cmNlLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY29ycmVjdGVkID0gZW5zdXJlRGlmZmVyZW50Q2F0ZWdvcmllcyhzb3VyY2UsIHRhcmdldCk7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRTb3VyY2UoY29ycmVjdGVkLnNvdXJjZSk7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRUYXJnZXQoY29ycmVjdGVkLnRhcmdldCk7XG4gICAgICAgICAgICAgIHNldExhc3RDYXRlZ29yeUNoYW5nZShjb3JyZWN0ZWQpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBcbiAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgcmVsYXRpdmVcIlxuICAgICAgICAgIHN0eWxlPXt7IGhlaWdodDogaGVpZ2h0ICogMC44NSB9fSAvLyBVc2UgODUlIG9mIGF2YWlsYWJsZSBoZWlnaHQgZm9yIHRoZSBjaGFydCB0byBhY2NvdW50IGZvciBsYWJlbHNcbiAgICAgICAgPlxuICAgICAgICAgIHtzaG93U2Vjb25kYXJ5Q2hvcmQgPyAoXG4gICAgICAgICAgICAvLyBUd28tY2hvcmQgbGF5b3V0IHdoZW4gcGVhayBwZXJmb3JtYW5jZSBpcyBpbnZvbHZlZFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgZ2FwLTE2XCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItNFwiIHN0eWxlPXt7IGNvbG9yOiB0ZXh0Q29sb3IgfX0+XG4gICAgICAgICAgICAgICAgICBNYWluIFJlbGF0aW9uc2hpcHNcbiAgICAgICAgICAgICAgICA8L2gzPlxuICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgIHJlZj17c3ZnUmVmfVxuICAgICAgICAgICAgICAgICAgd2lkdGg9e3dpZHRoICogMC40NX1cbiAgICAgICAgICAgICAgICAgIGhlaWdodD17aGVpZ2h0ICogMC44fVxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgZGlzcGxheTogJ2Jsb2NrJywgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JywgY29sb3I6IHRleHRDb2xvciB9fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTRcIiBzdHlsZT17eyBjb2xvcjogdGV4dENvbG9yIH19PlxuICAgICAgICAgICAgICAgICAgWWVhcnMgw5cgUGVyZm9ybWFuY2UgVHlwZXNcbiAgICAgICAgICAgICAgICA8L2gzPlxuICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgIHJlZj17c2Vjb25kYXJ5U3ZnUmVmfVxuICAgICAgICAgICAgICAgICAgd2lkdGg9e3dpZHRoICogMC40NX1cbiAgICAgICAgICAgICAgICAgIGhlaWdodD17aGVpZ2h0ICogMC44fVxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgZGlzcGxheTogJ2Jsb2NrJywgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JywgY29sb3I6IHRleHRDb2xvciB9fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIC8vIFNpbmdsZSBjaG9yZCBsYXlvdXQgd2hlbiBwZWFrIHBlcmZvcm1hbmNlIGlzIG5vdCBpbnZvbHZlZFxuICAgICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgICByZWY9e3N2Z1JlZn1cbiAgICAgICAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodCAqIDAuODV9XG4gICAgICAgICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdibG9jaycsIG1hcmdpbjogJzAgYXV0bycsIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsIGNvbG9yOiB0ZXh0Q29sb3IgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgICB7dG9vbHRpcEVsfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufSAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiZDMiLCJ1c2VWaXN1YWxpemF0aW9uRGF0YSIsIlF1ZXN0aW9uU2VsZWN0b3IiLCJwcm9jZXNzQ2hvcmREYXRhIiwiY3ljbGluZ01vZGVzIiwidXNlQXBwQ29udGV4dCIsIkdsb2JhbENvbnRyb2xzTmF2IiwiZ2V0WWVhcnNDYXRlZ29yeSIsImdldE5vZGVDb2xvciIsIm5vZGVOYW1lIiwiY2F0ZWdvcnkiLCJnbG9iYWxDb2xvcnMiLCJpc0RhcmtNb2RlIiwidGhlbWVDb2xvcnMiLCJkYXJrIiwibGlnaHQiLCJ5ZWFyc19hdF9tZWR0cm9uaWMiLCJsZWFybmluZ19zdHlsZSIsInBlYWtfcGVyZm9ybWFuY2UiLCJtb3RpdmF0aW9uIiwic2hhcGVkX2J5IiwiQ2hvcmREaWFncmFtIiwid2lkdGgiLCJoZWlnaHQiLCJhdXRvUGxheSIsIm9uUmVsYXRpb25zaGlwQ2hhbmdlIiwiZW5hYmxlUm90YXRpb24iLCJzaG93QWxsQ29ubmVjdGlvbnMiLCJzdmdSZWYiLCJzZWNvbmRhcnlTdmdSZWYiLCJkYXRhIiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJjdXJyZW50U291cmNlIiwic2V0Q3VycmVudFNvdXJjZSIsImN1cnJlbnRUYXJnZXQiLCJzZXRDdXJyZW50VGFyZ2V0IiwiaW5zaWdodHMiLCJzZXRJbnNpZ2h0cyIsInRvb2x0aXAiLCJzZXRUb29sdGlwIiwic2V0dGluZ3MiLCJsYXN0Q2F0ZWdvcnlDaGFuZ2UiLCJzZXRMYXN0Q2F0ZWdvcnlDaGFuZ2UiLCJzb3VyY2UiLCJ0YXJnZXQiLCJzaG93U2Vjb25kYXJ5Q2hvcmQiLCJzZXRTaG93U2Vjb25kYXJ5Q2hvcmQiLCJhbmltYXRpb25QaGFzZSIsInNldEFuaW1hdGlvblBoYXNlIiwiaGlnaGxpZ2h0ZWRBcmNJbmRleCIsInNldEhpZ2hsaWdodGVkQXJjSW5kZXgiLCJoaWdobGlnaHRlZFNpZGUiLCJzZXRIaWdobGlnaHRlZFNpZGUiLCJpc0FuaW1hdGluZyIsInNldElzQW5pbWF0aW5nIiwic2Vjb25kYXJ5QW5pbWF0aW9uUGhhc2UiLCJzZXRTZWNvbmRhcnlBbmltYXRpb25QaGFzZSIsInNlY29uZGFyeUhpZ2hsaWdodGVkQXJjSW5kZXgiLCJzZXRTZWNvbmRhcnlIaWdobGlnaHRlZEFyY0luZGV4Iiwic2Vjb25kYXJ5SGlnaGxpZ2h0ZWRTaWRlIiwic2V0U2Vjb25kYXJ5SGlnaGxpZ2h0ZWRTaWRlIiwiYW5pbWF0aW9uUmVmIiwidGltZXIiLCJydW5uaW5nIiwiY3VycmVudEluZGV4IiwiY3VycmVudFNpZGUiLCJpc1BhdXNlZCIsInNlY29uZGFyeUFuaW1hdGlvblJlZiIsImF2YWlsYWJsZUZpZWxkcyIsInZhbHVlIiwibGFiZWwiLCJsYWJlbEZvbnRTaXplIiwibGFiZWxGb250V2VpZ2h0IiwibGFiZWxDb2xvciIsImxhYmVsRm9udEZhbWlseSIsImlzUGVha1BlcmZvcm1hbmNlSW52b2x2ZWQiLCJyZW5kZXJTZWNvbmRhcnlDaG9yZCIsImN1cnJlbnQiLCJsZW5ndGgiLCJzdmciLCJzZWxlY3QiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJmaWx0ZXJlZERhdGEiLCJ1c2VUZXN0RGF0YSIsImZpbHRlciIsIml0ZW0iLCJ0ZXN0X2RhdGEiLCJzZWNvbmRhcnlEYXRhIiwiZCIsInNlY29uZGFyeVdpZHRoIiwic2Vjb25kYXJ5SGVpZ2h0Iiwic2Vjb25kYXJ5TWFyZ2luIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwic2Vjb25kYXJ5Q2hhcnRXaWR0aCIsInNlY29uZGFyeUNoYXJ0SGVpZ2h0Iiwic2Vjb25kYXJ5UmFkaXVzIiwiTWF0aCIsIm1heCIsIm1pbiIsInllYXJzQ2F0ZWdvcmllcyIsInBlYWtQZXJmQ2F0ZWdvcmllcyIsIkFycmF5IiwiZnJvbSIsIlNldCIsIm1hcCIsIkJvb2xlYW4iLCJzb3J0IiwiYWxsQ2F0ZWdvcmllcyIsIm1hdHJpeCIsInNvdXJjZUNhdGVnb3J5Iiwic291cmNlSW5kZXgiLCJ0YXJnZXRDYXRlZ29yeSIsInRhcmdldEluZGV4Iiwic291cmNlSXNZZWFycyIsInRhcmdldElzWWVhcnMiLCJ5ZWFyc0NhdCIsInBlcmZDYXQiLCJ5ZWFycyIsInBlcmYiLCJjaG9yZExheW91dCIsImNob3JkIiwicGFkQW5nbGUiLCJjaG9yZERhdGEiLCJnIiwiYXBwZW5kIiwiYXR0ciIsImFyYyIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJyaWJib24iLCJyYWRpdXMiLCJ5ZWFyc0NvbG9ycyIsInBlcmZDb2xvcnMiLCJjb2xvcnMiLCJzbGljZSIsImdyb3VwU2VsZWN0aW9uIiwiZ3JvdXBzIiwiZW50ZXIiLCJzdHlsZSIsImkiLCJvbiIsImV2ZW50IiwicGF1c2VBbmltYXRpb24iLCJjb25zb2xlIiwibG9nIiwiZ3JvdXBJbmRleCIsImluZGV4IiwieCIsInBhZ2VYIiwieSIsInBhZ2VZIiwiY29udGVudCIsImRpdiIsImZvbnRXZWlnaHQiLCJtYXJnaW5Cb3R0b20iLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJyZXN1bWVBbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwiZHVyYXRpb24iLCJpc0Nvbm5lY3RlZCIsInNvbWUiLCJjaG9yZFNlbGVjdGlvbiIsInNlY29uZGFyeUxhYmVsUmFkaXVzIiwiYW5nbGUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJQSSIsImNvcyIsInNpbiIsInJvdGF0aW9uIiwidG90YWxMYWJlbHMiLCJ0ZXh0IiwiZnVsbFRleHQiLCJlbnN1cmVEaWZmZXJlbnRDYXRlZ29yaWVzIiwiZGlmZmVyZW50T3B0aW9uIiwiZmluZCIsImZpZWxkIiwiY29ycmVjdGVkIiwiY3VycmVudE1vZGVJbmRleFJlZiIsIm1vZGVJbmRleCIsImZpbmRJbmRleCIsIm1vZGUiLCJpc0F1dG9QbGF5RW5hYmxlZCIsImF1dG9QbGF5U3BlZWQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwibmV4dE1vZGVJbmRleCIsIm5leHRNb2RlIiwid2FybiIsInRvIiwiY2xlYXJJbnRlcnZhbCIsImRhdGFMZW5ndGgiLCJjbGVhclRpbWVvdXQiLCJhbmltYXRlIiwic2lkZSIsImRlYnVnRmlsdGVyZWREYXRhIiwiZGVidWdMZWZ0VmFsdWVzIiwiZGVidWdSaWdodFZhbHVlcyIsImhpZ2hsaWdodGVkQ2F0ZWdvcnkiLCJzb3VyY2VTaWRlIiwic3RlcER1cmF0aW9uIiwicGF1c2VEdXJhdGlvbiIsImxlZnRWYWx1ZXMiLCJyaWdodFZhbHVlcyIsImN1cnJlbnRTaWRlTGVuZ3RoIiwic2V0VGltZW91dCIsImhhc0RhdGEiLCJhbmltYXRlU2Vjb25kYXJ5IiwiYWN0dWFsQXJjSW5kZXgiLCJyZWFzb24iLCJyZXN0YXJ0TWFpbkFuaW1hdGlvbiIsInJlc3RhcnRTZWNvbmRhcnlBbmltYXRpb24iLCJtYXJnaW4iLCJjaGFydFdpZHRoIiwiY2hhcnRIZWlnaHQiLCJpc0NvbnRhaW5lclRvb1NtYWxsIiwiZWZmZWN0aXZlV2lkdGgiLCJlZmZlY3RpdmVIZWlnaHQiLCJlZmZlY3RpdmVDaGFydFdpZHRoIiwiZWZmZWN0aXZlQ2hhcnRIZWlnaHQiLCJkZWZzIiwiWUVBUlNfR1JPVVBTIiwic291cmNlQ2F0ZWdvcmllcyIsInRhcmdldENhdGVnb3JpZXMiLCJmb3JFYWNoIiwiYWRkIiwic291cmNlQXJyYXkiLCJ0YXJnZXRBcnJheSIsImxlZnRUb3RhbHMiLCJjYXQiLCJyaWdodFRvdGFscyIsImxlZnRUb3RhbFN1bSIsInJlZHVjZSIsInN1bSIsInZhbCIsInJpZ2h0VG90YWxTdW0iLCJjb25uZWN0aW9uTWF0cml4Iiwic291cmNlQ2F0IiwidGFyZ2V0Q2F0IiwiaXNDYXRlZ29yeUNoYW5nZSIsImVhc2UiLCJlYXNlQ3ViaWNJbk91dCIsImhvdmVyVHJhbnNpdGlvbiIsImVhc2VRdWFkT3V0IiwiYXJjR2FwIiwibGVmdFN0YXJ0IiwibGVmdEVuZCIsInJpZ2h0U3RhcnQiLCJyaWdodEVuZCIsImxlZnRBcmNTcGFuIiwicmlnaHRBcmNTcGFuIiwibWluQXJjU3BhY2luZyIsImxlZnRBbmdsZSIsImxlZnRBcmNzIiwiY291bnQiLCJhdmFpbGFibGVTcGFuIiwiYXJjU3BhbiIsImNvbG9yIiwiY2F0ZWdvcnlDb2xvcnMiLCJvcGFjaXR5IiwibmFtZSIsInJpZ2h0QW5nbGUiLCJyaWdodEFyY3MiLCJhcmNHZW4iLCJjb3JuZXJSYWRpdXMiLCJiYXNlQ29sb3IiLCJsaWdodGVyQ29sb3IiLCJicmlnaHRlciIsIm9mZnNldCIsImxlZnRBcmNTZWxlY3Rpb24iLCJhcmNJbmRleCIsImhvdmVyRCIsImVsZW1lbnQiLCJjbGFzc2VkIiwibWF0cml4VmFsdWUiLCJyZXNldEQiLCJpc0Nvbm5lY3RlZFRvSGlnaGxpZ2h0ZWRSaWdodCIsInJpZ2h0QXJjU2VsZWN0aW9uIiwiYXJjTmFtZSIsImlzQ29ubmVjdGVkVG9IaWdobGlnaHRlZExlZnQiLCJyaWJib25SYWRpdXMiLCJyaWJib25HZW4iLCJjb25uZWN0aW9ucyIsImoiLCJsZWZ0U2VnIiwicmlnaHRTZWciLCJsZWZ0TWlkQW5nbGUiLCJyaWdodE1pZEFuZ2xlIiwibGVmdFgiLCJsZWZ0WSIsInJpZ2h0WCIsInJpZ2h0WSIsImxlZnRDb2xvciIsInNjaGVtZUNhdGVnb3J5MTAiLCJyaWdodENvbG9yIiwicHVzaCIsImdyYWRpZW50SWQiLCJyaWJib25TZWxlY3Rpb24iLCJwYXRoIiwibGVmdEFyY05hbWUiLCJyaWdodEFyY05hbWUiLCJsYWJlbFJhZGl1cyIsImxhYmVsR3JvdXAiLCJhbGxBcmNzIiwidG90YWxDb25uZWN0aW9ucyIsInN0cm9uZ2VzdENvbm5lY3Rpb24iLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwidG9vbHRpcEVsIiwicG9zaXRpb24iLCJiYWNrZ3JvdW5kIiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsInBvaW50ZXJFdmVudHMiLCJ6SW5kZXgiLCJmb250RmFtaWx5IiwiZm9udFNpemUiLCJib3hTaGFkb3ciLCJtYXhXaWR0aCIsInJvbGUiLCJhcmlhLWxpdmUiLCJ0aGVtZUNsYXNzIiwiYmFja2dyb3VuZENvbG9yIiwidGV4dENvbG9yIiwiY2xhc3NOYW1lIiwicCIsIm9uQ2hhbmdlIiwiaDMiLCJyZWYiLCJkaXNwbGF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/DataVisualization/ChordDiagram.tsx\n"));

/***/ })

});