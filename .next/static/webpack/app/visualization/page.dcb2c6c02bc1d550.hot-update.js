"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/visualization/page",{

/***/ "(app-pages-browser)/./src/components/DataVisualization/AlluvialDiagram.tsx":
/*!**************************************************************!*\
  !*** ./src/components/DataVisualization/AlluvialDiagram.tsx ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AlluvialDiagram; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\");\n/* harmony import */ var d3_sankey__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-sankey */ \"(app-pages-browser)/./node_modules/d3-sankey/src/index.js\");\n/* harmony import */ var _shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/useVisualizationData */ \"(app-pages-browser)/./src/components/DataVisualization/shared/useVisualizationData.ts\");\n/* harmony import */ var _shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shared/colorUtils */ \"(app-pages-browser)/./src/components/DataVisualization/shared/colorUtils.ts\");\n/* harmony import */ var _lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/context/AppContext */ \"(app-pages-browser)/./src/lib/context/AppContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst availableFields = [\n    {\n        value: \"years_at_medtronic\",\n        label: \"Years at Medtronic\"\n    },\n    {\n        value: \"learning_style\",\n        label: \"Learning Style\"\n    },\n    {\n        value: \"shaped_by\",\n        label: \"Shaped By\"\n    },\n    {\n        value: \"peak_performance\",\n        label: \"Peak Performance\"\n    },\n    {\n        value: \"motivation\",\n        label: \"Motivation\"\n    }\n];\nconst YEARS_CATEGORIES = [\n    \"0-5\",\n    \"6-10\",\n    \"11-15\",\n    \"16-20\",\n    \"20+\"\n];\n// Move this function up so it is defined before use\nconst getValidYearsCategory = (years)=>{\n    if (typeof years !== \"number\" || isNaN(years) || years < 0) return \"0-5\";\n    if (years <= 5) return \"0-5\";\n    if (years <= 10) return \"6-10\";\n    if (years <= 15) return \"11-15\";\n    if (years <= 20) return \"16-20\";\n    return \"20+\";\n};\n// Custom wave path generator for Sankey links with bounds checking\nfunction sankeyLinkWave(d) {\n    let waveAmplitude = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8, waveFrequency = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.1, chartWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 800, chartHeight = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 600;\n    // d has source/target: {x0, x1, y0, y1}\n    let x0 = d.source.x1;\n    let x1 = d.target.x0;\n    let y0 = d.y0;\n    let y1 = d.y1;\n    // Clamp coordinates to chart bounds to prevent overflow\n    x0 = Math.max(0, Math.min(chartWidth, x0));\n    x1 = Math.max(0, Math.min(chartWidth, x1));\n    y0 = Math.max(0, Math.min(chartHeight, y0));\n    y1 = Math.max(0, Math.min(chartHeight, y1));\n    const midX = (x0 + x1) / 2;\n    // Add a sine wave to the control points, but ensure they stay within bounds\n    const waveY0 = Math.max(0, Math.min(chartHeight, y0 + waveAmplitude * Math.sin(waveFrequency * Math.PI * 0.25)));\n    const waveY1 = Math.max(0, Math.min(chartHeight, y1 + waveAmplitude * Math.sin(waveFrequency * Math.PI * 0.75)));\n    return \"M\".concat(x0, \",\").concat(y0, \"\\n    C\").concat(midX, \",\").concat(waveY0, \" \").concat(midX, \",\").concat(waveY1, \" \").concat(x1, \",\").concat(y1);\n}\n// Custom horizontal link generator that clamps y0/y1 to node bounds\nfunction clampedSankeyLinkHorizontal() {\n    return function(d) {\n        // Clamp y0/y1 to node bounds\n        const sy = Math.max(d.source.y0, Math.min(d.source.y1, d.y0));\n        const ty = Math.max(d.target.y0, Math.min(d.target.y1, d.y1));\n        const x0 = d.source.x1;\n        const x1 = d.target.x0;\n        // Use a cubic Bezier for smoothness\n        const curvature = 0.5;\n        const xi = d3__WEBPACK_IMPORTED_MODULE_2__.interpolateNumber(x0, x1);\n        const x2 = xi(curvature);\n        const x3 = xi(1 - curvature);\n        return \"M\".concat(x0, \",\").concat(sy, \"C\").concat(x2, \",\").concat(sy, \" \").concat(x3, \",\").concat(ty, \" \").concat(x1, \",\").concat(ty);\n    };\n}\n// Note: Using theme-aware getNodeColor function from colorUtils\nfunction AlluvialDiagram(param) {\n    let { width = 800, height = 600, autoPlay = true, onQuestionChange } = param;\n    _s();\n    // Responsive: use state for width/height, fallback to props\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [containerWidth, setContainerWidth] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(width);\n    const [containerHeight, setContainerHeight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(height);\n    // Responsive: observe container size\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!containerRef.current) return;\n        const observer = new window.ResizeObserver((entries)=>{\n            for (let entry of entries){\n                if (entry.contentRect) {\n                    setContainerWidth(entry.contentRect.width);\n                    setContainerHeight(entry.contentRect.height);\n                }\n            }\n        });\n        observer.observe(containerRef.current);\n        return ()=>observer.disconnect();\n    }, []);\n    const svgRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { data, isLoading, error } = (0,_shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_4__.useVisualizationData)();\n    const { settings, getCurrentThemeColors } = (0,_lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__.useAppContext)();\n    const [currentSource, setCurrentSource] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"years_at_medtronic\");\n    const [currentTarget, setCurrentTarget] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"learning_style\");\n    // Filter data based on test data setting\n    const filteredData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!Array.isArray(data) || !data.length) return [];\n        return settings.useTestData ? data : data.filter((item)=>!item.test_data);\n    }, [\n        data,\n        settings.useTestData\n    ]);\n    // Compute sources and targets with validation\n    const sources = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!Array.isArray(filteredData) || !filteredData.length) return [];\n        if (currentSource === \"years_at_medtronic\") {\n            return YEARS_CATEGORIES.filter((cat)=>filteredData.some((d)=>getValidYearsCategory(d.years_at_medtronic || 0) === cat));\n        } else {\n            return Array.from(new Set(filteredData.map((d)=>d[currentSource]))).filter((value)=>typeof value === \"string\" && value.length > 0);\n        }\n    }, [\n        filteredData,\n        currentSource\n    ]);\n    const targets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!Array.isArray(filteredData) || !filteredData.length) return [];\n        if (currentTarget === \"years_at_medtronic\") {\n            return YEARS_CATEGORIES.filter((cat)=>filteredData.some((d)=>getValidYearsCategory(d.years_at_medtronic || 0) === cat));\n        } else {\n            // Sort target nodes consistently to maintain fixed positions\n            return Array.from(new Set(filteredData.map((d)=>currentTarget === \"years_at_medtronic\" ? getValidYearsCategory(d.years_at_medtronic || 0) : d[currentTarget]))).filter((value)=>typeof value === \"string\" && value.length > 0).sort(); // Add consistent sorting\n        }\n    }, [\n        filteredData,\n        currentTarget\n    ]);\n    // --- Responsive chart sizing based on data size ---\n    // Set sensible min/max chart dimensions\n    const MIN_CHART_HEIGHT = 180;\n    const MAX_CHART_HEIGHT = 700;\n    const MIN_CHART_WIDTH = 320;\n    const MAX_CHART_WIDTH = 1400;\n    // Calculate node count for sizing\n    const nodeCount = Math.max(sources.length, targets.length, 1);\n    // Calculate available height for nodes and paddings\n    let availableHeight = Math.max(MIN_CHART_HEIGHT, Math.min(containerHeight - 40, MAX_CHART_HEIGHT));\n    // For very sparse data, shrink the chart height\n    if (nodeCount <= 3) {\n        availableHeight = Math.max(MIN_CHART_HEIGHT, Math.min(320, availableHeight));\n    }\n    // For very dense data, allow more height\n    if (nodeCount >= 10) {\n        availableHeight = Math.min(MAX_CHART_HEIGHT, Math.max(availableHeight, 500));\n    }\n    // Node height and padding logic\n    const minNodeHeight = 16;\n    const maxNodeHeight = nodeCount <= 3 ? 36 : 48; // Smaller max for sparse data\n    const minPadding = 8;\n    let nodeHeight = Math.floor((availableHeight - (nodeCount + 1) * minPadding) / nodeCount);\n    nodeHeight = Math.max(minNodeHeight, Math.min(nodeHeight, maxNodeHeight));\n    let nodePadding = (availableHeight - nodeCount * nodeHeight) / (nodeCount + 1);\n    nodePadding = Math.max(nodePadding, minPadding);\n    // Dynamically scale label font size with node height (clamp between 12px and 28px)\n    const labelFontSize = Math.max(12, Math.min(28, Math.floor(nodeHeight * 0.5)));\n    // --- Dynamic margin calculation for full label visibility ---\n    // Helper to measure text width in px\n    function measureTextWidth(text, font) {\n        if (false) {} // fallback for SSR\n        if (!measureTextWidth._canvas) {\n            measureTextWidth._canvas = document.createElement(\"canvas\");\n        }\n        const canvas = measureTextWidth._canvas;\n        const context = canvas.getContext(\"2d\");\n        if (!context) return 100;\n        context.font = font;\n        return context.measureText(text).width;\n    }\n    // Font for measuring\n    const labelFont = \"bold \".concat(labelFontSize, \"px Avenir Next World, -apple-system, BlinkMacSystemFont, 'SF Pro', 'Roboto', sans-serif\");\n    const allLabels = [\n        ...sources,\n        ...targets\n    ];\n    const labelWidths = allLabels.map((label)=>measureTextWidth(label, labelFont));\n    const maxLabelWidth = Math.max(...labelWidths, 80); // fallback min\n    const labelPadding = 24;\n    const margin = {\n        top: 20,\n        right: maxLabelWidth + labelPadding,\n        bottom: 20,\n        left: maxLabelWidth + labelPadding\n    };\n    // Responsive chart width\n    let chartWidth = Math.max(MIN_CHART_WIDTH, Math.min(containerWidth - margin.left - margin.right, MAX_CHART_WIDTH));\n    let chartHeight = availableHeight;\n    // If very sparse, shrink width too\n    if (nodeCount <= 3) {\n        chartWidth = Math.max(MIN_CHART_WIDTH, Math.min(chartWidth, 480));\n    }\n    // If very dense, allow more width\n    if (nodeCount >= 10) {\n        chartWidth = Math.min(MAX_CHART_WIDTH, Math.max(chartWidth, 900));\n    }\n    // Debug logging\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"[AlluvialDiagram Debug]\");\n        console.log(\"  Container:\", containerWidth, \"x\", containerHeight);\n        console.log(\"  Chart:\", chartWidth, \"x\", chartHeight);\n        console.log(\"  Node count (sources/targets):\", sources.length, targets.length);\n        console.log(\"  nodeHeight:\", nodeHeight);\n        console.log(\"  nodePadding:\", nodePadding);\n        console.log(\"  labelFontSize:\", labelFontSize);\n    }, [\n        containerWidth,\n        containerHeight,\n        chartWidth,\n        chartHeight,\n        sources.length,\n        targets.length,\n        nodeHeight,\n        nodePadding,\n        labelFontSize\n    ]);\n    // Use refs to track current values without triggering re-renders\n    const currentSourceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(currentSource);\n    const currentTargetRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(currentTarget);\n    // Update refs when state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentSourceRef.current = currentSource;\n    }, [\n        currentSource\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentTargetRef.current = currentTarget;\n    }, [\n        currentTarget\n    ]);\n    const [insights, setInsights] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [hoveredNode, setHoveredNode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [hoveredLink, setHoveredLink] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [tooltip, setTooltip] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [lastCategoryChange, setLastCategoryChange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        source: currentSource,\n        target: currentTarget\n    });\n    const [currentTargetIndex, setCurrentTargetIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [isAnimating, setIsAnimating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [hoveredSourceIndex, setHoveredSourceIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [hoveredTargetIndex, setHoveredTargetIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isInFullOpacityState, setIsInFullOpacityState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [animationPhase, setAnimationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"full\");\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        timer: null,\n        running: false,\n        currentSourceIndex: 0,\n        currentTargetIndex: 0,\n        isPaused: false,\n        pausedAt: Date.now(),\n        resumeFrom: null,\n        cycleCount: 0\n    });\n    // Check for reduced motion preference\n    const prefersReducedMotion = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (false) {}\n        return window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\n    }, []);\n    // Adjust animation durations based on motion preference\n    const animationDurations = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const baseSpeed = settings.autoPlaySpeed || 3000;\n        const reductionFactor = prefersReducedMotion ? 0.5 : 1;\n        return {\n            stepDuration: Math.max(800, baseSpeed / 8 * reductionFactor),\n            pauseDuration: Math.max(400, baseSpeed / 12 * reductionFactor),\n            categoryPauseDuration: Math.max(1500, baseSpeed / 3 * reductionFactor),\n            linkTransitionDuration: prefersReducedMotion ? 400 : 750\n        };\n    }, [\n        settings.autoPlaySpeed,\n        prefersReducedMotion\n    ]);\n    // Get visual order of source nodes (top-to-bottom as they appear)\n    const sortedSources = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!filteredData.length || !chartWidth || !chartHeight) return sources;\n        const sourcesForNodes = [\n            ...sources\n        ];\n        if (currentSource === \"years_at_medtronic\") {\n            sourcesForNodes.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sourcesForNodes.sort();\n        }\n        // Create Sankey layout to get visual order\n        const nodes = [\n            ...sourcesForNodes.map((name)=>({\n                    id: \"\".concat(currentSource, \":\").concat(name),\n                    name,\n                    category: currentSource\n                })),\n            ...targets.map((name)=>({\n                    id: \"\".concat(currentTarget, \":\").concat(name),\n                    name,\n                    category: currentTarget\n                }))\n        ];\n        const linksMap = new Map();\n        filteredData.forEach((d)=>{\n            const source = currentSource === \"years_at_medtronic\" ? getValidYearsCategory(d.years_at_medtronic || 0) : d[currentSource];\n            const target = currentTarget === \"years_at_medtronic\" ? getValidYearsCategory(d.years_at_medtronic || 0) : d[currentTarget];\n            if (!sourcesForNodes.includes(source) || !targets.includes(target)) return;\n            const sourceId = \"\".concat(currentSource, \":\").concat(source);\n            const targetId = \"\".concat(currentTarget, \":\").concat(target);\n            const key = \"\".concat(sourceId, \"→\").concat(targetId);\n            if (!linksMap.has(key)) {\n                linksMap.set(key, {\n                    source: sourceId,\n                    target: targetId,\n                    value: 0\n                });\n            }\n            linksMap.get(key).value += 1;\n        });\n        const links = Array.from(linksMap.values());\n        const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(nodePadding).extent([\n            [\n                0,\n                0\n            ],\n            [\n                chartWidth,\n                chartHeight\n            ]\n        ]);\n        const sankeyData = sankeyGenerator({\n            nodes: nodes.map((d)=>({\n                    ...d\n                })),\n            links: links.map((d)=>({\n                    ...d\n                }))\n        });\n        // Get source nodes in visual order (top to bottom)\n        const sourceNodes = sankeyData.nodes.filter((d)=>d.category === currentSource).sort((a, b)=>a.y0 - b.y0);\n        return sourceNodes.map((d)=>d.name);\n    }, [\n        filteredData,\n        sources,\n        targets,\n        currentSource,\n        currentTarget,\n        chartWidth,\n        chartHeight,\n        nodePadding\n    ]);\n    // Enhanced animation function with comprehensive debug tracking\n    const animate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        // Check if animation is paused\n        if (animationRef.current.isPaused) {\n            console.log(\"⏸️  Animation is paused, skipping cycle\");\n            return;\n        }\n        if (!animationRef.current.running || !filteredData.length) {\n            console.log(\"❌ Animation stopped:\", {\n                running: animationRef.current.running,\n                dataLength: filteredData.length\n            });\n            return;\n        }\n        // Safety check: prevent infinite loops\n        if (animationRef.current.cycleCount > 1000) {\n            console.log(\"\\uD83D\\uDED1 Animation cycle limit reached, resetting\");\n            animationRef.current.cycleCount = 0;\n            animationRef.current.currentSourceIndex = 0;\n            animationRef.current.currentTargetIndex = 0;\n        }\n        // Increment cycle counter\n        animationRef.current.cycleCount++;\n        // Set animation phase to highlighting\n        setAnimationPhase(\"highlighting\");\n        setIsInFullOpacityState(false);\n        // Set the hovered source index to match the animation\n        setHoveredSourceIndex(animationRef.current.currentSourceIndex);\n        const targetOptions = availableFields.filter((f)=>f.value !== currentSourceRef.current).map((f)=>f.value);\n        // Debug: Log the target options to verify they're correct\n        if (animationRef.current.currentSourceIndex === 0) {\n            console.log(\"\\uD83C\\uDFAF Available target options for\", currentSourceRef.current, \":\", targetOptions);\n        }\n        // COMPREHENSIVE DEBUG: Log current state with full detail\n        console.log(\"\\uD83D\\uDD0D ANIMATION CYCLE DEBUG:\", {\n            \"\\uD83D\\uDCCD Current Position\": {\n                sourceIndex: animationRef.current.currentSourceIndex,\n                targetIndex: animationRef.current.currentTargetIndex,\n                sourceName: sortedSources[animationRef.current.currentSourceIndex],\n                targetName: currentTargetRef.current\n            },\n            \"\\uD83D\\uDCCA Categories\": {\n                currentSource: currentSourceRef.current,\n                currentTarget: currentTargetRef.current,\n                sourceOptions: availableFields.map((f)=>f.value),\n                targetOptions\n            },\n            \"\\uD83D\\uDCC8 Progress\": {\n                sourceProgress: \"\".concat(animationRef.current.currentSourceIndex + 1, \"/\").concat(sortedSources.length),\n                targetProgress: \"\".concat(animationRef.current.currentTargetIndex + 1, \"/\").concat(targetOptions.length),\n                isLastSource: animationRef.current.currentSourceIndex >= sortedSources.length - 1,\n                hasMoreTargets: animationRef.current.currentTargetIndex < targetOptions.length - 1\n            },\n            \"\\uD83C\\uDFAF Sources\": sortedSources,\n            \"\\uD83C\\uDFAF Targets\": targetOptions,\n            \"⏱️  Timings\": animationDurations\n        });\n        if (animationRef.current.currentSourceIndex < sortedSources.length - 1) {\n            // Move to next source\n            const nextTimeout = animationDurations.stepDuration + animationDurations.pauseDuration;\n            const progress = \"\".concat(animationRef.current.currentSourceIndex + 1, \"/\").concat(sortedSources.length);\n            console.log(\"\\uD83C\\uDFAF Source \".concat(progress, \": Highlighting '\").concat(sortedSources[animationRef.current.currentSourceIndex], \"' → '\").concat(currentTargetRef.current, \"' for \").concat(nextTimeout, \"ms\"));\n            animationRef.current.timer = setTimeout(()=>{\n                if (!animationRef.current.running || animationRef.current.isPaused) return;\n                animationRef.current.currentSourceIndex++;\n                animate();\n            }, nextTimeout);\n        } else {\n            // After last source, check if we need to cycle targets or change source category\n            console.log(\"\\uD83D\\uDD0D END OF SOURCES - Checking target cycling:\", {\n                currentTargetIndex: animationRef.current.currentTargetIndex,\n                targetOptionsLength: targetOptions.length,\n                hasMoreTargets: animationRef.current.currentTargetIndex < targetOptions.length - 1,\n                availableTargets: targetOptions\n            });\n            if (animationRef.current.currentTargetIndex < targetOptions.length - 1) {\n                // Still have more target categories to cycle through\n                const targetProgress = \"\".concat(animationRef.current.currentTargetIndex + 2, \"/\").concat(targetOptions.length);\n                console.log(\"\\uD83D\\uDD04 ✅ COMPLETED ALL SOURCES for '\".concat(currentTargetRef.current, \"', moving to next target (\").concat(targetProgress, \")\"));\n                // Clear any existing timer to prevent conflicts\n                if (animationRef.current.timer) {\n                    clearTimeout(animationRef.current.timer);\n                    animationRef.current.timer = null;\n                }\n                animationRef.current.timer = setTimeout(()=>{\n                    if (!animationRef.current.running || animationRef.current.isPaused) return;\n                    setAnimationPhase(\"transitioning\");\n                    // Move to next target category\n                    animationRef.current.currentTargetIndex++;\n                    const nextTarget = targetOptions[animationRef.current.currentTargetIndex];\n                    console.log(\"\\uD83C\\uDFAF ✨ NEW TARGET CATEGORY:\", nextTarget, \"(\".concat(animationRef.current.currentTargetIndex + 1, \"/\").concat(targetOptions.length, \")\"));\n                    console.log(\"\\uD83D\\uDD0D Target progression debug:\", {\n                        previousTarget: currentTargetRef.current,\n                        nextTarget,\n                        currentTargetIndex: animationRef.current.currentTargetIndex,\n                        allTargetOptions: targetOptions\n                    });\n                    setCurrentTarget(nextTarget);\n                    setLastCategoryChange({\n                        source: currentSourceRef.current,\n                        target: nextTarget\n                    });\n                    onQuestionChange === null || onQuestionChange === void 0 ? void 0 : onQuestionChange(currentSourceRef.current, nextTarget);\n                    // Reset source index and restart with new target\n                    animationRef.current.currentSourceIndex = 0;\n                    // Start the next cycle after a brief pause\n                    setTimeout(()=>{\n                        if (animationRef.current.running && !animationRef.current.isPaused) {\n                            animate();\n                        }\n                    }, animationDurations.categoryPauseDuration);\n                }, animationDurations.categoryPauseDuration);\n            } else {\n                // We've cycled through all targets, now change the source category\n                console.log(\"\\uD83D\\uDD04 ✨ COMPLETED ALL TARGETS for '\".concat(currentSourceRef.current, \"' - Moving to next source category! ✨\"));\n                // Clear any existing timer to prevent conflicts\n                if (animationRef.current.timer) {\n                    clearTimeout(animationRef.current.timer);\n                    animationRef.current.timer = null;\n                }\n                animationRef.current.timer = setTimeout(()=>{\n                    if (!animationRef.current.running || animationRef.current.isPaused) return;\n                    setAnimationPhase(\"transitioning\");\n                    // Move to next source category\n                    const sourceOptions = availableFields.map((f)=>f.value);\n                    const currentSourceIndex = sourceOptions.indexOf(currentSourceRef.current);\n                    const nextSourceIndex = (currentSourceIndex + 1) % sourceOptions.length;\n                    const nextSource = sourceOptions[nextSourceIndex];\n                    console.log(\"\\uD83C\\uDFAF \\uD83C\\uDD95 NEW SOURCE CATEGORY:\", nextSource, \"- Starting fresh cycle with all targets\");\n                    // Calculate target options for the NEW source (including years_at_medtronic)\n                    const newTargetOptions = availableFields.filter((f)=>f.value !== nextSource).map((f)=>f.value);\n                    console.log(\"\\uD83D\\uDD0D New target options for\", nextSource, \":\", newTargetOptions);\n                    setCurrentSource(nextSource);\n                    // Reset both indices and start with first target again\n                    animationRef.current.currentSourceIndex = 0;\n                    animationRef.current.currentTargetIndex = 0;\n                    const firstTarget = newTargetOptions[0];\n                    setCurrentTarget(firstTarget);\n                    setLastCategoryChange({\n                        source: nextSource,\n                        target: firstTarget\n                    });\n                    onQuestionChange === null || onQuestionChange === void 0 ? void 0 : onQuestionChange(nextSource, firstTarget);\n                    // Start the next cycle after a longer pause\n                    setTimeout(()=>{\n                        if (animationRef.current.running && !animationRef.current.isPaused) {\n                            animate();\n                        }\n                    }, animationDurations.categoryPauseDuration * 1.5); // Longer pause for source category change\n                }, animationDurations.categoryPauseDuration);\n            }\n        }\n    }, [\n        data.length,\n        sortedSources.length,\n        onQuestionChange,\n        animationDurations,\n        availableFields\n    ]);\n    // Animation effect - restart when settings change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"\\uD83C\\uDFAC Animation useEffect triggered:\", {\n            autoPlay,\n            isAutoPlayEnabled: settings.isAutoPlayEnabled,\n            dataLength: data.length,\n            svgRefExists: !!svgRef.current,\n            currentSource,\n            currentTarget,\n            autoPlaySpeed: settings.autoPlaySpeed,\n            isRunning: animationRef.current.running\n        });\n        if (!autoPlay || !settings.isAutoPlayEnabled) {\n            console.log(\"❌ Animation disabled\");\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n            setAnimationPhase(\"full\");\n            setIsInFullOpacityState(true);\n            return;\n        }\n        if (!filteredData.length) {\n            console.log(\"❌ No data available for animation\");\n            return;\n        }\n        if (!svgRef.current) {\n            console.log(\"❌ SVG ref not available\");\n            return;\n        }\n        // Restart animation when speed changes or on major changes\n        if (animationRef.current.running) {\n            console.log(\"\\uD83D\\uDD04 Restarting animation with new settings:\", {\n                sourceCategory: currentSource,\n                totalSources: sortedSources.length,\n                totalTargets: availableFields.filter((f)=>f.value !== currentSource).length,\n                speed: settings.autoPlaySpeed + \"ms\"\n            });\n            // Stop current animation\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n        }\n        // Start new animation cycle\n        console.log(\"✅ Starting animation cycle:\", {\n            sourceCategory: currentSource,\n            totalSources: sortedSources.length,\n            totalTargets: availableFields.filter((f)=>f.value !== currentSource).length,\n            speed: settings.autoPlaySpeed + \"ms\"\n        });\n        // Initialize animation state\n        animationRef.current.running = true;\n        animationRef.current.currentSourceIndex = 0;\n        animationRef.current.currentTargetIndex = 0;\n        animationRef.current.cycleCount = 0; // Reset cycle counter\n        // Start animation\n        animate();\n        return ()=>{\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n            setAnimationPhase(\"full\");\n            setIsInFullOpacityState(true);\n        };\n    }, [\n        autoPlay,\n        settings.isAutoPlayEnabled,\n        settings.autoPlaySpeed,\n        filteredData.length,\n        currentSource // Only restart on source changes, not target changes\n    ]);\n    const nodeLabelFontSize = 18; // larger for readability\n    const nodeLabelFontWeight = 700;\n    const nodeLabelColor = settings.isDarkMode ? \"#FFFFFF\" : \"#170F5F\";\n    const nodeLabelFontFamily = 'Avenir Next World, -apple-system, BlinkMacSystemFont, \"SF Pro\", \"Roboto\", sans-serif';\n    const nodeLabelOffset = 24;\n    // Local debug toggle for this component if no global admin context\n    const [localDebug, setLocalDebug] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showThemeToggle, setShowThemeToggle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const debugOn = localDebug;\n    // Debug Sankey data for outlines\n    const [debugSankeyData, setDebugSankeyData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!Array.isArray(sources) || !Array.isArray(targets)) return;\n        const nodes = [\n            ...sources.map((name)=>({\n                    id: \"source:\".concat(name),\n                    name,\n                    category: \"source\"\n                })),\n            ...targets.map((name)=>({\n                    id: \"target:\".concat(name),\n                    name,\n                    category: \"target\"\n                }))\n        ];\n        // Only create links if both sides have at least one node\n        const links = sources.length && targets.length ? [\n            {\n                source: \"source:\".concat(sources[0]),\n                target: \"target:\".concat(targets[0]),\n                value: 1\n            }\n        ] : [];\n        if (nodes.length < 2 || links.length < 1) return; // Prevent invalid array length\n        const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(nodePadding).extent([\n            [\n                0,\n                0\n            ],\n            [\n                chartWidth,\n                chartHeight\n            ]\n        ]);\n        const sankeyData = sankeyGenerator({\n            nodes: nodes.map((d)=>({\n                    ...d\n                })),\n            links: links.map((d)=>({\n                    ...d\n                }))\n        });\n        setDebugSankeyData(sankeyData);\n    }, [\n        sources,\n        targets,\n        chartWidth,\n        chartHeight,\n        nodePadding\n    ]);\n    // Render Sankey diagram\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current || !filteredData.length) return;\n        // --- Persistent SVG structure ---\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        svg.selectAll(\"*\").remove(); // Clear previous content\n        svg.attr(\"width\", containerWidth).attr(\"height\", containerHeight);\n        // --- Sankey node/link creation and vertical centering (deduplicated) ---\n        // Sort source nodes to maintain a fixed order (same as animation)\n        const sortedSources = [\n            ...sources\n        ];\n        if (currentSource === \"years_at_medtronic\") {\n            sortedSources.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sortedSources.sort();\n        }\n        // Sort target nodes to maintain a fixed order\n        const sortedTargets = [\n            ...targets\n        ];\n        if (currentTarget === \"years_at_medtronic\") {\n            sortedTargets.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sortedTargets.sort();\n        }\n        // Sankey transformation accessors\n        const sourceAccessor = (d)=>currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentSource];\n        const targetAccessor = (d)=>currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentTarget];\n        // Filter data to only include valid values\n        const validData = filteredData.filter((d)=>(currentSource !== \"years_at_medtronic\" || d.years_at_medtronic !== null) && (currentTarget !== \"years_at_medtronic\" || d.years_at_medtronic !== null));\n        // Build nodes array with unique ids\n        const nodes = [\n            ...sortedSources.map((name)=>({\n                    id: \"\".concat(currentSource, \":\").concat(name),\n                    name,\n                    category: currentSource\n                })),\n            ...sortedTargets.map((name)=>({\n                    id: \"\".concat(currentTarget, \":\").concat(name),\n                    name,\n                    category: currentTarget\n                }))\n        ];\n        // Build links array (aggregate counts for each source-target pair)\n        const linksMap = new Map();\n        // 1. For every possible source-target pair, create a link (dummy if no data)\n        sortedSources.forEach((source)=>{\n            sortedTargets.forEach((target)=>{\n                const sourceId = \"\".concat(currentSource, \":\").concat(source);\n                const targetId = \"\".concat(currentTarget, \":\").concat(target);\n                const key = \"\".concat(sourceId, \"→\").concat(targetId);\n                linksMap.set(key, {\n                    source: sourceId,\n                    target: targetId,\n                    value: 0,\n                    isDummy: true\n                });\n            });\n        });\n        // 2. Fill in real data, marking links as not dummy\n        validData.forEach((d)=>{\n            const source = sourceAccessor(d);\n            const target = targetAccessor(d);\n            if (!sortedSources.includes(source) || !sortedTargets.includes(target)) return;\n            const sourceId = \"\".concat(currentSource, \":\").concat(source);\n            const targetId = \"\".concat(currentTarget, \":\").concat(target);\n            const key = \"\".concat(sourceId, \"→\").concat(targetId);\n            if (!linksMap.has(key)) {\n                linksMap.set(key, {\n                    source: sourceId,\n                    target: targetId,\n                    value: 1,\n                    isDummy: false\n                });\n            } else {\n                const link = linksMap.get(key);\n                link.value += 1;\n                link.isDummy = false;\n            }\n        });\n        // 3. Set dummy links to a very small value if still dummy\n        Array.from(linksMap.values()).forEach((link)=>{\n            if (link.isDummy) link.value = 0.0001;\n        });\n        // --- COLUMN HEIGHT NORMALIZATION ---\n        // Calculate total value for each side\n        const leftTotals = sortedSources.map((source)=>{\n            const sourceId = \"\".concat(currentSource, \":\").concat(source);\n            return Array.from(linksMap.values()).filter((l)=>l.source === sourceId).reduce((sum, l)=>sum + l.value, 0);\n        });\n        const rightTotals = sortedTargets.map((target)=>{\n            const targetId = \"\".concat(currentTarget, \":\").concat(target);\n            return Array.from(linksMap.values()).filter((l)=>l.target === targetId).reduce((sum, l)=>sum + l.value, 0);\n        });\n        const leftSum = leftTotals.reduce((a, b)=>a + b, 0);\n        const rightSum = rightTotals.reduce((a, b)=>a + b, 0);\n        // If sums are different, scale the smaller side's node values and link values\n        let leftScale = 1, rightScale = 1;\n        if (leftSum > 0 && rightSum > 0 && leftSum !== rightSum) {\n            if (leftSum > rightSum) {\n                rightScale = leftSum / rightSum;\n            } else {\n                leftScale = rightSum / leftSum;\n            }\n        }\n        // Scale links\n        Array.from(linksMap.values()).forEach((link)=>{\n            const sourceId = link.source;\n            const targetId = link.target;\n            if (leftScale !== 1 && sortedSources.some((s)=>\"\".concat(currentSource, \":\").concat(s) === sourceId)) {\n                link.value *= leftScale;\n            }\n            if (rightScale !== 1 && sortedTargets.some((t)=>\"\".concat(currentTarget, \":\").concat(t) === targetId)) {\n                link.value *= rightScale;\n            }\n        });\n        const links = Array.from(linksMap.values());\n        // --- DYNAMIC NODE PADDING ---\n        // Reduce nodePadding for sparse data\n        let dynamicNodePadding = nodePadding;\n        if (sortedSources.length <= 4 && sortedTargets.length <= 4) {\n            dynamicNodePadding = Math.max(8, nodePadding / 2);\n        }\n        // Sankey layout\n        const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(dynamicNodePadding).extent([\n            [\n                0,\n                0\n            ],\n            [\n                chartWidth,\n                chartHeight\n            ]\n        ]);\n        const sankeyData = sankeyGenerator({\n            nodes: nodes.map((d)=>({\n                    ...d\n                })),\n            links: links.map((d)=>({\n                    ...d\n                }))\n        });\n        // --- FORCE ROW ALIGNMENT IF NODE SETS MATCH ---\n        // If left and right node sets have the same length and order, align their y0/y1\n        const leftNodes = sankeyData.nodes.filter((n)=>n.category === currentSource);\n        const rightNodes = sankeyData.nodes.filter((n)=>n.category === currentTarget);\n        if (leftNodes.length === rightNodes.length && leftNodes.every((n, i)=>rightNodes[i] && n.name === rightNodes[i].name)) {\n            // Force y0/y1 of right nodes to match left nodes\n            rightNodes.forEach((n, i)=>{\n                n.y0 = leftNodes[i].y0;\n                n.y1 = leftNodes[i].y1;\n            });\n        }\n        // --- VISUAL GUIDES: Render horizontal bands for each row ---\n        svg.selectAll(\"rect.row-guide\").data(leftNodes).enter().append(\"rect\").attr(\"class\", \"row-guide\").attr(\"x\", -margin.left).attr(\"y\", (d)=>d.y0).attr(\"width\", chartWidth + margin.left + margin.right).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"fill\", (d, i)=>i % 2 === 0 ? \"#f5f7fa\" : \"#e9eef5\").attr(\"opacity\", 0.25).lower();\n        // Compute vertical offset to center the diagram\n        const nodeYs = sankeyData.nodes.map((d)=>[\n                d.y0,\n                d.y1\n            ]).flat();\n        const minY = Math.min(...nodeYs);\n        const maxY = Math.max(...nodeYs);\n        const usedHeight = maxY - minY;\n        const offsetY = Math.max(0, (chartHeight - usedHeight) / 2 - minY);\n        // Create a group for the chart area with margin translation and vertical centering\n        const g = svg.append(\"g\").attr(\"transform\", \"translate(\".concat(margin.left, \",\").concat(margin.top + offsetY, \")\"));\n        let defs = svg.select(\"defs\");\n        if (defs.empty()) defs = svg.append(\"defs\");\n        let linksG = g.append(\"g\").attr(\"class\", \"links\");\n        let nodesG = g.append(\"g\").attr(\"class\", \"nodes\");\n        // Remove old gradients (no longer needed)\n        defs.selectAll(\"linearGradient.link-gradient\").remove();\n        // --- Add clipPath for links group with tighter bounds ---\n        svg.select(\"defs\").selectAll(\"#link-clip\").remove();\n        defs.append(\"clipPath\").attr(\"id\", \"link-clip\").append(\"rect\").attr(\"x\", margin.left).attr(\"y\", margin.top).attr(\"width\", chartWidth).attr(\"height\", chartHeight);\n        linksG.attr(\"clip-path\", \"url(#link-clip)\");\n        // Add glow filter for dark mode\n        defs.selectAll(\"#dark-mode-glow\").remove();\n        if (settings.isDarkMode) {\n            const glowFilter = defs.append(\"filter\").attr(\"id\", \"dark-mode-glow\").attr(\"x\", \"-50%\").attr(\"y\", \"-50%\").attr(\"width\", \"200%\").attr(\"height\", \"200%\");\n            glowFilter.append(\"feGaussianBlur\").attr(\"stdDeviation\", \"1.5\").attr(\"result\", \"coloredBlur\");\n            const feMerge = glowFilter.append(\"feMerge\");\n            feMerge.append(\"feMergeNode\").attr(\"in\", \"coloredBlur\");\n            feMerge.append(\"feMergeNode\").attr(\"in\", \"SourceGraphic\");\n        }\n        // --- Links update pattern ---\n        // All links are now between real nodes, with isDummy property for visual distinction\n        const filteredLinks = sankeyData.links;\n        // Remove mix-blend-mode in dark mode to prevent color washing out\n        linksG.style(\"mix-blend-mode\", settings.isDarkMode ? \"normal\" : \"multiply\");\n        const linkKey = (d)=>\"\".concat(d.source.id, \"→\").concat(d.target.id);\n        const linkSel = linksG.selectAll(\"path\").data(filteredLinks, linkKey);\n        // EXIT: fade out and remove all old links\n        linkSel.exit().transition().duration(400).attr(\"opacity\", 0).remove();\n        // Check if this is a category change that should trigger animation\n        const isCategoryChange = lastCategoryChange.source !== currentSource || lastCategoryChange.target !== currentTarget;\n        // ENTER: draw in all new links with improved animation\n        const newLinks = linksG.selectAll(\"path\").data(filteredLinks, linkKey).enter().append(\"path\").attr(\"d\", clampedSankeyLinkHorizontal()).attr(\"stroke\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d.source, getCurrentThemeColors(), settings.isDarkMode)).attr(\"stroke-width\", (d)=>Math.max(settings.isDarkMode ? 2 : 1, d.width)).attr(\"fill\", \"none\").attr(\"filter\", (d)=>{\n            if (hoveredLink === d) return \"url(#glow)\";\n            return settings.isDarkMode ? \"url(#dark-mode-glow)\" : null;\n        }).attr(\"pointer-events\", \"all\").attr(\"stroke-linecap\", \"round\").attr(\"opacity\", (d)=>{\n            // Dummy links: very low opacity\n            if (d.isDummy) return 0.08;\n            // Adjust opacity based on dark mode for better visibility\n            const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n            const highlightOpacity = settings.isDarkMode ? 1.0 : 0.9;\n            const dimOpacity = settings.isDarkMode ? 0.4 : 0.1;\n            // Default opacity when no highlighting\n            if (animationPhase !== \"highlighting\") return baseOpacity;\n            // Highlight links from the active source\n            if (hoveredSourceIndex !== null) {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n            }\n            // Highlight links to the active target\n            if (hoveredTargetIndex !== null) {\n                const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n            }\n            return baseOpacity;\n        }).attr(\"stroke-dasharray\", (d)=>d.isDummy ? \"4,4\" : null); // Dashed for dummy links\n        // Apply drawing animation only on category changes to prevent flickering\n        if (isCategoryChange) {\n            newLinks.each(function(d) {\n                const path = d3__WEBPACK_IMPORTED_MODULE_2__.select(this);\n                const totalLength = this.getTotalLength();\n                // Start with invisible path\n                path.attr(\"stroke-dasharray\", totalLength).attr(\"stroke-dashoffset\", totalLength).attr(\"opacity\", 0).transition().delay((d, i)=>i * 25) // Reduced stagger delay\n                .duration(600) // Reduced from 1200ms to 600ms\n                .ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut).attr(\"opacity\", (d)=>{\n                    // Adjust opacity based on dark mode for better visibility\n                    const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n                    const highlightOpacity = settings.isDarkMode ? 1.0 : 0.9;\n                    const dimOpacity = settings.isDarkMode ? 0.4 : 0.1;\n                    // Highlight links from the active source or to the active target\n                    if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                        const hoveredSource = sortedSources[hoveredSourceIndex];\n                        return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n                    }\n                    if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                        const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                        return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n                    }\n                    return baseOpacity;\n                }).attr(\"stroke-dashoffset\", 0).on(\"end\", function() {\n                    d3__WEBPACK_IMPORTED_MODULE_2__.select(this).attr(\"stroke-linecap\", \"butt\") // crisp edge after animation\n                    .attr(\"stroke-dasharray\", null).attr(\"stroke-dashoffset\", null);\n                });\n            });\n        } else {\n            // For non-category changes, just set the opacity directly\n            newLinks.attr(\"opacity\", (d)=>{\n                // Adjust opacity based on dark mode for better visibility\n                const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n                const highlightOpacity = settings.isDarkMode ? 1.0 : 0.9;\n                const dimOpacity = settings.isDarkMode ? 0.4 : 0.1;\n                // Highlight links from the active source or to the active target\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredSource = sortedSources[hoveredSourceIndex];\n                    return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n                }\n                if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                    return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n                }\n                return baseOpacity;\n            });\n        }\n        // Add hover interactions\n        newLinks.on(\"mousemove\", function(event, d) {\n            setHoveredLink(d);\n            setTooltip({\n                x: event.offsetX,\n                y: event.offsetY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"font-bold\",\n                            children: [\n                                d.source.name,\n                                \" → \",\n                                d.target.name\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                            lineNumber: 1034,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                d.value,\n                                \" attendees\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                            lineNumber: 1035,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                    lineNumber: 1033,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", function() {\n            setHoveredLink(null);\n            setTooltip(null);\n        });\n        // --- Nodes update pattern (rects) ---\n        const filteredNodes = sankeyData.nodes;\n        const nodeSel = nodesG.selectAll(\"rect\").data(filteredNodes, (d)=>d.id);\n        nodeSel.exit().remove();\n        nodeSel.join((enter)=>enter.append(\"rect\").attr(\"x\", (d)=>d.x0).attr(\"y\", (d)=>d.y0).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"width\", (d)=>d.x1 - d.x0).attr(\"fill\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d, getCurrentThemeColors(), settings.isDarkMode)).attr(\"stroke\", settings.isDarkMode ? \"#444\" : \"#22223b\").attr(\"opacity\", (d)=>{\n                // Source nodes: only the highlighted one is bright\n                if (d.category === currentSource) {\n                    if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                        return d.name === sortedSources[hoveredSourceIndex] ? 1 : 0.3;\n                    }\n                    return 0.9; // Increased from 0.6 to 0.9 for more prominence\n                }\n                // Target nodes: only those connected to the highlighted source or hovered target are bright\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredSource = sortedSources[hoveredSourceIndex];\n                    const isConnected = filteredLinks.some((l)=>l.source.name === hoveredSource && l.target.name === d.name);\n                    return isConnected ? 1 : 0.3;\n                }\n                if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                    return d.name === hoveredTarget ? 1 : 0.3;\n                }\n                return 0.9; // Increased from 0.6 to 0.9 for more prominence\n            }).on(\"mousemove\", function(event, d) {\n                setHoveredNode(d);\n                setTooltip({\n                    x: event.offsetX,\n                    y: event.offsetY,\n                    content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"font-bold\",\n                                children: d.name\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                lineNumber: 1087,\n                                columnNumber: 17\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Category: \",\n                                    d.category\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                lineNumber: 1088,\n                                columnNumber: 17\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Responses: \",\n                                    d.value\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                lineNumber: 1089,\n                                columnNumber: 17\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                        lineNumber: 1086,\n                        columnNumber: 15\n                    }, this)\n                });\n            }).on(\"mouseleave\", function() {\n                setHoveredNode(null);\n                setTooltip(null);\n            }).on(\"mouseenter\", function(event, d) {\n                if (d.category === currentSource) {\n                    const idx = sortedSources.indexOf(d.name);\n                    setHoveredSourceIndex(idx);\n                    setAnimationPhase(\"highlighting\");\n                }\n                if (d.category === currentTarget) {\n                    const idx = sortedTargets.indexOf(d.name);\n                    setHoveredTargetIndex(idx);\n                    setAnimationPhase(\"highlighting\");\n                }\n            }).on(\"mouseleave\", function(event, d) {\n                if (d.category === currentSource) {\n                    setHoveredSourceIndex(null);\n                    setAnimationPhase(\"full\");\n                }\n                if (d.category === currentTarget) {\n                    setHoveredTargetIndex(null);\n                    setAnimationPhase(\"full\");\n                }\n            }), (update)=>update.transition(d3__WEBPACK_IMPORTED_MODULE_2__.transition().duration(750).ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut)).attr(\"x\", (d)=>d.x0).attr(\"y\", (d)=>d.y0).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"width\", (d)=>d.x1 - d.x0).attr(\"fill\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d, getCurrentThemeColors(), settings.isDarkMode)).attr(\"opacity\", (d)=>{\n                // Source nodes: only the highlighted one is bright\n                if (d.category === currentSource) {\n                    if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                        return d.name === sortedSources[hoveredSourceIndex] ? 1 : 0.3;\n                    }\n                    return 0.9; // Increased from 0.6 to 0.9 for more prominence\n                }\n                // Target nodes: only those connected to the highlighted source or hovered target are bright\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredSource = sortedSources[hoveredSourceIndex];\n                    const isConnected = filteredLinks.some((l)=>l.source.name === hoveredSource && l.target.name === d.name);\n                    return isConnected ? 1 : 0.3;\n                }\n                if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                    return d.name === hoveredTarget ? 1 : 0.3;\n                }\n                return 0.9; // Increased from 0.6 to 0.9 for more prominence\n            }));\n        // --- Node labels (re-render as before) ---\n        g.selectAll(\"g.label-layer\").remove();\n        const labelLayer = g.append(\"g\").attr(\"class\", \"label-layer\");\n        const sourceNodeSet = new Set(sortedSources);\n        const targetNodeSet = new Set(sortedTargets);\n        const sourceNodes = sankeyData.nodes.filter((d)=>d.category === currentSource);\n        const targetNodes = sankeyData.nodes.filter((d)=>d.category === currentTarget);\n        sourceNodes.forEach((node)=>{\n            if (sourceNodeSet.has(node.name)) {\n                labelLayer.append(\"text\").attr(\"x\", -labelPadding).attr(\"y\", (node.y0 + node.y1) / 2).attr(\"text-anchor\", \"end\").attr(\"alignment-baseline\", \"middle\").attr(\"font-family\", nodeLabelFontFamily).attr(\"font-weight\", nodeLabelFontWeight).attr(\"font-size\", labelFontSize).attr(\"fill\", nodeLabelColor).attr(\"aria-label\", node.name).attr(\"opacity\", node.value === 0 ? 0.5 : 1).text(node.name);\n            }\n        });\n        targetNodes.forEach((node)=>{\n            if (targetNodeSet.has(node.name)) {\n                labelLayer.append(\"text\").attr(\"x\", chartWidth + labelPadding).attr(\"y\", (node.y0 + node.y1) / 2).attr(\"text-anchor\", \"start\").attr(\"alignment-baseline\", \"middle\").attr(\"font-family\", nodeLabelFontFamily).attr(\"font-weight\", nodeLabelFontWeight).attr(\"font-size\", labelFontSize).attr(\"fill\", nodeLabelColor).attr(\"aria-label\", node.name).attr(\"opacity\", node.value === 0 ? 0.5 : 1).text(node.name);\n            }\n        });\n        // 6. Update insights\n        let mostCommon = links.length > 0 ? links.reduce((a, b)=>b.value > a.value ? b : a, links[0]) : undefined;\n        setInsights([\n            {\n                title: \"Total Responses\",\n                value: data.length\n            },\n            {\n                title: \"Current View\",\n                value: \"\".concat(currentSource, \" → \").concat(currentTarget)\n            },\n            mostCommon ? {\n                title: \"Most Common Flow\",\n                value: \"\".concat(mostCommon.source.split(\":\")[1], \" → \").concat(mostCommon.target.split(\":\")[1]),\n                description: \"\".concat(mostCommon.value, \" attendees\")\n            } : {\n                title: \"Most Common Flow\",\n                value: \"N/A\",\n                description: \"\"\n            }\n        ]);\n        // 7. Automatic animation on question change only\n        const transition = d3__WEBPACK_IMPORTED_MODULE_2__.transition().duration(750).ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut);\n        // Animate nodes\n        nodeSel.transition(transition).attr(\"x\", (d)=>d.x0).attr(\"y\", (d)=>d.y0).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"width\", (d)=>d.x1 - d.x0).attr(\"fill\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d, getCurrentThemeColors(), settings.isDarkMode));\n    }, [\n        filteredData,\n        currentSource,\n        currentTarget,\n        containerWidth,\n        containerHeight,\n        settings.categoryColors,\n        settings.isDarkMode,\n        lastCategoryChange,\n        getCurrentThemeColors\n    ]);\n    // Create sorted targets for consistent highlighting\n    const sortedTargetsForHighlight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const sorted = [\n            ...targets\n        ];\n        if (currentTarget === \"years_at_medtronic\") {\n            sorted.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sorted.sort();\n        }\n        return sorted;\n    }, [\n        targets,\n        currentTarget\n    ]);\n    // Separate effect to update visual highlighting during animation\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        const g = svg.select(\"g\");\n        // Update node opacity based on animation state\n        g.selectAll(\"rect\").transition().duration(200).attr(\"opacity\", function(d) {\n            // Source nodes: only the highlighted one is bright\n            if (d.category === currentSource) {\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    return d.name === sortedSources[hoveredSourceIndex] ? 1 : 0.2; // Slightly higher for better visibility\n                }\n                return 0.9; // Increased from 0.6 to 0.9 for more prominence\n            }\n            // Target nodes: highlight those connected to the highlighted source\n            if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                // Check if this target node is connected to the highlighted source\n                const isConnected = svg.selectAll(\"path\").data().some((link)=>link.source.name === hoveredSource && link.target.name === d.name);\n                return isConnected ? 1 : 0.2; // Slightly higher for better visibility\n            }\n            if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                const hoveredTarget = sortedTargetsForHighlight[hoveredTargetIndex];\n                return d.name === hoveredTarget ? 1 : 0.2;\n            }\n            return 0.9; // Increased from 0.6 to 0.9 for more prominence\n        }).attr(\"stroke-width\", function(d) {\n            // Add thicker stroke to highlighted source node\n            if (d.category === currentSource && hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                return d.name === sortedSources[hoveredSourceIndex] ? 3 : 1;\n            }\n            return 1;\n        });\n        // Update link opacity based on animation state\n        g.selectAll(\"path\").transition().duration(200).attr(\"opacity\", function(d) {\n            // Adjust opacity based on dark mode for better visibility\n            const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n            const highlightOpacity = settings.isDarkMode ? 1.0 : 0.95;\n            const dimOpacity = settings.isDarkMode ? 0.35 : 0.05;\n            // Default opacity when no highlighting\n            if (animationPhase !== \"highlighting\") return baseOpacity;\n            // Highlight links from the active source\n            if (hoveredSourceIndex !== null) {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n            }\n            // Highlight links to the active target\n            if (hoveredTargetIndex !== null) {\n                const hoveredTarget = sortedTargetsForHighlight[hoveredTargetIndex];\n                return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n            }\n            return baseOpacity;\n        }).attr(\"stroke-width\", function(d) {\n            // Make highlighted links thicker\n            if (animationPhase === \"highlighting\" && hoveredSourceIndex !== null) {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                return d.source.name === hoveredSource ? Math.max(2, d.width * 1.2) : Math.max(1, d.width);\n            }\n            return Math.max(1, d.width);\n        });\n        console.log(\"\\uD83C\\uDFA8 Visual highlighting updated:\", {\n            hoveredSourceIndex,\n            sourceName: hoveredSourceIndex !== null ? sortedSources[hoveredSourceIndex] : null,\n            hoveredTargetIndex,\n            targetName: hoveredTargetIndex !== null ? sortedTargetsForHighlight[hoveredTargetIndex] : null,\n            animationPhase\n        });\n    }, [\n        hoveredSourceIndex,\n        hoveredTargetIndex,\n        animationPhase,\n        sortedSources,\n        sortedTargetsForHighlight,\n        currentSource,\n        currentTarget\n    ]);\n    // Separate effect for hover interactions (doesn't re-render the whole visualization)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        const g = svg.select(\"g\");\n        // Update link hover effects\n        g.selectAll(\"path\").each(function(d) {\n            const path = d3__WEBPACK_IMPORTED_MODULE_2__.select(this);\n            const isHovered = hoveredLink === d;\n            path.attr(\"filter\", isHovered ? \"url(#glow)\" : null);\n        });\n    }, [\n        hoveredNode,\n        hoveredLink\n    ]);\n    // Tooltip fadeout logic\n    const [tooltipVisible, setTooltipVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const tooltipTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (tooltip) {\n            setTooltipVisible(true);\n            if (tooltipTimeoutRef.current) clearTimeout(tooltipTimeoutRef.current);\n            tooltipTimeoutRef.current = setTimeout(()=>{\n                setTooltipVisible(false);\n                setTimeout(()=>setTooltip(null), 400); // Wait for fadeout\n            }, 5000);\n        } else {\n            setTooltipVisible(false);\n            if (tooltipTimeoutRef.current) clearTimeout(tooltipTimeoutRef.current);\n        }\n        return ()=>{\n            if (tooltipTimeoutRef.current) clearTimeout(tooltipTimeoutRef.current);\n        };\n    }, [\n        tooltip\n    ]);\n    const tooltipEl = tooltip ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: \"absolute\",\n            left: tooltip.x + 16,\n            top: tooltip.y + 16,\n            background: settings.isDarkMode ? \"rgba(20,20,30,0.98)\" : \"rgba(255,255,255,0.98)\",\n            color: settings.isDarkMode ? \"#fff\" : \"#170F5F\",\n            padding: \"8px 12px\",\n            borderRadius: 6,\n            pointerEvents: \"none\",\n            zIndex: 100,\n            fontFamily: \"Avenir Next World, sans-serif\",\n            fontWeight: 600,\n            fontSize: 14,\n            boxShadow: settings.isDarkMode ? \"0 4px 24px 0 rgba(16, 16, 235, 0.12)\" : \"0 4px 24px 0 rgba(0, 0, 0, 0.15)\",\n            border: settings.isDarkMode ? \"1px solid rgba(255,255,255,0.1)\" : \"1px solid rgba(0,0,0,0.1)\",\n            maxWidth: 280,\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden\",\n            textOverflow: \"ellipsis\",\n            opacity: tooltipVisible ? 1 : 0,\n            transition: \"opacity 0.4s\"\n        },\n        role: \"tooltip\",\n        \"aria-live\": \"polite\",\n        children: tooltip.content\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n        lineNumber: 1353,\n        columnNumber: 5\n    }, this) : null;\n    // Create sorted sources array for highlighting (same as rendering and animation)\n    const sortedSourcesForHighlight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        let visualOrder = [];\n        if (filteredData.length && chartWidth > 0 && chartHeight > 0) {\n            const sourcesForNodes = [\n                ...sources\n            ];\n            if (currentSource === \"years_at_medtronic\") {\n                sourcesForNodes.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n            } else {\n                sourcesForNodes.sort();\n            }\n            const nodes = [\n                ...sourcesForNodes.map((name)=>({\n                        id: \"\".concat(currentSource, \":\").concat(name),\n                        name,\n                        category: currentSource\n                    })),\n                ...targets.map((name)=>({\n                        id: \"\".concat(currentTarget, \":\").concat(name),\n                        name,\n                        category: currentTarget\n                    }))\n            ];\n            const linksMap = new Map();\n            filteredData.forEach((d)=>{\n                const source = currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentSource];\n                const target = currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentTarget];\n                const sourceId = \"\".concat(currentSource, \":\").concat(source);\n                const targetId = \"\".concat(currentTarget, \":\").concat(target);\n                if (!sourcesForNodes.includes(source) || !targets.includes(target)) return;\n                const key = \"\".concat(sourceId, \"→\").concat(targetId);\n                if (!linksMap.has(key)) {\n                    linksMap.set(key, {\n                        source: sourceId,\n                        target: targetId,\n                        value: 0\n                    });\n                }\n                linksMap.get(key).value += 1;\n            });\n            const links = Array.from(linksMap.values());\n            const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(nodePadding).extent([\n                [\n                    0,\n                    0\n                ],\n                [\n                    chartWidth,\n                    chartHeight\n                ]\n            ]);\n            const sankeyData = sankeyGenerator({\n                nodes: nodes.map((d)=>({\n                        ...d\n                    })),\n                links: links.map((d)=>({\n                        ...d\n                    }))\n            });\n            const sourceNodes = sankeyData.nodes.filter((d)=>d.category === currentSource);\n            visualOrder = sourceNodes.slice().sort((a, b)=>a.y0 - b.y0).map((d)=>d.name);\n        }\n        return visualOrder.length ? visualOrder : [\n            ...sources\n        ];\n    }, [\n        filteredData,\n        currentSource,\n        currentTarget,\n        sources,\n        targets,\n        chartWidth,\n        chartHeight,\n        nodePadding\n    ]);\n    // Determine which source or target to highlight based on animation state\n    let highlightSourceName = null;\n    let highlightTargetName = null;\n    if (isInFullOpacityState) {\n        highlightSourceName = null;\n        highlightTargetName = null;\n    } else if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n        highlightSourceName = sortedSourcesForHighlight[hoveredSourceIndex];\n    } else if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n        highlightTargetName = targets[hoveredTargetIndex];\n    }\n    // Enhanced animation pause/resume with debug tracking\n    const pauseAnimation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((reason)=>{\n        if (animationRef.current.running && !animationRef.current.isPaused) {\n            console.log(\"⏸️  PAUSING ANIMATION:\", reason, {\n                currentSourceIndex: animationRef.current.currentSourceIndex,\n                currentTargetIndex: animationRef.current.currentTargetIndex,\n                currentSource,\n                currentTarget\n            });\n            animationRef.current.isPaused = true;\n            animationRef.current.pausedAt = Date.now();\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n        }\n    }, [\n        currentSource,\n        currentTarget\n    ]);\n    const resumeAnimation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((reason)=>{\n        if (animationRef.current.running && animationRef.current.isPaused) {\n            console.log(\"▶️  RESUMING ANIMATION:\", reason, {\n                currentSourceIndex: animationRef.current.currentSourceIndex,\n                currentTargetIndex: animationRef.current.currentTargetIndex,\n                pausedDuration: Date.now() - animationRef.current.pausedAt\n            });\n            animationRef.current.isPaused = false;\n            animationRef.current.resumeFrom = \"source\";\n            // Resume animation from current position with a small delay to ensure state is updated\n            setTimeout(()=>{\n                if (animationRef.current.running && !animationRef.current.isPaused) {\n                    animate();\n                }\n            }, 100);\n        }\n    }, [\n        animate\n    ]);\n    // Update hover handlers with proper state management\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        // Update link hover behavior\n        svg.selectAll(\"path\").on(\"mouseenter\", function(event, d) {\n            // Pause animation during hover\n            pauseAnimation(\"link hover\");\n            // Set hover states\n            setHoveredLink(d);\n            setAnimationPhase(\"highlighting\");\n            // Handle source node hover\n            if (d.source && d.source.category === currentSource) {\n                const idx = sortedSources.indexOf(d.source.name);\n                setHoveredSourceIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual source highlight:\", d.source.name, \"index:\", idx);\n            }\n            // Handle target node hover\n            if (d.target && d.target.category === currentTarget) {\n                const idx = sortedTargetsForHighlight.indexOf(d.target.name);\n                setHoveredTargetIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual target highlight:\", d.target.name, \"index:\", idx);\n            }\n        }).on(\"mouseleave\", function() {\n            // Resume animation\n            resumeAnimation(\"link hover end\");\n            // Clear hover states\n            setHoveredLink(null);\n            setHoveredSourceIndex(null);\n            setHoveredTargetIndex(null);\n            setAnimationPhase(\"full\");\n        });\n        // Update node hover behavior\n        svg.selectAll(\"rect\").on(\"mouseenter\", function(event, d) {\n            // Pause animation during hover\n            pauseAnimation(\"node hover\");\n            setAnimationPhase(\"highlighting\");\n            // Handle source node hover\n            if (d.category === currentSource) {\n                const idx = sortedSources.indexOf(d.name);\n                setHoveredSourceIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual source node highlight:\", d.name, \"index:\", idx);\n            }\n            // Handle target node hover\n            if (d.category === currentTarget) {\n                const idx = sortedTargetsForHighlight.indexOf(d.name);\n                setHoveredTargetIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual target node highlight:\", d.name, \"index:\", idx);\n            }\n        }).on(\"mouseleave\", function() {\n            // Resume animation\n            resumeAnimation(\"node hover end\");\n            // Clear hover states\n            setHoveredSourceIndex(null);\n            setHoveredTargetIndex(null);\n            setAnimationPhase(\"full\");\n        });\n        return ()=>{\n            // Clean up all event listeners\n            svg.selectAll(\"path, rect\").on(\"mouseenter\", null).on(\"mouseleave\", null);\n        };\n    }, [\n        sortedSources,\n        sortedTargetsForHighlight,\n        currentSource,\n        currentTarget,\n        pauseAnimation,\n        resumeAnimation\n    ]);\n    // Main rendering effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current || !data.length) return;\n    // The main rendering logic handles all opacity updates\n    // This ensures data binding is correct and prevents the undefined error\n    }, [\n        filteredData,\n        hoveredSourceIndex,\n        hoveredTargetIndex,\n        animationPhase,\n        sortedSources,\n        targets,\n        currentSource,\n        currentTarget\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\",\n            minHeight: 220,\n            minWidth: 320,\n            position: \"relative\"\n        },\n        children: [\n            (nodeCount <= 2 || sources.length <= 1 || targets.length <= 1) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"absolute\",\n                    top: 40,\n                    left: \"50%\",\n                    transform: \"translateX(-50%)\",\n                    background: \"rgba(255,255,200,0.95)\",\n                    color: \"#170F5F\",\n                    padding: \"12px 24px\",\n                    borderRadius: 8,\n                    fontWeight: 600,\n                    fontSize: 18,\n                    zIndex: 10,\n                    boxShadow: \"0 2px 12px 0 rgba(0,0,0,0.08)\"\n                },\n                children: \"Not enough data to show a meaningful flow diagram.\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                lineNumber: 1576,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                ref: svgRef,\n                width: chartWidth + margin.left + margin.right,\n                height: chartHeight + margin.top + margin.bottom,\n                viewBox: \"0 0 \".concat(chartWidth + margin.left + margin.right, \" \").concat(chartHeight + margin.top + margin.bottom),\n                style: {\n                    display: \"block\",\n                    width: \"100%\",\n                    height: \"100%\",\n                    background: \"transparent\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                        transform: \"translate(\".concat(margin.left, \",\").concat(margin.top, \")\")\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                        lineNumber: 1601,\n                        columnNumber: 9\n                    }, this),\n                    debugOn && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                        transform: \"translate(\".concat(margin.left, \",\").concat(margin.top, \")\"),\n                        children: [\n                            Array.isArray(debugSankeyData === null || debugSankeyData === void 0 ? void 0 : debugSankeyData.nodes) && debugSankeyData.nodes.map((d, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                    x: d.x0,\n                                    y: d.y0,\n                                    width: d.x1 - d.x0,\n                                    height: d.y1 - d.y0,\n                                    fill: \"none\",\n                                    stroke: \"magenta\",\n                                    strokeDasharray: \"4 2\",\n                                    pointerEvents: \"none\"\n                                }, \"debug-node-\".concat(i), false, {\n                                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                    lineNumber: 1609,\n                                    columnNumber: 15\n                                }, this)),\n                            Array.isArray(debugSankeyData === null || debugSankeyData === void 0 ? void 0 : debugSankeyData.links) && debugSankeyData.links.map((d, i)=>{\n                                const path = clampedSankeyLinkHorizontal()(d) || \"\";\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                    d: path,\n                                    fill: \"none\",\n                                    stroke: \"cyan\",\n                                    strokeWidth: 2,\n                                    pointerEvents: \"none\"\n                                }, \"debug-link-\".concat(i), false, {\n                                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                    lineNumber: 1625,\n                                    columnNumber: 17\n                                }, this);\n                            })\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                        lineNumber: 1606,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                lineNumber: 1593,\n                columnNumber: 7\n            }, this),\n            tooltipEl\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n        lineNumber: 1573,\n        columnNumber: 5\n    }, this);\n}\n_s(AlluvialDiagram, \"6gYfAdpGWkB9+1STC2gDcKJDM6o=\", false, function() {\n    return [\n        _shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_4__.useVisualizationData,\n        _lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__.useAppContext\n    ];\n});\n_c = AlluvialDiagram;\nvar _c;\n$RefreshReg$(_c, \"AlluvialDiagram\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0RhdGFWaXN1YWxpemF0aW9uL0FsbHV2aWFsRGlhZ3JhbS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFFNkY7QUFDcEU7QUFDZ0M7QUFHWTtBQUdvQjtBQUVoQztBQW1EekQsTUFBTVksa0JBQWtCO0lBQ3RCO1FBQUVDLE9BQU87UUFBc0JDLE9BQU87SUFBcUI7SUFDM0Q7UUFBRUQsT0FBTztRQUFrQkMsT0FBTztJQUFpQjtJQUNuRDtRQUFFRCxPQUFPO1FBQWFDLE9BQU87SUFBWTtJQUN6QztRQUFFRCxPQUFPO1FBQW9CQyxPQUFPO0lBQW1CO0lBQ3ZEO1FBQUVELE9BQU87UUFBY0MsT0FBTztJQUFhO0NBRTVDO0FBRUQsTUFBTUMsbUJBQW1CO0lBQUM7SUFBTztJQUFRO0lBQVM7SUFBUztDQUFNO0FBRWpFLG9EQUFvRDtBQUNwRCxNQUFNQyx3QkFBd0IsQ0FBQ0M7SUFDN0IsSUFBSSxPQUFPQSxVQUFVLFlBQVlDLE1BQU1ELFVBQVVBLFFBQVEsR0FBRyxPQUFPO0lBQ25FLElBQUlBLFNBQVMsR0FBRyxPQUFPO0lBQ3ZCLElBQUlBLFNBQVMsSUFBSSxPQUFPO0lBQ3hCLElBQUlBLFNBQVMsSUFBSSxPQUFPO0lBQ3hCLElBQUlBLFNBQVMsSUFBSSxPQUFPO0lBQ3hCLE9BQU87QUFDVDtBQUVBLG1FQUFtRTtBQUNuRSxTQUFTRSxlQUFlQyxDQUFNO1FBQUVDLGdCQUFBQSxpRUFBZ0IsR0FBR0MsZ0JBQUFBLGlFQUFnQixLQUFLQyxhQUFBQSxpRUFBYSxLQUFLQyxjQUFBQSxpRUFBYztJQUN0Ryx3Q0FBd0M7SUFDeEMsSUFBSUMsS0FBS0wsRUFBRU0sTUFBTSxDQUFDQyxFQUFFO0lBQ3BCLElBQUlBLEtBQUtQLEVBQUVRLE1BQU0sQ0FBQ0gsRUFBRTtJQUNwQixJQUFJSSxLQUFLVCxFQUFFUyxFQUFFO0lBQ2IsSUFBSUMsS0FBS1YsRUFBRVUsRUFBRTtJQUViLHdEQUF3RDtJQUN4REws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NEI3UCxPQUFmQSxPQUFPSSxJQUFJLEVBQUMsS0FBYyxPQUFYSixPQUFPQyxHQUFHLEVBQUM7OzRCQUVsRDdDLE1BQU1DLE9BQU8sQ0FBQ3NLLDRCQUFBQSxzQ0FBQUEsZ0JBQWlCbEUsS0FBSyxLQUFLa0UsZ0JBQWdCbEUsS0FBSyxDQUFDeEYsR0FBRyxDQUFDLENBQUN0RSxHQUFRNlAsa0JBQzNFLDhEQUFDd0c7b0NBRUNoRSxHQUFHclMsRUFBRUssRUFBRTtvQ0FDUGtTLEdBQUd2UyxFQUFFUyxFQUFFO29DQUNQbUIsT0FBTzVCLEVBQUVPLEVBQUUsR0FBR1AsRUFBRUssRUFBRTtvQ0FDbEJ3QixRQUFRN0IsRUFBRVUsRUFBRSxHQUFHVixFQUFFUyxFQUFFO29DQUNuQjZWLE1BQUs7b0NBQ0xDLFFBQU87b0NBQ1BDLGlCQUFnQjtvQ0FDaEJoQyxlQUFjO21DQVJULGNBQWdCLE9BQUYzRTs7Ozs7NEJBWXRCcE0sTUFBTUMsT0FBTyxDQUFDc0ssNEJBQUFBLHNDQUFBQSxnQkFBaUJwRCxLQUFLLEtBQUtvRCxnQkFBZ0JwRCxLQUFLLENBQUN0RyxHQUFHLENBQUMsQ0FBQ3RFLEdBQVE2UDtnQ0FDM0UsTUFBTWdDLE9BQU8xUSw4QkFBOEJuQixNQUFNO2dDQUNqRCxxQkFDRSw4REFBQzZSO29DQUVDN1IsR0FBRzZSO29DQUNIeUUsTUFBSztvQ0FDTEMsUUFBTztvQ0FDUEUsYUFBYTtvQ0FDYmpDLGVBQWM7bUNBTFQsY0FBZ0IsT0FBRjNFOzs7Ozs0QkFRekI7Ozs7Ozs7Ozs7Ozs7WUFJTHFFOzs7Ozs7O0FBR1A7R0F6K0N3QnZTOztRQTJCYXZDLDhFQUFvQkE7UUFDWEcsa0VBQWFBOzs7S0E1Qm5Db0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvRGF0YVZpc3VhbGl6YXRpb24vQWxsdXZpYWxEaWFncmFtLnRzeD9iOTZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgeyBzYW5rZXksIHNhbmtleUxpbmtIb3Jpem9udGFsIH0gZnJvbSAnZDMtc2Fua2V5Jztcbi8vIEB0cy1leHBlY3QtZXJyb3I6IE5vIHR5cGVzIGZvciBkMy1pbnRlcnBvbGF0ZS1wYXRoXG5pbXBvcnQgeyBpbnRlcnBvbGF0ZVBhdGggfSBmcm9tICdkMy1pbnRlcnBvbGF0ZS1wYXRoJztcbmltcG9ydCB7IHVzZVZpc3VhbGl6YXRpb25EYXRhIH0gZnJvbSAnLi9zaGFyZWQvdXNlVmlzdWFsaXphdGlvbkRhdGEnO1xuaW1wb3J0IHsgVmlzdWFsaXphdGlvbkNvbnRhaW5lciB9IGZyb20gJy4vc2hhcmVkL1Zpc3VhbGl6YXRpb25Db250YWluZXInO1xuaW1wb3J0IHsgRGF0YUluc2lnaHRQYW5lbCB9IGZyb20gJy4vc2hhcmVkL0RhdGFJbnNpZ2h0UGFuZWwnO1xuaW1wb3J0IHsgZ2V0WWVhcnNDb2xvclNjYWxlLCBnZXRZZWFyc0NhdGVnb3J5LCBnZXROb2RlQ29sb3IgfSBmcm9tICcuL3NoYXJlZC9jb2xvclV0aWxzJztcbmltcG9ydCB7IFF1ZXN0aW9uU2VsZWN0b3IgfSBmcm9tICcuL3NoYXJlZC9RdWVzdGlvblNlbGVjdG9yJztcbmltcG9ydCB7IHVzZUFwcENvbnRleHQgfSBmcm9tICdAL2xpYi9jb250ZXh0L0FwcENvbnRleHQnO1xuaW1wb3J0IHR5cGUgeyBEYXRhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlL3R5cGVzJztcblxuaW50ZXJmYWNlIEFsbHV2aWFsRGlhZ3JhbVByb3BzIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgYXV0b1BsYXk/OiBib29sZWFuO1xuICBvblF1ZXN0aW9uQ2hhbmdlPzogKHNvdXJjZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZykgPT4gdm9pZDtcbn1cblxudHlwZSBTdXJ2ZXlSZXNwb25zZSA9IERhdGFiYXNlWydwdWJsaWMnXVsnVGFibGVzJ11bJ3N1cnZleV9yZXNwb25zZXMnXVsnUm93J10gJiB7XG4gIGF0dGVuZGVlOiBEYXRhYmFzZVsncHVibGljJ11bJ1RhYmxlcyddWydhdHRlbmRlZXMnXVsnUm93J107XG59O1xuXG5pbnRlcmZhY2UgU2Fua2V5Tm9kZSB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgeDA6IG51bWJlcjtcbiAgeDE6IG51bWJlcjtcbiAgeTA6IG51bWJlcjtcbiAgeTE6IG51bWJlcjtcbiAgdmFsdWU6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFNhbmtleUxpbmsge1xuICBzb3VyY2U6IFNhbmtleU5vZGU7XG4gIHRhcmdldDogU2Fua2V5Tm9kZTtcbiAgdmFsdWU6IG51bWJlcjtcbiAgd2lkdGg6IG51bWJlcjtcbiAgeTA6IG51bWJlcjtcbiAgeTE6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEFuaW1hdGlvblN0YXRlIHtcbiAgdGltZXI6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbDtcbiAgcnVubmluZzogYm9vbGVhbjtcbiAgY3VycmVudFNvdXJjZUluZGV4OiBudW1iZXI7XG4gIGN1cnJlbnRUYXJnZXRJbmRleDogbnVtYmVyO1xuICBpc1BhdXNlZDogYm9vbGVhbjtcbiAgcGF1c2VkQXQ6IG51bWJlcjtcbiAgcmVzdW1lRnJvbTogJ3NvdXJjZScgfCAndGFyZ2V0JyB8IG51bGw7XG4gIGN5Y2xlQ291bnQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFRvb2x0aXBTdGF0ZSB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICBjb250ZW50OiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmNvbnN0IGF2YWlsYWJsZUZpZWxkcyA9IFtcbiAgeyB2YWx1ZTogJ3llYXJzX2F0X21lZHRyb25pYycsIGxhYmVsOiAnWWVhcnMgYXQgTWVkdHJvbmljJyB9LFxuICB7IHZhbHVlOiAnbGVhcm5pbmdfc3R5bGUnLCBsYWJlbDogJ0xlYXJuaW5nIFN0eWxlJyB9LFxuICB7IHZhbHVlOiAnc2hhcGVkX2J5JywgbGFiZWw6ICdTaGFwZWQgQnknIH0sXG4gIHsgdmFsdWU6ICdwZWFrX3BlcmZvcm1hbmNlJywgbGFiZWw6ICdQZWFrIFBlcmZvcm1hbmNlJyB9LFxuICB7IHZhbHVlOiAnbW90aXZhdGlvbicsIGxhYmVsOiAnTW90aXZhdGlvbicgfSxcbiAgLy8gQWRkIG1vcmUgZmllbGRzIGFzIG5lZWRlZFxuXTtcblxuY29uc3QgWUVBUlNfQ0FURUdPUklFUyA9IFsnMC01JywgJzYtMTAnLCAnMTEtMTUnLCAnMTYtMjAnLCAnMjArJ107XG5cbi8vIE1vdmUgdGhpcyBmdW5jdGlvbiB1cCBzbyBpdCBpcyBkZWZpbmVkIGJlZm9yZSB1c2VcbmNvbnN0IGdldFZhbGlkWWVhcnNDYXRlZ29yeSA9ICh5ZWFyczogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgaWYgKHR5cGVvZiB5ZWFycyAhPT0gJ251bWJlcicgfHwgaXNOYU4oeWVhcnMpIHx8IHllYXJzIDwgMCkgcmV0dXJuICcwLTUnO1xuICBpZiAoeWVhcnMgPD0gNSkgcmV0dXJuICcwLTUnO1xuICBpZiAoeWVhcnMgPD0gMTApIHJldHVybiAnNi0xMCc7XG4gIGlmICh5ZWFycyA8PSAxNSkgcmV0dXJuICcxMS0xNSc7XG4gIGlmICh5ZWFycyA8PSAyMCkgcmV0dXJuICcxNi0yMCc7XG4gIHJldHVybiAnMjArJztcbn07XG5cbi8vIEN1c3RvbSB3YXZlIHBhdGggZ2VuZXJhdG9yIGZvciBTYW5rZXkgbGlua3Mgd2l0aCBib3VuZHMgY2hlY2tpbmdcbmZ1bmN0aW9uIHNhbmtleUxpbmtXYXZlKGQ6IGFueSwgd2F2ZUFtcGxpdHVkZSA9IDgsIHdhdmVGcmVxdWVuY3kgPSAxLjEsIGNoYXJ0V2lkdGggPSA4MDAsIGNoYXJ0SGVpZ2h0ID0gNjAwKSB7XG4gIC8vIGQgaGFzIHNvdXJjZS90YXJnZXQ6IHt4MCwgeDEsIHkwLCB5MX1cbiAgbGV0IHgwID0gZC5zb3VyY2UueDE7XG4gIGxldCB4MSA9IGQudGFyZ2V0LngwO1xuICBsZXQgeTAgPSBkLnkwO1xuICBsZXQgeTEgPSBkLnkxO1xuICBcbiAgLy8gQ2xhbXAgY29vcmRpbmF0ZXMgdG8gY2hhcnQgYm91bmRzIHRvIHByZXZlbnQgb3ZlcmZsb3dcbiAgeDAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjaGFydFdpZHRoLCB4MCkpO1xuICB4MSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNoYXJ0V2lkdGgsIHgxKSk7XG4gIHkwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY2hhcnRIZWlnaHQsIHkwKSk7XG4gIHkxID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY2hhcnRIZWlnaHQsIHkxKSk7XG4gIFxuICBjb25zdCBtaWRYID0gKHgwICsgeDEpIC8gMjtcbiAgXG4gIC8vIEFkZCBhIHNpbmUgd2F2ZSB0byB0aGUgY29udHJvbCBwb2ludHMsIGJ1dCBlbnN1cmUgdGhleSBzdGF5IHdpdGhpbiBib3VuZHNcbiAgY29uc3Qgd2F2ZVkwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY2hhcnRIZWlnaHQsIHkwICsgd2F2ZUFtcGxpdHVkZSAqIE1hdGguc2luKHdhdmVGcmVxdWVuY3kgKiBNYXRoLlBJICogMC4yNSkpKTtcbiAgY29uc3Qgd2F2ZVkxID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY2hhcnRIZWlnaHQsIHkxICsgd2F2ZUFtcGxpdHVkZSAqIE1hdGguc2luKHdhdmVGcmVxdWVuY3kgKiBNYXRoLlBJICogMC43NSkpKTtcbiAgXG4gIHJldHVybiBgTSR7eDB9LCR7eTB9XG4gICAgQyR7bWlkWH0sJHt3YXZlWTB9ICR7bWlkWH0sJHt3YXZlWTF9ICR7eDF9LCR7eTF9YDtcbn1cblxuLy8gQ3VzdG9tIGhvcml6b250YWwgbGluayBnZW5lcmF0b3IgdGhhdCBjbGFtcHMgeTAveTEgdG8gbm9kZSBib3VuZHNcbmZ1bmN0aW9uIGNsYW1wZWRTYW5rZXlMaW5rSG9yaXpvbnRhbCgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQ6IGFueSkge1xuICAgIC8vIENsYW1wIHkwL3kxIHRvIG5vZGUgYm91bmRzXG4gICAgY29uc3Qgc3kgPSBNYXRoLm1heChkLnNvdXJjZS55MCwgTWF0aC5taW4oZC5zb3VyY2UueTEsIGQueTApKTtcbiAgICBjb25zdCB0eSA9IE1hdGgubWF4KGQudGFyZ2V0LnkwLCBNYXRoLm1pbihkLnRhcmdldC55MSwgZC55MSkpO1xuICAgIGNvbnN0IHgwID0gZC5zb3VyY2UueDE7XG4gICAgY29uc3QgeDEgPSBkLnRhcmdldC54MDtcbiAgICAvLyBVc2UgYSBjdWJpYyBCZXppZXIgZm9yIHNtb290aG5lc3NcbiAgICBjb25zdCBjdXJ2YXR1cmUgPSAwLjU7XG4gICAgY29uc3QgeGkgPSBkMy5pbnRlcnBvbGF0ZU51bWJlcih4MCwgeDEpO1xuICAgIGNvbnN0IHgyID0geGkoY3VydmF0dXJlKTtcbiAgICBjb25zdCB4MyA9IHhpKDEgLSBjdXJ2YXR1cmUpO1xuICAgIHJldHVybiBgTSR7eDB9LCR7c3l9QyR7eDJ9LCR7c3l9ICR7eDN9LCR7dHl9ICR7eDF9LCR7dHl9YDtcbiAgfTtcbn1cblxuLy8gTm90ZTogVXNpbmcgdGhlbWUtYXdhcmUgZ2V0Tm9kZUNvbG9yIGZ1bmN0aW9uIGZyb20gY29sb3JVdGlsc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBbGx1dmlhbERpYWdyYW0oe1xuICB3aWR0aCA9IDgwMCxcbiAgaGVpZ2h0ID0gNjAwLFxuICBhdXRvUGxheSA9IHRydWUsXG4gIG9uUXVlc3Rpb25DaGFuZ2UsXG59OiBBbGx1dmlhbERpYWdyYW1Qcm9wcykge1xuICAvLyBSZXNwb25zaXZlOiB1c2Ugc3RhdGUgZm9yIHdpZHRoL2hlaWdodCwgZmFsbGJhY2sgdG8gcHJvcHNcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgW2NvbnRhaW5lcldpZHRoLCBzZXRDb250YWluZXJXaWR0aF0gPSB1c2VTdGF0ZSh3aWR0aCk7XG4gIGNvbnN0IFtjb250YWluZXJIZWlnaHQsIHNldENvbnRhaW5lckhlaWdodF0gPSB1c2VTdGF0ZShoZWlnaHQpO1xuXG4gIC8vIFJlc3BvbnNpdmU6IG9ic2VydmUgY29udGFpbmVyIHNpemVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgd2luZG93LlJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBpZiAoZW50cnkuY29udGVudFJlY3QpIHtcbiAgICAgICAgICBzZXRDb250YWluZXJXaWR0aChlbnRyeS5jb250ZW50UmVjdC53aWR0aCk7XG4gICAgICAgICAgc2V0Q29udGFpbmVySGVpZ2h0KGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc3ZnUmVmID0gdXNlUmVmPFNWR1NWR0VsZW1lbnQ+KG51bGwpO1xuICBjb25zdCB7IGRhdGEsIGlzTG9hZGluZywgZXJyb3IgfSA9IHVzZVZpc3VhbGl6YXRpb25EYXRhKCk7XG4gIGNvbnN0IHsgc2V0dGluZ3MsIGdldEN1cnJlbnRUaGVtZUNvbG9ycyB9ID0gdXNlQXBwQ29udGV4dCgpO1xuICBjb25zdCBbY3VycmVudFNvdXJjZSwgc2V0Q3VycmVudFNvdXJjZV0gPSB1c2VTdGF0ZSgneWVhcnNfYXRfbWVkdHJvbmljJyk7XG4gIGNvbnN0IFtjdXJyZW50VGFyZ2V0LCBzZXRDdXJyZW50VGFyZ2V0XSA9IHVzZVN0YXRlKCdsZWFybmluZ19zdHlsZScpO1xuXG4gIC8vIEZpbHRlciBkYXRhIGJhc2VkIG9uIHRlc3QgZGF0YSBzZXR0aW5nXG4gIGNvbnN0IGZpbHRlcmVkRGF0YSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcbiAgICByZXR1cm4gc2V0dGluZ3MudXNlVGVzdERhdGEgPyBkYXRhIDogZGF0YS5maWx0ZXIoaXRlbSA9PiAhKGl0ZW0gYXMgYW55KS50ZXN0X2RhdGEpO1xuICB9LCBbZGF0YSwgc2V0dGluZ3MudXNlVGVzdERhdGFdKTtcblxuICAvLyBDb21wdXRlIHNvdXJjZXMgYW5kIHRhcmdldHMgd2l0aCB2YWxpZGF0aW9uXG4gIGNvbnN0IHNvdXJjZXM6IHN0cmluZ1tdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcmVkRGF0YSkgfHwgIWZpbHRlcmVkRGF0YS5sZW5ndGgpIHJldHVybiBbXTtcbiAgICBpZiAoY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycpIHtcbiAgICAgIHJldHVybiBZRUFSU19DQVRFR09SSUVTLmZpbHRlcihjYXQgPT4gXG4gICAgICAgIGZpbHRlcmVkRGF0YS5zb21lKGQgPT4gZ2V0VmFsaWRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApID09PSBjYXQpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KFxuICAgICAgICBmaWx0ZXJlZERhdGEubWFwKChkOiBTdXJ2ZXlSZXNwb25zZSkgPT4gZFtjdXJyZW50U291cmNlIGFzIGtleW9mIFN1cnZleVJlc3BvbnNlXSlcbiAgICAgICkpLmZpbHRlcigodmFsdWUpOiB2YWx1ZSBpcyBzdHJpbmcgPT4gXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID4gMFxuICAgICAgKTtcbiAgICB9XG4gIH0sIFtmaWx0ZXJlZERhdGEsIGN1cnJlbnRTb3VyY2VdKTtcblxuICBjb25zdCB0YXJnZXRzOiBzdHJpbmdbXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWx0ZXJlZERhdGEpIHx8ICFmaWx0ZXJlZERhdGEubGVuZ3RoKSByZXR1cm4gW107XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgICByZXR1cm4gWUVBUlNfQ0FURUdPUklFUy5maWx0ZXIoY2F0ID0+IFxuICAgICAgICBmaWx0ZXJlZERhdGEuc29tZShkID0+IGdldFZhbGlkWWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSA9PT0gY2F0KVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU29ydCB0YXJnZXQgbm9kZXMgY29uc2lzdGVudGx5IHRvIG1haW50YWluIGZpeGVkIHBvc2l0aW9uc1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChcbiAgICAgICAgZmlsdGVyZWREYXRhLm1hcCgoZDogU3VydmV5UmVzcG9uc2UpID0+IFxuICAgICAgICBjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJyBcbiAgICAgICAgICAgID8gZ2V0VmFsaWRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApXG4gICAgICAgICAgICA6IGRbY3VycmVudFRhcmdldCBhcyBrZXlvZiBTdXJ2ZXlSZXNwb25zZV1cbiAgICAgICAgKVxuICAgICAgKSkuZmlsdGVyKCh2YWx1ZSk6IHZhbHVlIGlzIHN0cmluZyA9PiBcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPiAwXG4gICAgICApLnNvcnQoKTsgLy8gQWRkIGNvbnNpc3RlbnQgc29ydGluZ1xuICAgIH1cbiAgfSwgW2ZpbHRlcmVkRGF0YSwgY3VycmVudFRhcmdldF0pO1xuXG4gIC8vIC0tLSBSZXNwb25zaXZlIGNoYXJ0IHNpemluZyBiYXNlZCBvbiBkYXRhIHNpemUgLS0tXG4gIC8vIFNldCBzZW5zaWJsZSBtaW4vbWF4IGNoYXJ0IGRpbWVuc2lvbnNcbiAgY29uc3QgTUlOX0NIQVJUX0hFSUdIVCA9IDE4MDtcbiAgY29uc3QgTUFYX0NIQVJUX0hFSUdIVCA9IDcwMDtcbiAgY29uc3QgTUlOX0NIQVJUX1dJRFRIID0gMzIwO1xuICBjb25zdCBNQVhfQ0hBUlRfV0lEVEggPSAxNDAwO1xuXG4gIC8vIENhbGN1bGF0ZSBub2RlIGNvdW50IGZvciBzaXppbmdcbiAgY29uc3Qgbm9kZUNvdW50ID0gTWF0aC5tYXgoc291cmNlcy5sZW5ndGgsIHRhcmdldHMubGVuZ3RoLCAxKTtcbiAgLy8gQ2FsY3VsYXRlIGF2YWlsYWJsZSBoZWlnaHQgZm9yIG5vZGVzIGFuZCBwYWRkaW5nc1xuICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoTUlOX0NIQVJUX0hFSUdIVCwgTWF0aC5taW4oY29udGFpbmVySGVpZ2h0IC0gNDAsIE1BWF9DSEFSVF9IRUlHSFQpKTtcbiAgLy8gRm9yIHZlcnkgc3BhcnNlIGRhdGEsIHNocmluayB0aGUgY2hhcnQgaGVpZ2h0XG4gIGlmIChub2RlQ291bnQgPD0gMykge1xuICAgIGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KE1JTl9DSEFSVF9IRUlHSFQsIE1hdGgubWluKDMyMCwgYXZhaWxhYmxlSGVpZ2h0KSk7XG4gIH1cbiAgLy8gRm9yIHZlcnkgZGVuc2UgZGF0YSwgYWxsb3cgbW9yZSBoZWlnaHRcbiAgaWYgKG5vZGVDb3VudCA+PSAxMCkge1xuICAgIGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWluKE1BWF9DSEFSVF9IRUlHSFQsIE1hdGgubWF4KGF2YWlsYWJsZUhlaWdodCwgNTAwKSk7XG4gIH1cblxuICAvLyBOb2RlIGhlaWdodCBhbmQgcGFkZGluZyBsb2dpY1xuICBjb25zdCBtaW5Ob2RlSGVpZ2h0ID0gMTY7XG4gIGNvbnN0IG1heE5vZGVIZWlnaHQgPSBub2RlQ291bnQgPD0gMyA/IDM2IDogNDg7IC8vIFNtYWxsZXIgbWF4IGZvciBzcGFyc2UgZGF0YVxuICBjb25zdCBtaW5QYWRkaW5nID0gODtcbiAgbGV0IG5vZGVIZWlnaHQgPSBNYXRoLmZsb29yKChhdmFpbGFibGVIZWlnaHQgLSAobm9kZUNvdW50ICsgMSkgKiBtaW5QYWRkaW5nKSAvIG5vZGVDb3VudCk7XG4gIG5vZGVIZWlnaHQgPSBNYXRoLm1heChtaW5Ob2RlSGVpZ2h0LCBNYXRoLm1pbihub2RlSGVpZ2h0LCBtYXhOb2RlSGVpZ2h0KSk7XG4gIGxldCBub2RlUGFkZGluZyA9IChhdmFpbGFibGVIZWlnaHQgLSBub2RlQ291bnQgKiBub2RlSGVpZ2h0KSAvIChub2RlQ291bnQgKyAxKTtcbiAgbm9kZVBhZGRpbmcgPSBNYXRoLm1heChub2RlUGFkZGluZywgbWluUGFkZGluZyk7XG5cbiAgLy8gRHluYW1pY2FsbHkgc2NhbGUgbGFiZWwgZm9udCBzaXplIHdpdGggbm9kZSBoZWlnaHQgKGNsYW1wIGJldHdlZW4gMTJweCBhbmQgMjhweClcbiAgY29uc3QgbGFiZWxGb250U2l6ZSA9IE1hdGgubWF4KDEyLCBNYXRoLm1pbigyOCwgTWF0aC5mbG9vcihub2RlSGVpZ2h0ICogMC41KSkpO1xuXG4gIC8vIC0tLSBEeW5hbWljIG1hcmdpbiBjYWxjdWxhdGlvbiBmb3IgZnVsbCBsYWJlbCB2aXNpYmlsaXR5IC0tLVxuICAvLyBIZWxwZXIgdG8gbWVhc3VyZSB0ZXh0IHdpZHRoIGluIHB4XG4gIGZ1bmN0aW9uIG1lYXN1cmVUZXh0V2lkdGgodGV4dDogc3RyaW5nLCBmb250OiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIDEwMDsgLy8gZmFsbGJhY2sgZm9yIFNTUlxuICAgIGlmICghKG1lYXN1cmVUZXh0V2lkdGggYXMgYW55KS5fY2FudmFzKSB7XG4gICAgICAobWVhc3VyZVRleHRXaWR0aCBhcyBhbnkpLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzID0gKG1lYXN1cmVUZXh0V2lkdGggYXMgYW55KS5fY2FudmFzIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoIWNvbnRleHQpIHJldHVybiAxMDA7XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICByZXR1cm4gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgfVxuXG4gIC8vIEZvbnQgZm9yIG1lYXN1cmluZ1xuICBjb25zdCBsYWJlbEZvbnQgPSBgYm9sZCAke2xhYmVsRm9udFNpemV9cHggQXZlbmlyIE5leHQgV29ybGQsIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NGIFBybycsICdSb2JvdG8nLCBzYW5zLXNlcmlmYDtcbiAgY29uc3QgYWxsTGFiZWxzID0gWy4uLnNvdXJjZXMsIC4uLnRhcmdldHNdO1xuICBjb25zdCBsYWJlbFdpZHRocyA9IGFsbExhYmVscy5tYXAobGFiZWwgPT4gbWVhc3VyZVRleHRXaWR0aChsYWJlbCwgbGFiZWxGb250KSk7XG4gIGNvbnN0IG1heExhYmVsV2lkdGggPSBNYXRoLm1heCguLi5sYWJlbFdpZHRocywgODApOyAvLyBmYWxsYmFjayBtaW5cbiAgY29uc3QgbGFiZWxQYWRkaW5nID0gMjQ7XG4gIGNvbnN0IG1hcmdpbiA9IHsgdG9wOiAyMCwgcmlnaHQ6IG1heExhYmVsV2lkdGggKyBsYWJlbFBhZGRpbmcsIGJvdHRvbTogMjAsIGxlZnQ6IG1heExhYmVsV2lkdGggKyBsYWJlbFBhZGRpbmcgfTtcblxuICAvLyBSZXNwb25zaXZlIGNoYXJ0IHdpZHRoXG4gIGxldCBjaGFydFdpZHRoID0gTWF0aC5tYXgoTUlOX0NIQVJUX1dJRFRILCBNYXRoLm1pbihjb250YWluZXJXaWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LCBNQVhfQ0hBUlRfV0lEVEgpKTtcbiAgbGV0IGNoYXJ0SGVpZ2h0ID0gYXZhaWxhYmxlSGVpZ2h0O1xuXG4gIC8vIElmIHZlcnkgc3BhcnNlLCBzaHJpbmsgd2lkdGggdG9vXG4gIGlmIChub2RlQ291bnQgPD0gMykge1xuICAgIGNoYXJ0V2lkdGggPSBNYXRoLm1heChNSU5fQ0hBUlRfV0lEVEgsIE1hdGgubWluKGNoYXJ0V2lkdGgsIDQ4MCkpO1xuICB9XG5cbiAgLy8gSWYgdmVyeSBkZW5zZSwgYWxsb3cgbW9yZSB3aWR0aFxuICBpZiAobm9kZUNvdW50ID49IDEwKSB7XG4gICAgY2hhcnRXaWR0aCA9IE1hdGgubWluKE1BWF9DSEFSVF9XSURUSCwgTWF0aC5tYXgoY2hhcnRXaWR0aCwgOTAwKSk7XG4gIH1cblxuICAvLyBEZWJ1ZyBsb2dnaW5nXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1tBbGx1dmlhbERpYWdyYW0gRGVidWddJyk7XG4gICAgY29uc29sZS5sb2coJyAgQ29udGFpbmVyOicsIGNvbnRhaW5lcldpZHRoLCAneCcsIGNvbnRhaW5lckhlaWdodCk7XG4gICAgY29uc29sZS5sb2coJyAgQ2hhcnQ6JywgY2hhcnRXaWR0aCwgJ3gnLCBjaGFydEhlaWdodCk7XG4gICAgY29uc29sZS5sb2coJyAgTm9kZSBjb3VudCAoc291cmNlcy90YXJnZXRzKTonLCBzb3VyY2VzLmxlbmd0aCwgdGFyZ2V0cy5sZW5ndGgpO1xuICAgIGNvbnNvbGUubG9nKCcgIG5vZGVIZWlnaHQ6Jywgbm9kZUhlaWdodCk7XG4gICAgY29uc29sZS5sb2coJyAgbm9kZVBhZGRpbmc6Jywgbm9kZVBhZGRpbmcpO1xuICAgIGNvbnNvbGUubG9nKCcgIGxhYmVsRm9udFNpemU6JywgbGFiZWxGb250U2l6ZSk7XG4gIH0sIFtjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0LCBjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgc291cmNlcy5sZW5ndGgsIHRhcmdldHMubGVuZ3RoLCBub2RlSGVpZ2h0LCBub2RlUGFkZGluZywgbGFiZWxGb250U2l6ZV0pO1xuXG4gIC8vIFVzZSByZWZzIHRvIHRyYWNrIGN1cnJlbnQgdmFsdWVzIHdpdGhvdXQgdHJpZ2dlcmluZyByZS1yZW5kZXJzXG4gIGNvbnN0IGN1cnJlbnRTb3VyY2VSZWYgPSB1c2VSZWYoY3VycmVudFNvdXJjZSk7XG4gIGNvbnN0IGN1cnJlbnRUYXJnZXRSZWYgPSB1c2VSZWYoY3VycmVudFRhcmdldCk7XG4gIFxuICAvLyBVcGRhdGUgcmVmcyB3aGVuIHN0YXRlIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjdXJyZW50U291cmNlUmVmLmN1cnJlbnQgPSBjdXJyZW50U291cmNlO1xuICB9LCBbY3VycmVudFNvdXJjZV0pO1xuICBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjdXJyZW50VGFyZ2V0UmVmLmN1cnJlbnQgPSBjdXJyZW50VGFyZ2V0O1xuICB9LCBbY3VycmVudFRhcmdldF0pO1xuICBjb25zdCBbaW5zaWdodHMsIHNldEluc2lnaHRzXSA9IHVzZVN0YXRlPEFycmF5PHsgdGl0bGU6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB8IG51bWJlcjsgZGVzY3JpcHRpb24/OiBzdHJpbmcgfT4+KFtdKTtcbiAgY29uc3QgW2hvdmVyZWROb2RlLCBzZXRIb3ZlcmVkTm9kZV0gPSB1c2VTdGF0ZTxTYW5rZXlOb2RlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtob3ZlcmVkTGluaywgc2V0SG92ZXJlZExpbmtdID0gdXNlU3RhdGU8U2Fua2V5TGluayB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbdG9vbHRpcCwgc2V0VG9vbHRpcF0gPSB1c2VTdGF0ZTxUb29sdGlwU3RhdGUgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xhc3RDYXRlZ29yeUNoYW5nZSwgc2V0TGFzdENhdGVnb3J5Q2hhbmdlXSA9IHVzZVN0YXRlPHsgc291cmNlOiBzdHJpbmc7IHRhcmdldDogc3RyaW5nIH0+KHsgc291cmNlOiBjdXJyZW50U291cmNlLCB0YXJnZXQ6IGN1cnJlbnRUYXJnZXQgfSk7XG4gIGNvbnN0IFtjdXJyZW50VGFyZ2V0SW5kZXgsIHNldEN1cnJlbnRUYXJnZXRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuICBjb25zdCBbaXNBbmltYXRpbmcsIHNldElzQW5pbWF0aW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbaG92ZXJlZFNvdXJjZUluZGV4LCBzZXRIb3ZlcmVkU291cmNlSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtob3ZlcmVkVGFyZ2V0SW5kZXgsIHNldEhvdmVyZWRUYXJnZXRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzSW5GdWxsT3BhY2l0eVN0YXRlLCBzZXRJc0luRnVsbE9wYWNpdHlTdGF0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFthbmltYXRpb25QaGFzZSwgc2V0QW5pbWF0aW9uUGhhc2VdID0gdXNlU3RhdGU8J2Z1bGwnIHwgJ2hpZ2hsaWdodGluZycgfCAndHJhbnNpdGlvbmluZyc+KCdmdWxsJyk7XG5cbiAgY29uc3QgYW5pbWF0aW9uUmVmID0gdXNlUmVmPEFuaW1hdGlvblN0YXRlPih7XG4gICAgdGltZXI6IG51bGwsXG4gICAgcnVubmluZzogZmFsc2UsXG4gICAgY3VycmVudFNvdXJjZUluZGV4OiAwLFxuICAgIGN1cnJlbnRUYXJnZXRJbmRleDogMCxcbiAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgcGF1c2VkQXQ6IERhdGUubm93KCksXG4gICAgcmVzdW1lRnJvbTogbnVsbCxcbiAgICBjeWNsZUNvdW50OiAwXG4gIH0pO1xuXG4gIC8vIENoZWNrIGZvciByZWR1Y2VkIG1vdGlvbiBwcmVmZXJlbmNlXG4gIGNvbnN0IHByZWZlcnNSZWR1Y2VkTW90aW9uID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKScpLm1hdGNoZXM7XG4gIH0sIFtdKTtcblxuICAvLyBBZGp1c3QgYW5pbWF0aW9uIGR1cmF0aW9ucyBiYXNlZCBvbiBtb3Rpb24gcHJlZmVyZW5jZVxuICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBiYXNlU3BlZWQgPSBzZXR0aW5ncy5hdXRvUGxheVNwZWVkIHx8IDMwMDA7XG4gICAgY29uc3QgcmVkdWN0aW9uRmFjdG9yID0gcHJlZmVyc1JlZHVjZWRNb3Rpb24gPyAwLjUgOiAxO1xuICAgIHJldHVybiB7XG4gICAgICBzdGVwRHVyYXRpb246IE1hdGgubWF4KDgwMCwgKGJhc2VTcGVlZCAvIDgpICogcmVkdWN0aW9uRmFjdG9yKSxcbiAgICAgIHBhdXNlRHVyYXRpb246IE1hdGgubWF4KDQwMCwgKGJhc2VTcGVlZCAvIDEyKSAqIHJlZHVjdGlvbkZhY3RvciksXG4gICAgICBjYXRlZ29yeVBhdXNlRHVyYXRpb246IE1hdGgubWF4KDE1MDAsIChiYXNlU3BlZWQgLyAzKSAqIHJlZHVjdGlvbkZhY3RvciksXG4gICAgICBsaW5rVHJhbnNpdGlvbkR1cmF0aW9uOiBwcmVmZXJzUmVkdWNlZE1vdGlvbiA/IDQwMCA6IDc1MFxuICAgIH07XG4gIH0sIFtzZXR0aW5ncy5hdXRvUGxheVNwZWVkLCBwcmVmZXJzUmVkdWNlZE1vdGlvbl0pO1xuXG4gIC8vIEdldCB2aXN1YWwgb3JkZXIgb2Ygc291cmNlIG5vZGVzICh0b3AtdG8tYm90dG9tIGFzIHRoZXkgYXBwZWFyKVxuICBjb25zdCBzb3J0ZWRTb3VyY2VzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFmaWx0ZXJlZERhdGEubGVuZ3RoIHx8ICFjaGFydFdpZHRoIHx8ICFjaGFydEhlaWdodCkgcmV0dXJuIHNvdXJjZXM7XG5cbiAgICBjb25zdCBzb3VyY2VzRm9yTm9kZXMgPSBbLi4uc291cmNlc107XG4gICAgaWYgKGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgICBzb3VyY2VzRm9yTm9kZXMuc29ydCgoYSwgYikgPT4gWUVBUlNfQ0FURUdPUklFUy5pbmRleE9mKGEpIC0gWUVBUlNfQ0FURUdPUklFUy5pbmRleE9mKGIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlc0Zvck5vZGVzLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgU2Fua2V5IGxheW91dCB0byBnZXQgdmlzdWFsIG9yZGVyXG4gICAgY29uc3Qgbm9kZXMgPSBbXG4gICAgICAuLi5zb3VyY2VzRm9yTm9kZXMubWFwKChuYW1lKSA9PiAoeyBpZDogYCR7Y3VycmVudFNvdXJjZX06JHtuYW1lfWAsIG5hbWUsIGNhdGVnb3J5OiBjdXJyZW50U291cmNlIH0pKSxcbiAgICAgIC4uLnRhcmdldHMubWFwKChuYW1lKSA9PiAoeyBpZDogYCR7Y3VycmVudFRhcmdldH06JHtuYW1lfWAsIG5hbWUsIGNhdGVnb3J5OiBjdXJyZW50VGFyZ2V0IH0pKSxcbiAgICBdO1xuXG4gICAgY29uc3QgbGlua3NNYXAgPSBuZXcgTWFwPHN0cmluZywgeyBzb3VyY2U6IHN0cmluZzsgdGFyZ2V0OiBzdHJpbmc7IHZhbHVlOiBudW1iZXIgfT4oKTsgXG4gICAgZmlsdGVyZWREYXRhLmZvckVhY2goKGQpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnIFxuICAgICAgICA/IGdldFZhbGlkWWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSBcbiAgICAgICAgOiAoZCBhcyBhbnkpW2N1cnJlbnRTb3VyY2VdO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY3VycmVudFRhcmdldCA9PT0gJ3llYXJzX2F0X21lZHRyb25pYydcbiAgICAgICAgPyBnZXRWYWxpZFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMClcbiAgICAgICAgOiAoZCBhcyBhbnkpW2N1cnJlbnRUYXJnZXRdO1xuICAgICAgXG4gICAgICBpZiAoIXNvdXJjZXNGb3JOb2Rlcy5pbmNsdWRlcyhzb3VyY2UpIHx8ICF0YXJnZXRzLmluY2x1ZGVzKHRhcmdldCkpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3Qgc291cmNlSWQgPSBgJHtjdXJyZW50U291cmNlfToke3NvdXJjZX1gO1xuICAgICAgY29uc3QgdGFyZ2V0SWQgPSBgJHtjdXJyZW50VGFyZ2V0fToke3RhcmdldH1gO1xuICAgICAgY29uc3Qga2V5ID0gYCR7c291cmNlSWR94oaSJHt0YXJnZXRJZH1gO1xuICAgICAgXG4gICAgICBpZiAoIWxpbmtzTWFwLmhhcyhrZXkpKSB7XG4gICAgICAgIGxpbmtzTWFwLnNldChrZXksIHsgc291cmNlOiBzb3VyY2VJZCwgdGFyZ2V0OiB0YXJnZXRJZCwgdmFsdWU6IDAgfSk7XG4gICAgICB9XG4gICAgICBsaW5rc01hcC5nZXQoa2V5KSEudmFsdWUgKz0gMTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGxpbmtzID0gQXJyYXkuZnJvbShsaW5rc01hcC52YWx1ZXMoKSk7XG4gICAgY29uc3Qgc2Fua2V5R2VuZXJhdG9yID0gc2Fua2V5PGFueSwgYW55PigpXG4gICAgICAubm9kZUlkKChkOiBhbnkpID0+IGQuaWQpXG4gICAgICAubm9kZVdpZHRoKDEyKVxuICAgICAgLm5vZGVQYWRkaW5nKG5vZGVQYWRkaW5nKVxuICAgICAgLmV4dGVudChbWzAsIDBdLCBbY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHRdXSk7XG5cbiAgICBjb25zdCBzYW5rZXlEYXRhID0gc2Fua2V5R2VuZXJhdG9yKHtcbiAgICAgIG5vZGVzOiBub2Rlcy5tYXAoKGQpID0+ICh7IC4uLmQgfSkpLFxuICAgICAgbGlua3M6IGxpbmtzLm1hcCgoZCkgPT4gKHsgLi4uZCB9KSksXG4gICAgfSk7XG5cbiAgICAvLyBHZXQgc291cmNlIG5vZGVzIGluIHZpc3VhbCBvcmRlciAodG9wIHRvIGJvdHRvbSlcbiAgICBjb25zdCBzb3VyY2VOb2RlcyA9IHNhbmtleURhdGEubm9kZXNcbiAgICAgIC5maWx0ZXIoKGQ6IGFueSkgPT4gZC5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSlcbiAgICAgIC5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gYS55MCAtIGIueTApO1xuXG4gICAgcmV0dXJuIHNvdXJjZU5vZGVzLm1hcCgoZDogYW55KSA9PiBkLm5hbWUpO1xuICB9LCBbZmlsdGVyZWREYXRhLCBzb3VyY2VzLCB0YXJnZXRzLCBjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0LCBjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgbm9kZVBhZGRpbmddKTtcblxuICAvLyBFbmhhbmNlZCBhbmltYXRpb24gZnVuY3Rpb24gd2l0aCBjb21wcmVoZW5zaXZlIGRlYnVnIHRyYWNraW5nXG4gIGNvbnN0IGFuaW1hdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgYW5pbWF0aW9uIGlzIHBhdXNlZFxuICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KPuO+4jyAgQW5pbWF0aW9uIGlzIHBhdXNlZCwgc2tpcHBpbmcgY3ljbGUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgfHwgIWZpbHRlcmVkRGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgQW5pbWF0aW9uIHN0b3BwZWQ6Jywge1xuICAgICAgICBydW5uaW5nOiBhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nLFxuICAgICAgICBkYXRhTGVuZ3RoOiBmaWx0ZXJlZERhdGEubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTYWZldHkgY2hlY2s6IHByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3ljbGVDb3VudCA+IDEwMDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5uRIEFuaW1hdGlvbiBjeWNsZSBsaW1pdCByZWFjaGVkLCByZXNldHRpbmcnKTtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN5Y2xlQ291bnQgPSAwO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4ID0gMDtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLy8gSW5jcmVtZW50IGN5Y2xlIGNvdW50ZXJcbiAgICBhbmltYXRpb25SZWYuY3VycmVudC5jeWNsZUNvdW50Kys7XG5cbiAgICAvLyBTZXQgYW5pbWF0aW9uIHBoYXNlIHRvIGhpZ2hsaWdodGluZ1xuICAgIHNldEFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgICAgc2V0SXNJbkZ1bGxPcGFjaXR5U3RhdGUoZmFsc2UpO1xuICAgIFxuICAgIC8vIFNldCB0aGUgaG92ZXJlZCBzb3VyY2UgaW5kZXggdG8gbWF0Y2ggdGhlIGFuaW1hdGlvblxuICAgIHNldEhvdmVyZWRTb3VyY2VJbmRleChhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXgpO1xuXG4gICAgY29uc3QgdGFyZ2V0T3B0aW9ucyA9IGF2YWlsYWJsZUZpZWxkc1xuICAgICAgLmZpbHRlcihmID0+IGYudmFsdWUgIT09IGN1cnJlbnRTb3VyY2VSZWYuY3VycmVudClcbiAgICAgIC5tYXAoZiA9PiBmLnZhbHVlKTtcbiAgICBcbiAgICAvLyBEZWJ1ZzogTG9nIHRoZSB0YXJnZXQgb3B0aW9ucyB0byB2ZXJpZnkgdGhleSdyZSBjb3JyZWN0XG4gICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfjq8gQXZhaWxhYmxlIHRhcmdldCBvcHRpb25zIGZvcicsIGN1cnJlbnRTb3VyY2VSZWYuY3VycmVudCwgJzonLCB0YXJnZXRPcHRpb25zKTtcbiAgICB9XG5cbiAgICAgICAgICAvLyBDT01QUkVIRU5TSVZFIERFQlVHOiBMb2cgY3VycmVudCBzdGF0ZSB3aXRoIGZ1bGwgZGV0YWlsXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBBTklNQVRJT04gQ1lDTEUgREVCVUc6Jywge1xuICAgICAgICAn8J+TjSBDdXJyZW50IFBvc2l0aW9uJzoge1xuICAgICAgICAgIHNvdXJjZUluZGV4OiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXgsXG4gICAgICAgICAgdGFyZ2V0SW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCxcbiAgICAgICAgICBzb3VyY2VOYW1lOiBzb3J0ZWRTb3VyY2VzW2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleF0sXG4gICAgICAgICAgdGFyZ2V0TmFtZTogY3VycmVudFRhcmdldFJlZi5jdXJyZW50XG4gICAgICAgIH0sXG4gICAgICAgICfwn5OKIENhdGVnb3JpZXMnOiB7XG4gICAgICAgICAgY3VycmVudFNvdXJjZTogY3VycmVudFNvdXJjZVJlZi5jdXJyZW50LFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXRSZWYuY3VycmVudCxcbiAgICAgICAgICBzb3VyY2VPcHRpb25zOiBhdmFpbGFibGVGaWVsZHMubWFwKGYgPT4gZi52YWx1ZSksXG4gICAgICAgICAgdGFyZ2V0T3B0aW9uc1xuICAgICAgICB9LFxuICAgICAgJ/Cfk4ggUHJvZ3Jlc3MnOiB7XG4gICAgICAgIHNvdXJjZVByb2dyZXNzOiBgJHthbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXggKyAxfS8ke3NvcnRlZFNvdXJjZXMubGVuZ3RofWAsXG4gICAgICAgIHRhcmdldFByb2dyZXNzOiBgJHthbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXggKyAxfS8ke3RhcmdldE9wdGlvbnMubGVuZ3RofWAsXG4gICAgICAgIGlzTGFzdFNvdXJjZTogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4ID49IHNvcnRlZFNvdXJjZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgaGFzTW9yZVRhcmdldHM6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCA8IHRhcmdldE9wdGlvbnMubGVuZ3RoIC0gMVxuICAgICAgfSxcbiAgICAgICfwn46vIFNvdXJjZXMnOiBzb3J0ZWRTb3VyY2VzLFxuICAgICAgJ/Cfjq8gVGFyZ2V0cyc6IHRhcmdldE9wdGlvbnMsXG4gICAgICAn4o+x77iPICBUaW1pbmdzJzogYW5pbWF0aW9uRHVyYXRpb25zXG4gICAgfSk7XG5cbiAgICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4IDwgc29ydGVkU291cmNlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIE1vdmUgdG8gbmV4dCBzb3VyY2VcbiAgICAgICAgY29uc3QgbmV4dFRpbWVvdXQgPSBhbmltYXRpb25EdXJhdGlvbnMuc3RlcER1cmF0aW9uICsgYW5pbWF0aW9uRHVyYXRpb25zLnBhdXNlRHVyYXRpb247XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gYCR7YW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4ICsgMX0vJHtzb3J0ZWRTb3VyY2VzLmxlbmd0aH1gO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+OryBTb3VyY2UgJHtwcm9ncmVzc306IEhpZ2hsaWdodGluZyAnJHtzb3J0ZWRTb3VyY2VzW2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleF19JyDihpIgJyR7Y3VycmVudFRhcmdldFJlZi5jdXJyZW50fScgZm9yICR7bmV4dFRpbWVvdXR9bXNgKTtcbiAgICAgIFxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nIHx8IGFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSByZXR1cm47XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCsrO1xuICAgICAgICBhbmltYXRlKCk7XG4gICAgICB9LCBuZXh0VGltZW91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gQWZ0ZXIgbGFzdCBzb3VyY2UsIGNoZWNrIGlmIHdlIG5lZWQgdG8gY3ljbGUgdGFyZ2V0cyBvciBjaGFuZ2Ugc291cmNlIGNhdGVnb3J5XG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBFTkQgT0YgU09VUkNFUyAtIENoZWNraW5nIHRhcmdldCBjeWNsaW5nOicsIHtcbiAgICAgICAgY3VycmVudFRhcmdldEluZGV4OiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXgsXG4gICAgICAgIHRhcmdldE9wdGlvbnNMZW5ndGg6IHRhcmdldE9wdGlvbnMubGVuZ3RoLFxuICAgICAgICBoYXNNb3JlVGFyZ2V0czogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4IDwgdGFyZ2V0T3B0aW9ucy5sZW5ndGggLSAxLFxuICAgICAgICBhdmFpbGFibGVUYXJnZXRzOiB0YXJnZXRPcHRpb25zXG4gICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4IDwgdGFyZ2V0T3B0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gU3RpbGwgaGF2ZSBtb3JlIHRhcmdldCBjYXRlZ29yaWVzIHRvIGN5Y2xlIHRocm91Z2hcbiAgICAgICAgICBjb25zdCB0YXJnZXRQcm9ncmVzcyA9IGAke2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCArIDJ9LyR7dGFyZ2V0T3B0aW9ucy5sZW5ndGh9YDtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCDinIUgQ09NUExFVEVEIEFMTCBTT1VSQ0VTIGZvciAnJHtjdXJyZW50VGFyZ2V0UmVmLmN1cnJlbnR9JywgbW92aW5nIHRvIG5leHQgdGFyZ2V0ICgke3RhcmdldFByb2dyZXNzfSlgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZXIgdG8gcHJldmVudCBjb25mbGljdHNcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgfHwgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHJldHVybjtcbiAgICAgICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCd0cmFuc2l0aW9uaW5nJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1vdmUgdG8gbmV4dCB0YXJnZXQgY2F0ZWdvcnlcbiAgICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCsrO1xuICAgICAgICAgICAgY29uc3QgbmV4dFRhcmdldCA9IHRhcmdldE9wdGlvbnNbYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4XTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46vIOKcqCBORVcgVEFSR0VUIENBVEVHT1JZOicsIG5leHRUYXJnZXQsIGAoJHthbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXggKyAxfS8ke3RhcmdldE9wdGlvbnMubGVuZ3RofSlgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFRhcmdldCBwcm9ncmVzc2lvbiBkZWJ1ZzonLCB7XG4gICAgICAgICAgICAgIHByZXZpb3VzVGFyZ2V0OiBjdXJyZW50VGFyZ2V0UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgIG5leHRUYXJnZXQsXG4gICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXRJbmRleDogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4LFxuICAgICAgICAgICAgICBhbGxUYXJnZXRPcHRpb25zOiB0YXJnZXRPcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUYXJnZXQobmV4dFRhcmdldCk7XG4gICAgICAgICAgICBzZXRMYXN0Q2F0ZWdvcnlDaGFuZ2UoeyBzb3VyY2U6IGN1cnJlbnRTb3VyY2VSZWYuY3VycmVudCwgdGFyZ2V0OiBuZXh0VGFyZ2V0IH0pO1xuICAgICAgICAgICAgb25RdWVzdGlvbkNoYW5nZT8uKGN1cnJlbnRTb3VyY2VSZWYuY3VycmVudCwgbmV4dFRhcmdldCk7XG4gICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXNldCBzb3VyY2UgaW5kZXggYW5kIHJlc3RhcnQgd2l0aCBuZXcgdGFyZ2V0XG4gICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXggPSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCBjeWNsZSBhZnRlciBhIGJyaWVmIHBhdXNlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhbmltYXRpb25EdXJhdGlvbnMuY2F0ZWdvcnlQYXVzZUR1cmF0aW9uKTtcbiAgICAgICAgICB9LCBhbmltYXRpb25EdXJhdGlvbnMuY2F0ZWdvcnlQYXVzZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjeWNsZWQgdGhyb3VnaCBhbGwgdGFyZ2V0cywgbm93IGNoYW5nZSB0aGUgc291cmNlIGNhdGVnb3J5XG4gICAgICAgICAgY29uc29sZS5sb2coYPCflIQg4pyoIENPTVBMRVRFRCBBTEwgVEFSR0VUUyBmb3IgJyR7Y3VycmVudFNvdXJjZVJlZi5jdXJyZW50fScgLSBNb3ZpbmcgdG8gbmV4dCBzb3VyY2UgY2F0ZWdvcnkhIOKcqGApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lciB0byBwcmV2ZW50IGNvbmZsaWN0c1xuICAgICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKTtcbiAgICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyB8fCBhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ3RyYW5zaXRpb25pbmcnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTW92ZSB0byBuZXh0IHNvdXJjZSBjYXRlZ29yeVxuICAgICAgICAgICAgY29uc3Qgc291cmNlT3B0aW9ucyA9IGF2YWlsYWJsZUZpZWxkcy5tYXAoZiA9PiBmLnZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTb3VyY2VJbmRleCA9IHNvdXJjZU9wdGlvbnMuaW5kZXhPZihjdXJyZW50U291cmNlUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgY29uc3QgbmV4dFNvdXJjZUluZGV4ID0gKGN1cnJlbnRTb3VyY2VJbmRleCArIDEpICUgc291cmNlT3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBuZXh0U291cmNlID0gc291cmNlT3B0aW9uc1tuZXh0U291cmNlSW5kZXhdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+OryDwn4aVIE5FVyBTT1VSQ0UgQ0FURUdPUlk6JywgbmV4dFNvdXJjZSwgJy0gU3RhcnRpbmcgZnJlc2ggY3ljbGUgd2l0aCBhbGwgdGFyZ2V0cycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGFyZ2V0IG9wdGlvbnMgZm9yIHRoZSBORVcgc291cmNlIChpbmNsdWRpbmcgeWVhcnNfYXRfbWVkdHJvbmljKVxuICAgICAgICAgICAgY29uc3QgbmV3VGFyZ2V0T3B0aW9ucyA9IGF2YWlsYWJsZUZpZWxkc1xuICAgICAgICAgICAgICAuZmlsdGVyKGYgPT4gZi52YWx1ZSAhPT0gbmV4dFNvdXJjZSlcbiAgICAgICAgICAgICAgLm1hcChmID0+IGYudmFsdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBOZXcgdGFyZ2V0IG9wdGlvbnMgZm9yJywgbmV4dFNvdXJjZSwgJzonLCBuZXdUYXJnZXRPcHRpb25zKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2V0Q3VycmVudFNvdXJjZShuZXh0U291cmNlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVzZXQgYm90aCBpbmRpY2VzIGFuZCBzdGFydCB3aXRoIGZpcnN0IHRhcmdldCBhZ2FpblxuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4ID0gMDtcbiAgICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCA9IDA7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFRhcmdldCA9IG5ld1RhcmdldE9wdGlvbnNbMF07XG4gICAgICAgICAgICBzZXRDdXJyZW50VGFyZ2V0KGZpcnN0VGFyZ2V0KTtcbiAgICAgICAgICAgIHNldExhc3RDYXRlZ29yeUNoYW5nZSh7IHNvdXJjZTogbmV4dFNvdXJjZSwgdGFyZ2V0OiBmaXJzdFRhcmdldCB9KTtcbiAgICAgICAgICAgIG9uUXVlc3Rpb25DaGFuZ2U/LihuZXh0U291cmNlLCBmaXJzdFRhcmdldCk7XG4gICAgICAgICAgXG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCBjeWNsZSBhZnRlciBhIGxvbmdlciBwYXVzZVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nICYmICFhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgYW5pbWF0aW9uRHVyYXRpb25zLmNhdGVnb3J5UGF1c2VEdXJhdGlvbiAqIDEuNSk7IC8vIExvbmdlciBwYXVzZSBmb3Igc291cmNlIGNhdGVnb3J5IGNoYW5nZVxuICAgICAgICAgIH0sIGFuaW1hdGlvbkR1cmF0aW9ucy5jYXRlZ29yeVBhdXNlRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW1xuICAgIGRhdGEubGVuZ3RoLFxuICAgIHNvcnRlZFNvdXJjZXMubGVuZ3RoLFxuICAgIG9uUXVlc3Rpb25DaGFuZ2UsXG4gICAgYW5pbWF0aW9uRHVyYXRpb25zLFxuICAgIGF2YWlsYWJsZUZpZWxkc1xuICAgIC8vIFJlbW92ZWQgc29ydGVkU291cmNlcyB0byBwcmV2ZW50IGRlcGVuZGVuY3kgbG9vcHNcbiAgXSk7XG5cblxuXG4gIC8vIEFuaW1hdGlvbiBlZmZlY3QgLSByZXN0YXJ0IHdoZW4gc2V0dGluZ3MgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ/CfjqwgQW5pbWF0aW9uIHVzZUVmZmVjdCB0cmlnZ2VyZWQ6Jywge1xuICAgICAgYXV0b1BsYXksXG4gICAgICBpc0F1dG9QbGF5RW5hYmxlZDogc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQsXG4gICAgICBkYXRhTGVuZ3RoOiBkYXRhLmxlbmd0aCxcbiAgICAgIHN2Z1JlZkV4aXN0czogISFzdmdSZWYuY3VycmVudCxcbiAgICAgIGN1cnJlbnRTb3VyY2UsXG4gICAgICBjdXJyZW50VGFyZ2V0LFxuICAgICAgYXV0b1BsYXlTcGVlZDogc2V0dGluZ3MuYXV0b1BsYXlTcGVlZCxcbiAgICAgIGlzUnVubmluZzogYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZ1xuICAgIH0pO1xuXG4gICAgaWYgKCFhdXRvUGxheSB8fCAhc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgQW5pbWF0aW9uIGRpc2FibGVkJyk7XG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKTtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyA9IGZhbHNlO1xuICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgIHNldElzSW5GdWxsT3BhY2l0eVN0YXRlKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIWZpbHRlcmVkRGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgTm8gZGF0YSBhdmFpbGFibGUgZm9yIGFuaW1hdGlvbicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXN2Z1JlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIFNWRyByZWYgbm90IGF2YWlsYWJsZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlc3RhcnQgYW5pbWF0aW9uIHdoZW4gc3BlZWQgY2hhbmdlcyBvciBvbiBtYWpvciBjaGFuZ2VzXG4gICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFJlc3RhcnRpbmcgYW5pbWF0aW9uIHdpdGggbmV3IHNldHRpbmdzOicsIHtcbiAgICAgICAgc291cmNlQ2F0ZWdvcnk6IGN1cnJlbnRTb3VyY2UsXG4gICAgICAgIHRvdGFsU291cmNlczogc29ydGVkU291cmNlcy5sZW5ndGgsXG4gICAgICAgIHRvdGFsVGFyZ2V0czogYXZhaWxhYmxlRmllbGRzLmZpbHRlcihmID0+IGYudmFsdWUgIT09IGN1cnJlbnRTb3VyY2UpLmxlbmd0aCxcbiAgICAgICAgc3BlZWQ6IHNldHRpbmdzLmF1dG9QbGF5U3BlZWQgKyAnbXMnXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU3RvcCBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTdGFydCBuZXcgYW5pbWF0aW9uIGN5Y2xlXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFN0YXJ0aW5nIGFuaW1hdGlvbiBjeWNsZTonLCB7XG4gICAgICAgIHNvdXJjZUNhdGVnb3J5OiBjdXJyZW50U291cmNlLFxuICAgICAgICB0b3RhbFNvdXJjZXM6IHNvcnRlZFNvdXJjZXMubGVuZ3RoLFxuICAgICAgICB0b3RhbFRhcmdldHM6IGF2YWlsYWJsZUZpZWxkcy5maWx0ZXIoZiA9PiBmLnZhbHVlICE9PSBjdXJyZW50U291cmNlKS5sZW5ndGgsXG4gICAgICAgIHNwZWVkOiBzZXR0aW5ncy5hdXRvUGxheVNwZWVkICsgJ21zJ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgYW5pbWF0aW9uIHN0YXRlXG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCA9IDA7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXggPSAwO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3ljbGVDb3VudCA9IDA7IC8vIFJlc2V0IGN5Y2xlIGNvdW50ZXJcblxuICAgICAgLy8gU3RhcnQgYW5pbWF0aW9uXG4gICAgICBhbmltYXRlKCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICBzZXRJc0luRnVsbE9wYWNpdHlTdGF0ZSh0cnVlKTtcbiAgICB9O1xuICB9LCBbXG4gICAgYXV0b1BsYXksXG4gICAgc2V0dGluZ3MuaXNBdXRvUGxheUVuYWJsZWQsXG4gICAgc2V0dGluZ3MuYXV0b1BsYXlTcGVlZCwgLy8gQWRkIHRoaXMgdG8gcmVzdGFydCB3aGVuIHNwZWVkIGNoYW5nZXNcbiAgICBmaWx0ZXJlZERhdGEubGVuZ3RoLFxuICAgIGN1cnJlbnRTb3VyY2UgLy8gT25seSByZXN0YXJ0IG9uIHNvdXJjZSBjaGFuZ2VzLCBub3QgdGFyZ2V0IGNoYW5nZXNcbiAgXSk7XG5cbiAgY29uc3Qgbm9kZUxhYmVsRm9udFNpemUgPSAxODsgLy8gbGFyZ2VyIGZvciByZWFkYWJpbGl0eVxuICBjb25zdCBub2RlTGFiZWxGb250V2VpZ2h0ID0gNzAwO1xuICBjb25zdCBub2RlTGFiZWxDb2xvciA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAnI0ZGRkZGRicgOiAnIzE3MEY1Ric7XG4gIGNvbnN0IG5vZGVMYWJlbEZvbnRGYW1pbHkgPSAnQXZlbmlyIE5leHQgV29ybGQsIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTRiBQcm9cIiwgXCJSb2JvdG9cIiwgc2Fucy1zZXJpZic7XG4gIGNvbnN0IG5vZGVMYWJlbE9mZnNldCA9IDI0O1xuXG4gIC8vIExvY2FsIGRlYnVnIHRvZ2dsZSBmb3IgdGhpcyBjb21wb25lbnQgaWYgbm8gZ2xvYmFsIGFkbWluIGNvbnRleHRcbiAgY29uc3QgW2xvY2FsRGVidWcsIHNldExvY2FsRGVidWddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1RoZW1lVG9nZ2xlLCBzZXRTaG93VGhlbWVUb2dnbGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBkZWJ1Z09uID0gbG9jYWxEZWJ1ZztcblxuICAvLyBEZWJ1ZyBTYW5rZXkgZGF0YSBmb3Igb3V0bGluZXNcbiAgY29uc3QgW2RlYnVnU2Fua2V5RGF0YSwgc2V0RGVidWdTYW5rZXlEYXRhXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZXMpIHx8ICFBcnJheS5pc0FycmF5KHRhcmdldHMpKSByZXR1cm47XG4gICAgY29uc3Qgbm9kZXMgPSBbXG4gICAgICAuLi5zb3VyY2VzLm1hcCgobmFtZSkgPT4gKHsgaWQ6IGBzb3VyY2U6JHtuYW1lfWAsIG5hbWUsIGNhdGVnb3J5OiAnc291cmNlJyB9KSksXG4gICAgICAuLi50YXJnZXRzLm1hcCgobmFtZSkgPT4gKHsgaWQ6IGB0YXJnZXQ6JHtuYW1lfWAsIG5hbWUsIGNhdGVnb3J5OiAndGFyZ2V0JyB9KSksXG4gICAgXTtcbiAgICAvLyBPbmx5IGNyZWF0ZSBsaW5rcyBpZiBib3RoIHNpZGVzIGhhdmUgYXQgbGVhc3Qgb25lIG5vZGVcbiAgICBjb25zdCBsaW5rcyA9IChzb3VyY2VzLmxlbmd0aCAmJiB0YXJnZXRzLmxlbmd0aClcbiAgICAgID8gW3sgc291cmNlOiBgc291cmNlOiR7c291cmNlc1swXX1gLCB0YXJnZXQ6IGB0YXJnZXQ6JHt0YXJnZXRzWzBdfWAsIHZhbHVlOiAxIH1dXG4gICAgICA6IFtdO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPCAyIHx8IGxpbmtzLmxlbmd0aCA8IDEpIHJldHVybjsgLy8gUHJldmVudCBpbnZhbGlkIGFycmF5IGxlbmd0aFxuICAgIGNvbnN0IHNhbmtleUdlbmVyYXRvciA9IHNhbmtleTxhbnksIGFueT4oKVxuICAgICAgLm5vZGVJZCgoZDogYW55KSA9PiBkLmlkKVxuICAgICAgLm5vZGVXaWR0aCgxMilcbiAgICAgIC5ub2RlUGFkZGluZyhub2RlUGFkZGluZylcbiAgICAgIC5leHRlbnQoW1swLCAwXSwgW2NoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0XV0pO1xuICAgIGNvbnN0IHNhbmtleURhdGEgPSBzYW5rZXlHZW5lcmF0b3IoeyBub2Rlczogbm9kZXMubWFwKChkKSA9PiAoeyAuLi5kIH0pKSwgbGlua3M6IGxpbmtzLm1hcCgoZCkgPT4gKHsgLi4uZCB9KSkgfSk7XG4gICAgc2V0RGVidWdTYW5rZXlEYXRhKHNhbmtleURhdGEpO1xuICB9LCBbc291cmNlcywgdGFyZ2V0cywgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQsIG5vZGVQYWRkaW5nXSk7XG5cbiAgLy8gUmVuZGVyIFNhbmtleSBkaWFncmFtXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzdmdSZWYuY3VycmVudCB8fCAhZmlsdGVyZWREYXRhLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgLy8gLS0tIFBlcnNpc3RlbnQgU1ZHIHN0cnVjdHVyZSAtLS1cbiAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3Q8U1ZHU1ZHRWxlbWVudCwgdW5rbm93bj4oc3ZnUmVmLmN1cnJlbnQpO1xuICAgIHN2Zy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTsgLy8gQ2xlYXIgcHJldmlvdXMgY29udGVudFxuICAgIHN2Z1xuICAgICAgLmF0dHIoJ3dpZHRoJywgY29udGFpbmVyV2lkdGgpXG4gICAgICAuYXR0cignaGVpZ2h0JywgY29udGFpbmVySGVpZ2h0KTtcblxuICAgIC8vIC0tLSBTYW5rZXkgbm9kZS9saW5rIGNyZWF0aW9uIGFuZCB2ZXJ0aWNhbCBjZW50ZXJpbmcgKGRlZHVwbGljYXRlZCkgLS0tXG4gICAgLy8gU29ydCBzb3VyY2Ugbm9kZXMgdG8gbWFpbnRhaW4gYSBmaXhlZCBvcmRlciAoc2FtZSBhcyBhbmltYXRpb24pXG4gICAgY29uc3Qgc29ydGVkU291cmNlcyA9IFsuLi5zb3VyY2VzXTtcbiAgICBpZiAoY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycpIHtcbiAgICAgIHNvcnRlZFNvdXJjZXMuc29ydCgoYSwgYikgPT4gWUVBUlNfQ0FURUdPUklFUy5pbmRleE9mKGEpIC0gWUVBUlNfQ0FURUdPUklFUy5pbmRleE9mKGIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ydGVkU291cmNlcy5zb3J0KCk7XG4gICAgfVxuICAgIC8vIFNvcnQgdGFyZ2V0IG5vZGVzIHRvIG1haW50YWluIGEgZml4ZWQgb3JkZXJcbiAgICBjb25zdCBzb3J0ZWRUYXJnZXRzID0gWy4uLnRhcmdldHNdO1xuICAgIGlmIChjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgICAgc29ydGVkVGFyZ2V0cy5zb3J0KChhLCBiKSA9PiBZRUFSU19DQVRFR09SSUVTLmluZGV4T2YoYSkgLSBZRUFSU19DQVRFR09SSUVTLmluZGV4T2YoYikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3J0ZWRUYXJnZXRzLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvLyBTYW5rZXkgdHJhbnNmb3JtYXRpb24gYWNjZXNzb3JzXG4gICAgY29uc3Qgc291cmNlQWNjZXNzb3IgPSAoZDogYW55KSA9PlxuICAgICAgY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYydcbiAgICAgICAgPyBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApXG4gICAgICAgIDogKGQgYXMgYW55KVtjdXJyZW50U291cmNlXTtcbiAgICBjb25zdCB0YXJnZXRBY2Nlc3NvciA9IChkOiBhbnkpID0+XG4gICAgICBjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJ1xuICAgICAgICA/IGdldFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMClcbiAgICAgICAgOiAoZCBhcyBhbnkpW2N1cnJlbnRUYXJnZXRdO1xuXG4gICAgLy8gRmlsdGVyIGRhdGEgdG8gb25seSBpbmNsdWRlIHZhbGlkIHZhbHVlc1xuICAgIGNvbnN0IHZhbGlkRGF0YSA9IGZpbHRlcmVkRGF0YS5maWx0ZXIoZCA9PlxuICAgICAgKGN1cnJlbnRTb3VyY2UgIT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnIHx8IGQueWVhcnNfYXRfbWVkdHJvbmljICE9PSBudWxsKSAmJlxuICAgICAgKGN1cnJlbnRUYXJnZXQgIT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnIHx8IGQueWVhcnNfYXRfbWVkdHJvbmljICE9PSBudWxsKVxuICAgICk7XG5cbiAgICAvLyBCdWlsZCBub2RlcyBhcnJheSB3aXRoIHVuaXF1ZSBpZHNcbiAgICBjb25zdCBub2RlcyA9IFtcbiAgICAgIC4uLnNvcnRlZFNvdXJjZXMubWFwKChuYW1lKSA9PiAoeyBpZDogYCR7Y3VycmVudFNvdXJjZX06JHtuYW1lfWAsIG5hbWUsIGNhdGVnb3J5OiBjdXJyZW50U291cmNlIH0pKSxcbiAgICAgIC4uLnNvcnRlZFRhcmdldHMubWFwKChuYW1lKSA9PiAoeyBpZDogYCR7Y3VycmVudFRhcmdldH06JHtuYW1lfWAsIG5hbWUsIGNhdGVnb3J5OiBjdXJyZW50VGFyZ2V0IH0pKSxcbiAgICBdO1xuXG4gICAgLy8gQnVpbGQgbGlua3MgYXJyYXkgKGFnZ3JlZ2F0ZSBjb3VudHMgZm9yIGVhY2ggc291cmNlLXRhcmdldCBwYWlyKVxuICAgIGNvbnN0IGxpbmtzTWFwID0gbmV3IE1hcDxzdHJpbmcsIHsgc291cmNlOiBzdHJpbmc7IHRhcmdldDogc3RyaW5nOyB2YWx1ZTogbnVtYmVyLCBpc0R1bW15PzogYm9vbGVhbiB9PigpO1xuICAgIC8vIDEuIEZvciBldmVyeSBwb3NzaWJsZSBzb3VyY2UtdGFyZ2V0IHBhaXIsIGNyZWF0ZSBhIGxpbmsgKGR1bW15IGlmIG5vIGRhdGEpXG4gICAgc29ydGVkU291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgIHNvcnRlZFRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUlkID0gYCR7Y3VycmVudFNvdXJjZX06JHtzb3VyY2V9YDtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBgJHtjdXJyZW50VGFyZ2V0fToke3RhcmdldH1gO1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtzb3VyY2VJZH3ihpIke3RhcmdldElkfWA7XG4gICAgICAgIGxpbmtzTWFwLnNldChrZXksIHsgc291cmNlOiBzb3VyY2VJZCwgdGFyZ2V0OiB0YXJnZXRJZCwgdmFsdWU6IDAsIGlzRHVtbXk6IHRydWUgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyAyLiBGaWxsIGluIHJlYWwgZGF0YSwgbWFya2luZyBsaW5rcyBhcyBub3QgZHVtbXlcbiAgICB2YWxpZERhdGEuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgY29uc3Qgc291cmNlID0gc291cmNlQWNjZXNzb3IoZCk7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRBY2Nlc3NvcihkKTtcbiAgICAgIGlmICghc29ydGVkU291cmNlcy5pbmNsdWRlcyhzb3VyY2UpIHx8ICFzb3J0ZWRUYXJnZXRzLmluY2x1ZGVzKHRhcmdldCkpIHJldHVybjtcbiAgICAgIGNvbnN0IHNvdXJjZUlkID0gYCR7Y3VycmVudFNvdXJjZX06JHtzb3VyY2V9YDtcbiAgICAgIGNvbnN0IHRhcmdldElkID0gYCR7Y3VycmVudFRhcmdldH06JHt0YXJnZXR9YDtcbiAgICAgIGNvbnN0IGtleSA9IGAke3NvdXJjZUlkfeKGkiR7dGFyZ2V0SWR9YDtcbiAgICAgIGlmICghbGlua3NNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgbGlua3NNYXAuc2V0KGtleSwgeyBzb3VyY2U6IHNvdXJjZUlkLCB0YXJnZXQ6IHRhcmdldElkLCB2YWx1ZTogMSwgaXNEdW1teTogZmFsc2UgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaW5rID0gbGlua3NNYXAuZ2V0KGtleSkhO1xuICAgICAgICBsaW5rLnZhbHVlICs9IDE7XG4gICAgICAgIGxpbmsuaXNEdW1teSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIDMuIFNldCBkdW1teSBsaW5rcyB0byBhIHZlcnkgc21hbGwgdmFsdWUgaWYgc3RpbGwgZHVtbXlcbiAgICBBcnJheS5mcm9tKGxpbmtzTWFwLnZhbHVlcygpKS5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgaWYgKGxpbmsuaXNEdW1teSkgbGluay52YWx1ZSA9IDAuMDAwMTtcbiAgICB9KTtcblxuICAgIC8vIC0tLSBDT0xVTU4gSEVJR0hUIE5PUk1BTElaQVRJT04gLS0tXG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHZhbHVlIGZvciBlYWNoIHNpZGVcbiAgICBjb25zdCBsZWZ0VG90YWxzID0gc29ydGVkU291cmNlcy5tYXAoc291cmNlID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZUlkID0gYCR7Y3VycmVudFNvdXJjZX06JHtzb3VyY2V9YDtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGxpbmtzTWFwLnZhbHVlcygpKS5maWx0ZXIobCA9PiBsLnNvdXJjZSA9PT0gc291cmNlSWQpLnJlZHVjZSgoc3VtLCBsKSA9PiBzdW0gKyBsLnZhbHVlLCAwKTtcbiAgICB9KTtcbiAgICBjb25zdCByaWdodFRvdGFscyA9IHNvcnRlZFRhcmdldHMubWFwKHRhcmdldCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRJZCA9IGAke2N1cnJlbnRUYXJnZXR9OiR7dGFyZ2V0fWA7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShsaW5rc01hcC52YWx1ZXMoKSkuZmlsdGVyKGwgPT4gbC50YXJnZXQgPT09IHRhcmdldElkKS5yZWR1Y2UoKHN1bSwgbCkgPT4gc3VtICsgbC52YWx1ZSwgMCk7XG4gICAgfSk7XG4gICAgY29uc3QgbGVmdFN1bSA9IGxlZnRUb3RhbHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgY29uc3QgcmlnaHRTdW0gPSByaWdodFRvdGFscy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICAvLyBJZiBzdW1zIGFyZSBkaWZmZXJlbnQsIHNjYWxlIHRoZSBzbWFsbGVyIHNpZGUncyBub2RlIHZhbHVlcyBhbmQgbGluayB2YWx1ZXNcbiAgICBsZXQgbGVmdFNjYWxlID0gMSwgcmlnaHRTY2FsZSA9IDE7XG4gICAgaWYgKGxlZnRTdW0gPiAwICYmIHJpZ2h0U3VtID4gMCAmJiBsZWZ0U3VtICE9PSByaWdodFN1bSkge1xuICAgICAgaWYgKGxlZnRTdW0gPiByaWdodFN1bSkge1xuICAgICAgICByaWdodFNjYWxlID0gbGVmdFN1bSAvIHJpZ2h0U3VtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdFNjYWxlID0gcmlnaHRTdW0gLyBsZWZ0U3VtO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTY2FsZSBsaW5rc1xuICAgIEFycmF5LmZyb20obGlua3NNYXAudmFsdWVzKCkpLmZvckVhY2gobGluayA9PiB7XG4gICAgICBjb25zdCBzb3VyY2VJZCA9IGxpbmsuc291cmNlO1xuICAgICAgY29uc3QgdGFyZ2V0SWQgPSBsaW5rLnRhcmdldDtcbiAgICAgIGlmIChsZWZ0U2NhbGUgIT09IDEgJiYgc29ydGVkU291cmNlcy5zb21lKHMgPT4gYCR7Y3VycmVudFNvdXJjZX06JHtzfWAgPT09IHNvdXJjZUlkKSkge1xuICAgICAgICBsaW5rLnZhbHVlICo9IGxlZnRTY2FsZTtcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodFNjYWxlICE9PSAxICYmIHNvcnRlZFRhcmdldHMuc29tZSh0ID0+IGAke2N1cnJlbnRUYXJnZXR9OiR7dH1gID09PSB0YXJnZXRJZCkpIHtcbiAgICAgICAgbGluay52YWx1ZSAqPSByaWdodFNjYWxlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgbGlua3MgPSBBcnJheS5mcm9tKGxpbmtzTWFwLnZhbHVlcygpKTtcblxuICAgIC8vIC0tLSBEWU5BTUlDIE5PREUgUEFERElORyAtLS1cbiAgICAvLyBSZWR1Y2Ugbm9kZVBhZGRpbmcgZm9yIHNwYXJzZSBkYXRhXG4gICAgbGV0IGR5bmFtaWNOb2RlUGFkZGluZyA9IG5vZGVQYWRkaW5nO1xuICAgIGlmIChzb3J0ZWRTb3VyY2VzLmxlbmd0aCA8PSA0ICYmIHNvcnRlZFRhcmdldHMubGVuZ3RoIDw9IDQpIHtcbiAgICAgIGR5bmFtaWNOb2RlUGFkZGluZyA9IE1hdGgubWF4KDgsIG5vZGVQYWRkaW5nIC8gMik7XG4gICAgfVxuXG4gICAgLy8gU2Fua2V5IGxheW91dFxuICAgIGNvbnN0IHNhbmtleUdlbmVyYXRvciA9IHNhbmtleTxhbnksIGFueT4oKVxuICAgICAgLm5vZGVJZCgoZDogYW55KSA9PiBkLmlkKVxuICAgICAgLm5vZGVXaWR0aCgxMilcbiAgICAgIC5ub2RlUGFkZGluZyhkeW5hbWljTm9kZVBhZGRpbmcpXG4gICAgICAuZXh0ZW50KFtbMCwgMF0sIFtjaGFydFdpZHRoLCBjaGFydEhlaWdodF1dKTtcblxuICAgIGNvbnN0IHNhbmtleURhdGEgPSBzYW5rZXlHZW5lcmF0b3Ioe1xuICAgICAgbm9kZXM6IG5vZGVzLm1hcCgoZCkgPT4gKHsgLi4uZCB9KSksXG4gICAgICBsaW5rczogbGlua3MubWFwKChkKSA9PiAoeyAuLi5kIH0pKSxcbiAgICB9KTtcblxuICAgIC8vIC0tLSBGT1JDRSBST1cgQUxJR05NRU5UIElGIE5PREUgU0VUUyBNQVRDSCAtLS1cbiAgICAvLyBJZiBsZWZ0IGFuZCByaWdodCBub2RlIHNldHMgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYW5kIG9yZGVyLCBhbGlnbiB0aGVpciB5MC95MVxuICAgIGNvbnN0IGxlZnROb2RlcyA9IHNhbmtleURhdGEubm9kZXMuZmlsdGVyKChuOiBhbnkpID0+IG4uY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpO1xuICAgIGNvbnN0IHJpZ2h0Tm9kZXMgPSBzYW5rZXlEYXRhLm5vZGVzLmZpbHRlcigobjogYW55KSA9PiBuLmNhdGVnb3J5ID09PSBjdXJyZW50VGFyZ2V0KTtcbiAgICBpZiAoXG4gICAgICBsZWZ0Tm9kZXMubGVuZ3RoID09PSByaWdodE5vZGVzLmxlbmd0aCAmJlxuICAgICAgbGVmdE5vZGVzLmV2ZXJ5KChuLCBpKSA9PiByaWdodE5vZGVzW2ldICYmIG4ubmFtZSA9PT0gcmlnaHROb2Rlc1tpXS5uYW1lKVxuICAgICkge1xuICAgICAgLy8gRm9yY2UgeTAveTEgb2YgcmlnaHQgbm9kZXMgdG8gbWF0Y2ggbGVmdCBub2Rlc1xuICAgICAgcmlnaHROb2Rlcy5mb3JFYWNoKChuLCBpKSA9PiB7XG4gICAgICAgIG4ueTAgPSBsZWZ0Tm9kZXNbaV0ueTA7XG4gICAgICAgIG4ueTEgPSBsZWZ0Tm9kZXNbaV0ueTE7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAtLS0gVklTVUFMIEdVSURFUzogUmVuZGVyIGhvcml6b250YWwgYmFuZHMgZm9yIGVhY2ggcm93IC0tLVxuICAgIHN2Zy5zZWxlY3RBbGwoJ3JlY3Qucm93LWd1aWRlJylcbiAgICAgIC5kYXRhKGxlZnROb2RlcylcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdyb3ctZ3VpZGUnKVxuICAgICAgLmF0dHIoJ3gnLCAtbWFyZ2luLmxlZnQpXG4gICAgICAuYXR0cigneScsIChkOiBhbnkpID0+IGQueTApXG4gICAgICAuYXR0cignd2lkdGgnLCBjaGFydFdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpXG4gICAgICAuYXR0cignaGVpZ2h0JywgKGQ6IGFueSkgPT4gZC55MSAtIGQueTApXG4gICAgICAuYXR0cignZmlsbCcsIChkLCBpKSA9PiBpICUgMiA9PT0gMCA/ICcjZjVmN2ZhJyA6ICcjZTllZWY1JylcbiAgICAgIC5hdHRyKCdvcGFjaXR5JywgMC4yNSlcbiAgICAgIC5sb3dlcigpO1xuXG4gICAgLy8gQ29tcHV0ZSB2ZXJ0aWNhbCBvZmZzZXQgdG8gY2VudGVyIHRoZSBkaWFncmFtXG4gICAgY29uc3Qgbm9kZVlzID0gc2Fua2V5RGF0YS5ub2Rlcy5tYXAoKGQ6IGFueSkgPT4gW2QueTAsIGQueTFdKS5mbGF0KCk7XG4gICAgY29uc3QgbWluWSA9IE1hdGgubWluKC4uLm5vZGVZcyk7XG4gICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KC4uLm5vZGVZcyk7XG4gICAgY29uc3QgdXNlZEhlaWdodCA9IG1heFkgLSBtaW5ZO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLm1heCgwLCAoY2hhcnRIZWlnaHQgLSB1c2VkSGVpZ2h0KSAvIDIgLSBtaW5ZKTtcblxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgY2hhcnQgYXJlYSB3aXRoIG1hcmdpbiB0cmFuc2xhdGlvbiBhbmQgdmVydGljYWwgY2VudGVyaW5nXG4gICAgY29uc3QgZyA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCR7bWFyZ2luLnRvcCArIG9mZnNldFl9KWApO1xuXG4gICAgbGV0IGRlZnMgPSBzdmcuc2VsZWN0PFNWR0RlZnNFbGVtZW50PignZGVmcycpO1xuICAgIGlmIChkZWZzLmVtcHR5KCkpIGRlZnMgPSBzdmcuYXBwZW5kKCdkZWZzJykgYXMgZDMuU2VsZWN0aW9uPFNWR0RlZnNFbGVtZW50LCB1bmtub3duLCBudWxsLCB1bmRlZmluZWQ+O1xuICAgIGxldCBsaW5rc0cgPSBnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2xpbmtzJyk7XG4gICAgbGV0IG5vZGVzRyA9IGcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbm9kZXMnKTtcblxuICAgIC8vIFJlbW92ZSBvbGQgZ3JhZGllbnRzIChubyBsb25nZXIgbmVlZGVkKVxuICAgIGRlZnMuc2VsZWN0QWxsKCdsaW5lYXJHcmFkaWVudC5saW5rLWdyYWRpZW50JykucmVtb3ZlKCk7XG5cbiAgICAvLyAtLS0gQWRkIGNsaXBQYXRoIGZvciBsaW5rcyBncm91cCB3aXRoIHRpZ2h0ZXIgYm91bmRzIC0tLVxuICAgIHN2Zy5zZWxlY3QoJ2RlZnMnKS5zZWxlY3RBbGwoJyNsaW5rLWNsaXAnKS5yZW1vdmUoKTtcbiAgICBkZWZzLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgLmF0dHIoJ2lkJywgJ2xpbmstY2xpcCcpXG4gICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQpXG4gICAgICAuYXR0cigneScsIG1hcmdpbi50b3ApXG4gICAgICAuYXR0cignd2lkdGgnLCBjaGFydFdpZHRoKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIGNoYXJ0SGVpZ2h0KTtcbiAgICBsaW5rc0cuYXR0cignY2xpcC1wYXRoJywgJ3VybCgjbGluay1jbGlwKScpO1xuXG4gICAgLy8gQWRkIGdsb3cgZmlsdGVyIGZvciBkYXJrIG1vZGVcbiAgICBkZWZzLnNlbGVjdEFsbCgnI2RhcmstbW9kZS1nbG93JykucmVtb3ZlKCk7XG4gICAgaWYgKHNldHRpbmdzLmlzRGFya01vZGUpIHtcbiAgICAgIGNvbnN0IGdsb3dGaWx0ZXIgPSBkZWZzLmFwcGVuZCgnZmlsdGVyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2RhcmstbW9kZS1nbG93JylcbiAgICAgICAgLmF0dHIoJ3gnLCAnLTUwJScpXG4gICAgICAgIC5hdHRyKCd5JywgJy01MCUnKVxuICAgICAgICAuYXR0cignd2lkdGgnLCAnMjAwJScpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnMjAwJScpO1xuICAgICAgXG4gICAgICBnbG93RmlsdGVyLmFwcGVuZCgnZmVHYXVzc2lhbkJsdXInKVxuICAgICAgICAuYXR0cignc3RkRGV2aWF0aW9uJywgJzEuNScpXG4gICAgICAgIC5hdHRyKCdyZXN1bHQnLCAnY29sb3JlZEJsdXInKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmVNZXJnZSA9IGdsb3dGaWx0ZXIuYXBwZW5kKCdmZU1lcmdlJyk7XG4gICAgICBmZU1lcmdlLmFwcGVuZCgnZmVNZXJnZU5vZGUnKS5hdHRyKCdpbicsICdjb2xvcmVkQmx1cicpO1xuICAgICAgZmVNZXJnZS5hcHBlbmQoJ2ZlTWVyZ2VOb2RlJykuYXR0cignaW4nLCAnU291cmNlR3JhcGhpYycpO1xuICAgIH1cblxuICAgIC8vIC0tLSBMaW5rcyB1cGRhdGUgcGF0dGVybiAtLS1cbiAgICAvLyBBbGwgbGlua3MgYXJlIG5vdyBiZXR3ZWVuIHJlYWwgbm9kZXMsIHdpdGggaXNEdW1teSBwcm9wZXJ0eSBmb3IgdmlzdWFsIGRpc3RpbmN0aW9uXG4gICAgY29uc3QgZmlsdGVyZWRMaW5rcyA9IHNhbmtleURhdGEubGlua3M7XG4gICAgLy8gUmVtb3ZlIG1peC1ibGVuZC1tb2RlIGluIGRhcmsgbW9kZSB0byBwcmV2ZW50IGNvbG9yIHdhc2hpbmcgb3V0XG4gICAgbGlua3NHLnN0eWxlKCdtaXgtYmxlbmQtbW9kZScsIHNldHRpbmdzLmlzRGFya01vZGUgPyAnbm9ybWFsJyA6ICdtdWx0aXBseScpO1xuICAgIGNvbnN0IGxpbmtLZXkgPSAoZDogYW55KSA9PiBgJHtkLnNvdXJjZS5pZH3ihpIke2QudGFyZ2V0LmlkfWA7XG4gICAgY29uc3QgbGlua1NlbCA9IGxpbmtzRy5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgLmRhdGEoZmlsdGVyZWRMaW5rcywgbGlua0tleSk7XG5cbiAgICAvLyBFWElUOiBmYWRlIG91dCBhbmQgcmVtb3ZlIGFsbCBvbGQgbGlua3NcbiAgICBsaW5rU2VsLmV4aXQoKVxuICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbig0MDApXG4gICAgICAuYXR0cignb3BhY2l0eScsIDApXG4gICAgICAucmVtb3ZlKCk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgY2F0ZWdvcnkgY2hhbmdlIHRoYXQgc2hvdWxkIHRyaWdnZXIgYW5pbWF0aW9uXG4gICAgY29uc3QgaXNDYXRlZ29yeUNoYW5nZSA9IGxhc3RDYXRlZ29yeUNoYW5nZS5zb3VyY2UgIT09IGN1cnJlbnRTb3VyY2UgfHwgbGFzdENhdGVnb3J5Q2hhbmdlLnRhcmdldCAhPT0gY3VycmVudFRhcmdldDtcblxuICAgIC8vIEVOVEVSOiBkcmF3IGluIGFsbCBuZXcgbGlua3Mgd2l0aCBpbXByb3ZlZCBhbmltYXRpb25cbiAgICBjb25zdCBuZXdMaW5rcyA9IGxpbmtzRy5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgLmRhdGEoZmlsdGVyZWRMaW5rcywgbGlua0tleSlcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdwYXRoJylcbiAgICAgIC5hdHRyKCdkJywgY2xhbXBlZFNhbmtleUxpbmtIb3Jpem9udGFsKCkpXG4gICAgICAuYXR0cignc3Ryb2tlJywgKGQ6IGFueSkgPT4gZ2V0Tm9kZUNvbG9yKGQuc291cmNlLCBnZXRDdXJyZW50VGhlbWVDb2xvcnMoKSwgc2V0dGluZ3MuaXNEYXJrTW9kZSkpXG4gICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgKGQ6IGFueSkgPT4gTWF0aC5tYXgoc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDIgOiAxLCBkLndpZHRoKSlcbiAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxuICAgICAgLmF0dHIoJ2ZpbHRlcicsIChkOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGhvdmVyZWRMaW5rID09PSBkKSByZXR1cm4gJ3VybCgjZ2xvdyknO1xuICAgICAgICByZXR1cm4gc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICd1cmwoI2RhcmstbW9kZS1nbG93KScgOiBudWxsO1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdwb2ludGVyLWV2ZW50cycsICdhbGwnKVxuICAgICAgLmF0dHIoJ3N0cm9rZS1saW5lY2FwJywgJ3JvdW5kJylcbiAgICAgIC5hdHRyKCdvcGFjaXR5JywgKGQ6IGFueSkgPT4ge1xuICAgICAgICAvLyBEdW1teSBsaW5rczogdmVyeSBsb3cgb3BhY2l0eVxuICAgICAgICBpZiAoZC5pc0R1bW15KSByZXR1cm4gMC4wODtcbiAgICAgICAgLy8gQWRqdXN0IG9wYWNpdHkgYmFzZWQgb24gZGFyayBtb2RlIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICBjb25zdCBiYXNlT3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjg1IDogMC40O1xuICAgICAgICBjb25zdCBoaWdobGlnaHRPcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDEuMCA6IDAuOTtcbiAgICAgICAgY29uc3QgZGltT3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjQgOiAwLjE7XG4gICAgICAgIC8vIERlZmF1bHQgb3BhY2l0eSB3aGVuIG5vIGhpZ2hsaWdodGluZ1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgIT09ICdoaWdobGlnaHRpbmcnKSByZXR1cm4gYmFzZU9wYWNpdHk7XG4gICAgICAgIC8vIEhpZ2hsaWdodCBsaW5rcyBmcm9tIHRoZSBhY3RpdmUgc291cmNlXG4gICAgICAgIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBob3ZlcmVkU291cmNlID0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdO1xuICAgICAgICAgIHJldHVybiBkLnNvdXJjZS5uYW1lID09PSBob3ZlcmVkU291cmNlID8gaGlnaGxpZ2h0T3BhY2l0eSA6IGRpbU9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGlnaGxpZ2h0IGxpbmtzIHRvIHRoZSBhY3RpdmUgdGFyZ2V0XG4gICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0SW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBob3ZlcmVkVGFyZ2V0ID0gc29ydGVkVGFyZ2V0c1tob3ZlcmVkVGFyZ2V0SW5kZXhdO1xuICAgICAgICAgIHJldHVybiBkLnRhcmdldC5uYW1lID09PSBob3ZlcmVkVGFyZ2V0ID8gaGlnaGxpZ2h0T3BhY2l0eSA6IGRpbU9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VPcGFjaXR5O1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgKGQ6IGFueSkgPT4gZC5pc0R1bW15ID8gJzQsNCcgOiBudWxsKTsgLy8gRGFzaGVkIGZvciBkdW1teSBsaW5rc1xuXG4gICAgLy8gQXBwbHkgZHJhd2luZyBhbmltYXRpb24gb25seSBvbiBjYXRlZ29yeSBjaGFuZ2VzIHRvIHByZXZlbnQgZmxpY2tlcmluZ1xuICAgIGlmIChpc0NhdGVnb3J5Q2hhbmdlKSB7XG4gICAgICBuZXdMaW5rcy5lYWNoKGZ1bmN0aW9uIChkOiBhbnkpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgY29uc3QgdG90YWxMZW5ndGggPSAodGhpcyBhcyBTVkdQYXRoRWxlbWVudCkuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggaW52aXNpYmxlIHBhdGhcbiAgICAgICAgcGF0aFxuICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgdG90YWxMZW5ndGgpXG4gICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNob2Zmc2V0JywgdG90YWxMZW5ndGgpXG4gICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAwKVxuICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuZGVsYXkoKGQ6IGFueSwgaTogbnVtYmVyKSA9PiBpICogMjUpIC8vIFJlZHVjZWQgc3RhZ2dlciBkZWxheVxuICAgICAgICAgIC5kdXJhdGlvbig2MDApIC8vIFJlZHVjZWQgZnJvbSAxMjAwbXMgdG8gNjAwbXNcbiAgICAgICAgICAuZWFzZShkMy5lYXNlQ3ViaWNJbk91dClcbiAgICAgICAgICAuYXR0cignb3BhY2l0eScsIChkOiBhbnkpID0+IHtcbiAgICAgICAgICAgIC8vIEFkanVzdCBvcGFjaXR5IGJhc2VkIG9uIGRhcmsgbW9kZSBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgICAgIGNvbnN0IGJhc2VPcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuODUgOiAwLjQ7XG4gICAgICAgICAgICBjb25zdCBoaWdobGlnaHRPcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDEuMCA6IDAuOTtcbiAgICAgICAgICAgIGNvbnN0IGRpbU9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMC40IDogMC4xO1xuXG4gICAgICAgICAgICAvLyBIaWdobGlnaHQgbGlua3MgZnJvbSB0aGUgYWN0aXZlIHNvdXJjZSBvciB0byB0aGUgYWN0aXZlIHRhcmdldFxuICAgICAgICAgICAgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICAgICAgY29uc3QgaG92ZXJlZFNvdXJjZSA9IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XTtcbiAgICAgICAgICAgICAgcmV0dXJuIGQuc291cmNlLm5hbWUgPT09IGhvdmVyZWRTb3VyY2UgPyBoaWdobGlnaHRPcGFjaXR5IDogZGltT3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0SW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRUYXJnZXQgPSBzb3J0ZWRUYXJnZXRzW2hvdmVyZWRUYXJnZXRJbmRleF07XG4gICAgICAgICAgICAgIHJldHVybiBkLnRhcmdldC5uYW1lID09PSBob3ZlcmVkVGFyZ2V0ID8gaGlnaGxpZ2h0T3BhY2l0eSA6IGRpbU9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFzZU9wYWNpdHk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCAwKVxuICAgICAgICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtbGluZWNhcCcsICdidXR0JykgLy8gY3Jpc3AgZWRnZSBhZnRlciBhbmltYXRpb25cbiAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCBudWxsKVxuICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCBudWxsKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igbm9uLWNhdGVnb3J5IGNoYW5nZXMsIGp1c3Qgc2V0IHRoZSBvcGFjaXR5IGRpcmVjdGx5XG4gICAgICBuZXdMaW5rcy5hdHRyKCdvcGFjaXR5JywgKGQ6IGFueSkgPT4ge1xuICAgICAgICAvLyBBZGp1c3Qgb3BhY2l0eSBiYXNlZCBvbiBkYXJrIG1vZGUgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgICAgIGNvbnN0IGJhc2VPcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuODUgOiAwLjQ7XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodE9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMS4wIDogMC45O1xuICAgICAgICBjb25zdCBkaW1PcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuNCA6IDAuMTtcblxuICAgICAgICAvLyBIaWdobGlnaHQgbGlua3MgZnJvbSB0aGUgYWN0aXZlIHNvdXJjZSBvciB0byB0aGUgYWN0aXZlIHRhcmdldFxuICAgICAgICBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGNvbnN0IGhvdmVyZWRTb3VyY2UgPSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF07XG4gICAgICAgICAgcmV0dXJuIGQuc291cmNlLm5hbWUgPT09IGhvdmVyZWRTb3VyY2UgPyBoaWdobGlnaHRPcGFjaXR5IDogZGltT3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG92ZXJlZFRhcmdldEluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGNvbnN0IGhvdmVyZWRUYXJnZXQgPSBzb3J0ZWRUYXJnZXRzW2hvdmVyZWRUYXJnZXRJbmRleF07XG4gICAgICAgICAgcmV0dXJuIGQudGFyZ2V0Lm5hbWUgPT09IGhvdmVyZWRUYXJnZXQgPyBoaWdobGlnaHRPcGFjaXR5IDogZGltT3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZU9wYWNpdHk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgaG92ZXIgaW50ZXJhY3Rpb25zXG4gICAgbmV3TGlua3NcbiAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2ZW50OiBhbnksIGQ6IGFueSkge1xuICAgICAgICBzZXRIb3ZlcmVkTGluayhkKTtcbiAgICAgICAgc2V0VG9vbHRpcCh7XG4gICAgICAgICAgeDogZXZlbnQub2Zmc2V0WCxcbiAgICAgICAgICB5OiBldmVudC5vZmZzZXRZLFxuICAgICAgICAgIGNvbnRlbnQ6IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9udC1ib2xkXCI+e2Quc291cmNlLm5hbWV9IOKGkiB7ZC50YXJnZXQubmFtZX08L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdj57ZC52YWx1ZX0gYXR0ZW5kZWVzPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApLFxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldEhvdmVyZWRMaW5rKG51bGwpO1xuICAgICAgICBzZXRUb29sdGlwKG51bGwpO1xuICAgICAgfSk7XG5cbiAgICAvLyAtLS0gTm9kZXMgdXBkYXRlIHBhdHRlcm4gKHJlY3RzKSAtLS1cblxuXG4gICAgY29uc3QgZmlsdGVyZWROb2RlcyA9IHNhbmtleURhdGEubm9kZXM7XG4gICAgY29uc3Qgbm9kZVNlbCA9IG5vZGVzRy5zZWxlY3RBbGwoJ3JlY3QnKVxuICAgICAgLmRhdGEoZmlsdGVyZWROb2RlcywgKGQ6IGFueSkgPT4gZC5pZCk7XG4gICAgbm9kZVNlbC5leGl0KCkucmVtb3ZlKCk7XG4gICAgbm9kZVNlbC5qb2luKFxuICAgICAgZW50ZXIgPT4gZW50ZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgLmF0dHIoJ3gnLCAoZDogYW55KSA9PiBkLngwKVxuICAgICAgICAuYXR0cigneScsIChkOiBhbnkpID0+IGQueTApXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoZDogYW55KSA9PiBkLnkxIC0gZC55MClcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQ6IGFueSkgPT4gZC54MSAtIGQueDApXG4gICAgICAgIC5hdHRyKCdmaWxsJywgKGQ6IGFueSkgPT4gZ2V0Tm9kZUNvbG9yKGQsIGdldEN1cnJlbnRUaGVtZUNvbG9ycygpLCBzZXR0aW5ncy5pc0RhcmtNb2RlKSlcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHNldHRpbmdzLmlzRGFya01vZGUgPyAnIzQ0NCcgOiAnIzIyMjIzYicpXG4gICAgICAgIC5hdHRyKCdvcGFjaXR5JywgKGQ6IGFueSkgPT4ge1xuICAgICAgICAgIC8vIFNvdXJjZSBub2Rlczogb25seSB0aGUgaGlnaGxpZ2h0ZWQgb25lIGlzIGJyaWdodFxuICAgICAgICAgIGlmIChkLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF0gPyAxIDogMC4zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuOTsgLy8gSW5jcmVhc2VkIGZyb20gMC42IHRvIDAuOSBmb3IgbW9yZSBwcm9taW5lbmNlXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRhcmdldCBub2Rlczogb25seSB0aG9zZSBjb25uZWN0ZWQgdG8gdGhlIGhpZ2hsaWdodGVkIHNvdXJjZSBvciBob3ZlcmVkIHRhcmdldCBhcmUgYnJpZ2h0XG4gICAgICAgICAgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRTb3VyY2UgPSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF07XG4gICAgICAgICAgICBjb25zdCBpc0Nvbm5lY3RlZCA9IGZpbHRlcmVkTGlua3Muc29tZShsID0+IGwuc291cmNlLm5hbWUgPT09IGhvdmVyZWRTb3VyY2UgJiYgbC50YXJnZXQubmFtZSA9PT0gZC5uYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBpc0Nvbm5lY3RlZCA/IDEgOiAwLjM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0SW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBob3ZlcmVkVGFyZ2V0ID0gc29ydGVkVGFyZ2V0c1tob3ZlcmVkVGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaG92ZXJlZFRhcmdldCA/IDEgOiAwLjM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwLjk7IC8vIEluY3JlYXNlZCBmcm9tIDAuNiB0byAwLjkgZm9yIG1vcmUgcHJvbWluZW5jZVxuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldmVudDogYW55LCBkOiBhbnkpIHtcbiAgICAgICAgICBzZXRIb3ZlcmVkTm9kZShkKTtcbiAgICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICAgIHg6IGV2ZW50Lm9mZnNldFgsXG4gICAgICAgICAgICB5OiBldmVudC5vZmZzZXRZLFxuICAgICAgICAgICAgY29udGVudDogKFxuICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9udC1ib2xkXCI+e2QubmFtZX08L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2PkNhdGVnb3J5OiB7ZC5jYXRlZ29yeX08L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2PlJlc3BvbnNlczoge2QudmFsdWV9PC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNldEhvdmVyZWROb2RlKG51bGwpO1xuICAgICAgICAgIHNldFRvb2x0aXAobnVsbCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uIChldmVudDogYW55LCBkOiBhbnkpIHtcbiAgICAgICAgICBpZiAoZC5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gc29ydGVkU291cmNlcy5pbmRleE9mKGQubmFtZSk7XG4gICAgICAgICAgICBzZXRIb3ZlcmVkU291cmNlSW5kZXgoaWR4KTtcbiAgICAgICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHNvcnRlZFRhcmdldHMuaW5kZXhPZihkLm5hbWUpO1xuICAgICAgICAgICAgc2V0SG92ZXJlZFRhcmdldEluZGV4KGlkeCk7XG4gICAgICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnaGlnaGxpZ2h0aW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoZXZlbnQ6IGFueSwgZDogYW55KSB7XG4gICAgICAgICAgaWYgKGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpIHtcbiAgICAgICAgICAgIHNldEhvdmVyZWRTb3VyY2VJbmRleChudWxsKTtcbiAgICAgICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkLmNhdGVnb3J5ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICBzZXRIb3ZlcmVkVGFyZ2V0SW5kZXgobnVsbCk7XG4gICAgICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICB1cGRhdGUgPT4gdXBkYXRlXG4gICAgICAgIC50cmFuc2l0aW9uKGQzLnRyYW5zaXRpb24oKS5kdXJhdGlvbig3NTApLmVhc2UoZDMuZWFzZUN1YmljSW5PdXQpKVxuICAgICAgICAuYXR0cigneCcsIChkOiBhbnkpID0+IGQueDApXG4gICAgICAgIC5hdHRyKCd5JywgKGQ6IGFueSkgPT4gZC55MClcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkOiBhbnkpID0+IGQueTEgLSBkLnkwKVxuICAgICAgICAuYXR0cignd2lkdGgnLCAoZDogYW55KSA9PiBkLngxIC0gZC54MClcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZDogYW55KSA9PiBnZXROb2RlQ29sb3IoZCwgZ2V0Q3VycmVudFRoZW1lQ29sb3JzKCksIHNldHRpbmdzLmlzRGFya01vZGUpKVxuICAgICAgICAuYXR0cignb3BhY2l0eScsIChkOiBhbnkpID0+IHtcbiAgICAgICAgICAvLyBTb3VyY2Ugbm9kZXM6IG9ubHkgdGhlIGhpZ2hsaWdodGVkIG9uZSBpcyBicmlnaHRcbiAgICAgICAgICBpZiAoZC5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdID8gMSA6IDAuMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjk7IC8vIEluY3JlYXNlZCBmcm9tIDAuNiB0byAwLjkgZm9yIG1vcmUgcHJvbWluZW5jZVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUYXJnZXQgbm9kZXM6IG9ubHkgdGhvc2UgY29ubmVjdGVkIHRvIHRoZSBoaWdobGlnaHRlZCBzb3VyY2Ugb3IgaG92ZXJlZCB0YXJnZXQgYXJlIGJyaWdodFxuICAgICAgICAgIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBob3ZlcmVkU291cmNlID0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBmaWx0ZXJlZExpbmtzLnNvbWUobCA9PiBsLnNvdXJjZS5uYW1lID09PSBob3ZlcmVkU291cmNlICYmIGwudGFyZ2V0Lm5hbWUgPT09IGQubmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gaXNDb25uZWN0ZWQgPyAxIDogMC4zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaG92ZXJlZFRhcmdldEluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZFRhcmdldCA9IHNvcnRlZFRhcmdldHNbaG92ZXJlZFRhcmdldEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGhvdmVyZWRUYXJnZXQgPyAxIDogMC4zO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMC45OyAvLyBJbmNyZWFzZWQgZnJvbSAwLjYgdG8gMC45IGZvciBtb3JlIHByb21pbmVuY2VcbiAgICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gLS0tIE5vZGUgbGFiZWxzIChyZS1yZW5kZXIgYXMgYmVmb3JlKSAtLS1cbiAgICBnLnNlbGVjdEFsbCgnZy5sYWJlbC1sYXllcicpLnJlbW92ZSgpO1xuICAgIGNvbnN0IGxhYmVsTGF5ZXIgPSBnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2xhYmVsLWxheWVyJyk7XG4gICAgY29uc3Qgc291cmNlTm9kZVNldCA9IG5ldyBTZXQoc29ydGVkU291cmNlcyk7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZVNldCA9IG5ldyBTZXQoc29ydGVkVGFyZ2V0cyk7XG4gICAgY29uc3Qgc291cmNlTm9kZXMgPSBzYW5rZXlEYXRhLm5vZGVzLmZpbHRlcihkID0+IGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpO1xuICAgIGNvbnN0IHRhcmdldE5vZGVzID0gc2Fua2V5RGF0YS5ub2Rlcy5maWx0ZXIoZCA9PiBkLmNhdGVnb3J5ID09PSBjdXJyZW50VGFyZ2V0KTtcbiAgICBzb3VyY2VOb2Rlcy5mb3JFYWNoKChub2RlOiBhbnkpID0+IHtcbiAgICAgIGlmIChzb3VyY2VOb2RlU2V0Lmhhcyhub2RlLm5hbWUpKSB7XG4gICAgICAgIGxhYmVsTGF5ZXJcbiAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAuYXR0cigneCcsIC1sYWJlbFBhZGRpbmcpXG4gICAgICAgICAgLmF0dHIoJ3knLCAobm9kZS55MCArIG5vZGUueTEpIC8gMilcbiAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJylcbiAgICAgICAgICAuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpXG4gICAgICAgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5Jywgbm9kZUxhYmVsRm9udEZhbWlseSlcbiAgICAgICAgICAuYXR0cignZm9udC13ZWlnaHQnLCBub2RlTGFiZWxGb250V2VpZ2h0KVxuICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBsYWJlbEZvbnRTaXplKVxuICAgICAgICAgIC5hdHRyKCdmaWxsJywgbm9kZUxhYmVsQ29sb3IpXG4gICAgICAgICAgLmF0dHIoJ2FyaWEtbGFiZWwnLCBub2RlLm5hbWUpXG4gICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBub2RlLnZhbHVlID09PSAwID8gMC41IDogMSlcbiAgICAgICAgICAudGV4dChub2RlLm5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhcmdldE5vZGVzLmZvckVhY2goKG5vZGU6IGFueSkgPT4ge1xuICAgICAgaWYgKHRhcmdldE5vZGVTZXQuaGFzKG5vZGUubmFtZSkpIHtcbiAgICAgICAgbGFiZWxMYXllclxuICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCd4JywgY2hhcnRXaWR0aCArIGxhYmVsUGFkZGluZylcbiAgICAgICAgICAuYXR0cigneScsIChub2RlLnkwICsgbm9kZS55MSkgLyAyKVxuICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXG4gICAgICAgICAgLmF0dHIoJ2FsaWdubWVudC1iYXNlbGluZScsICdtaWRkbGUnKVxuICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsIG5vZGVMYWJlbEZvbnRGYW1pbHkpXG4gICAgICAgICAgLmF0dHIoJ2ZvbnQtd2VpZ2h0Jywgbm9kZUxhYmVsRm9udFdlaWdodClcbiAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgbGFiZWxGb250U2l6ZSlcbiAgICAgICAgICAuYXR0cignZmlsbCcsIG5vZGVMYWJlbENvbG9yKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWxhYmVsJywgbm9kZS5uYW1lKVxuICAgICAgICAgIC5hdHRyKCdvcGFjaXR5Jywgbm9kZS52YWx1ZSA9PT0gMCA/IDAuNSA6IDEpXG4gICAgICAgICAgLnRleHQobm9kZS5uYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIDYuIFVwZGF0ZSBpbnNpZ2h0c1xuICAgIGxldCBtb3N0Q29tbW9uOiB0eXBlb2YgbGlua3NbMF0gfCB1bmRlZmluZWQgPSBsaW5rcy5sZW5ndGggPiAwID8gbGlua3MucmVkdWNlKChhLCBiKSA9PiAoYi52YWx1ZSA+IGEudmFsdWUgPyBiIDogYSksIGxpbmtzWzBdKSA6IHVuZGVmaW5lZDtcbiAgICBzZXRJbnNpZ2h0cyhbXG4gICAgICB7IHRpdGxlOiAnVG90YWwgUmVzcG9uc2VzJywgdmFsdWU6IGRhdGEubGVuZ3RoIH0sXG4gICAgICB7IHRpdGxlOiAnQ3VycmVudCBWaWV3JywgdmFsdWU6IGAke2N1cnJlbnRTb3VyY2V9IOKGkiAke2N1cnJlbnRUYXJnZXR9YCB9LFxuICAgICAgbW9zdENvbW1vblxuICAgICAgICA/IHsgdGl0bGU6ICdNb3N0IENvbW1vbiBGbG93JywgdmFsdWU6IGAke21vc3RDb21tb24uc291cmNlLnNwbGl0KCc6JylbMV19IOKGkiAke21vc3RDb21tb24udGFyZ2V0LnNwbGl0KCc6JylbMV19YCwgZGVzY3JpcHRpb246IGAke21vc3RDb21tb24udmFsdWV9IGF0dGVuZGVlc2AgfVxuICAgICAgICA6IHsgdGl0bGU6ICdNb3N0IENvbW1vbiBGbG93JywgdmFsdWU6ICdOL0EnLCBkZXNjcmlwdGlvbjogJycgfSxcbiAgICBdKTtcblxuICAgIC8vIDcuIEF1dG9tYXRpYyBhbmltYXRpb24gb24gcXVlc3Rpb24gY2hhbmdlIG9ubHlcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gZDMudHJhbnNpdGlvbigpLmR1cmF0aW9uKDc1MCkuZWFzZShkMy5lYXNlQ3ViaWNJbk91dCk7XG5cbiAgICAvLyBBbmltYXRlIG5vZGVzXG4gICAgbm9kZVNlbFxuICAgICAgLnRyYW5zaXRpb24odHJhbnNpdGlvbilcbiAgICAgIC5hdHRyKCd4JywgKGQ6IGFueSkgPT4gZC54MClcbiAgICAgIC5hdHRyKCd5JywgKGQ6IGFueSkgPT4gZC55MClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCAoZDogYW55KSA9PiBkLnkxIC0gZC55MClcbiAgICAgIC5hdHRyKCd3aWR0aCcsIChkOiBhbnkpID0+IGQueDEgLSBkLngwKVxuICAgICAgLmF0dHIoJ2ZpbGwnLCAoZDogYW55KSA9PiBnZXROb2RlQ29sb3IoZCwgZ2V0Q3VycmVudFRoZW1lQ29sb3JzKCksIHNldHRpbmdzLmlzRGFya01vZGUpKTtcblxuICB9LCBbZmlsdGVyZWREYXRhLCBjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0LCBzZXR0aW5ncy5jYXRlZ29yeUNvbG9ycywgc2V0dGluZ3MuaXNEYXJrTW9kZSwgbGFzdENhdGVnb3J5Q2hhbmdlLCBnZXRDdXJyZW50VGhlbWVDb2xvcnNdKTtcblxuICAvLyBDcmVhdGUgc29ydGVkIHRhcmdldHMgZm9yIGNvbnNpc3RlbnQgaGlnaGxpZ2h0aW5nXG4gIGNvbnN0IHNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4udGFyZ2V0c107XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgICBzb3J0ZWQuc29ydCgoYSwgYikgPT4gWUVBUlNfQ0FURUdPUklFUy5pbmRleE9mKGEpIC0gWUVBUlNfQ0FURUdPUklFUy5pbmRleE9mKGIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ydGVkLnNvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvcnRlZDtcbiAgfSwgW3RhcmdldHMsIGN1cnJlbnRUYXJnZXRdKTtcblxuICAvLyBTZXBhcmF0ZSBlZmZlY3QgdG8gdXBkYXRlIHZpc3VhbCBoaWdobGlnaHRpbmcgZHVyaW5nIGFuaW1hdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc3ZnUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGNvbnN0IHN2ZyA9IGQzLnNlbGVjdDxTVkdTVkdFbGVtZW50LCB1bmtub3duPihzdmdSZWYuY3VycmVudCk7XG4gICAgY29uc3QgZyA9IHN2Zy5zZWxlY3QoJ2cnKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgbm9kZSBvcGFjaXR5IGJhc2VkIG9uIGFuaW1hdGlvbiBzdGF0ZVxuICAgIGcuc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbigyMDApXG4gICAgICAuYXR0cignb3BhY2l0eScsIGZ1bmN0aW9uKGQ6IGFueSkge1xuICAgICAgICAvLyBTb3VyY2Ugbm9kZXM6IG9ubHkgdGhlIGhpZ2hsaWdodGVkIG9uZSBpcyBicmlnaHRcbiAgICAgICAgaWYgKGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpIHtcbiAgICAgICAgICBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdID8gMSA6IDAuMjsgLy8gU2xpZ2h0bHkgaGlnaGVyIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMC45OyAvLyBJbmNyZWFzZWQgZnJvbSAwLjYgdG8gMC45IGZvciBtb3JlIHByb21pbmVuY2VcbiAgICAgICAgfVxuICAgICAgICAvLyBUYXJnZXQgbm9kZXM6IGhpZ2hsaWdodCB0aG9zZSBjb25uZWN0ZWQgdG8gdGhlIGhpZ2hsaWdodGVkIHNvdXJjZVxuICAgICAgICBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGNvbnN0IGhvdmVyZWRTb3VyY2UgPSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF07XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyB0YXJnZXQgbm9kZSBpcyBjb25uZWN0ZWQgdG8gdGhlIGhpZ2hsaWdodGVkIHNvdXJjZVxuICAgICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gc3ZnLnNlbGVjdEFsbCgncGF0aCcpLmRhdGEoKS5zb21lKChsaW5rOiBhbnkpID0+IFxuICAgICAgICAgICAgbGluay5zb3VyY2UubmFtZSA9PT0gaG92ZXJlZFNvdXJjZSAmJiBsaW5rLnRhcmdldC5uYW1lID09PSBkLm5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBpc0Nvbm5lY3RlZCA/IDEgOiAwLjI7IC8vIFNsaWdodGx5IGhpZ2hlciBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG92ZXJlZFRhcmdldEluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIGNvbnN0IGhvdmVyZWRUYXJnZXQgPSBzb3J0ZWRUYXJnZXRzRm9ySGlnaGxpZ2h0W2hvdmVyZWRUYXJnZXRJbmRleF07XG4gICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaG92ZXJlZFRhcmdldCA/IDEgOiAwLjI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuOTsgLy8gSW5jcmVhc2VkIGZyb20gMC42IHRvIDAuOSBmb3IgbW9yZSBwcm9taW5lbmNlXG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uKGQ6IGFueSkge1xuICAgICAgICAvLyBBZGQgdGhpY2tlciBzdHJva2UgdG8gaGlnaGxpZ2h0ZWQgc291cmNlIG5vZGVcbiAgICAgICAgaWYgKGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UgJiYgaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XSA/IDMgOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgbGluayBvcGFjaXR5IGJhc2VkIG9uIGFuaW1hdGlvbiBzdGF0ZVxuICAgIGcuc2VsZWN0QWxsKCdwYXRoJylcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbigyMDApXG4gICAgICAuYXR0cignb3BhY2l0eScsIGZ1bmN0aW9uKGQ6IGFueSkge1xuICAgICAgICAvLyBBZGp1c3Qgb3BhY2l0eSBiYXNlZCBvbiBkYXJrIG1vZGUgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgICAgIGNvbnN0IGJhc2VPcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuODUgOiAwLjQ7XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodE9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMS4wIDogMC45NTtcbiAgICAgICAgY29uc3QgZGltT3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjM1IDogMC4wNTtcblxuICAgICAgICAvLyBEZWZhdWx0IG9wYWNpdHkgd2hlbiBubyBoaWdobGlnaHRpbmdcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlICE9PSAnaGlnaGxpZ2h0aW5nJykgcmV0dXJuIGJhc2VPcGFjaXR5O1xuXG4gICAgICAgIC8vIEhpZ2hsaWdodCBsaW5rcyBmcm9tIHRoZSBhY3RpdmUgc291cmNlXG4gICAgICAgIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBob3ZlcmVkU291cmNlID0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdO1xuICAgICAgICAgIHJldHVybiBkLnNvdXJjZS5uYW1lID09PSBob3ZlcmVkU291cmNlID8gaGlnaGxpZ2h0T3BhY2l0eSA6IGRpbU9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWdobGlnaHQgbGlua3MgdG8gdGhlIGFjdGl2ZSB0YXJnZXRcbiAgICAgICAgaWYgKGhvdmVyZWRUYXJnZXRJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGhvdmVyZWRUYXJnZXQgPSBzb3J0ZWRUYXJnZXRzRm9ySGlnaGxpZ2h0W2hvdmVyZWRUYXJnZXRJbmRleF07XG4gICAgICAgICAgcmV0dXJuIGQudGFyZ2V0Lm5hbWUgPT09IGhvdmVyZWRUYXJnZXQgPyBoaWdobGlnaHRPcGFjaXR5IDogZGltT3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlT3BhY2l0eTtcbiAgICAgIH0pXG4gICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgZnVuY3Rpb24oZDogYW55KSB7XG4gICAgICAgIC8vIE1ha2UgaGlnaGxpZ2h0ZWQgbGlua3MgdGhpY2tlclxuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnICYmIGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGhvdmVyZWRTb3VyY2UgPSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF07XG4gICAgICAgICAgcmV0dXJuIGQuc291cmNlLm5hbWUgPT09IGhvdmVyZWRTb3VyY2UgPyBNYXRoLm1heCgyLCBkLndpZHRoICogMS4yKSA6IE1hdGgubWF4KDEsIGQud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgxLCBkLndpZHRoKTtcbiAgICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coJ/CfjqggVmlzdWFsIGhpZ2hsaWdodGluZyB1cGRhdGVkOicsIHtcbiAgICAgIGhvdmVyZWRTb3VyY2VJbmRleCxcbiAgICAgIHNvdXJjZU5hbWU6IGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCA/IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XSA6IG51bGwsXG4gICAgICBob3ZlcmVkVGFyZ2V0SW5kZXgsXG4gICAgICB0YXJnZXROYW1lOiBob3ZlcmVkVGFyZ2V0SW5kZXggIT09IG51bGwgPyBzb3J0ZWRUYXJnZXRzRm9ySGlnaGxpZ2h0W2hvdmVyZWRUYXJnZXRJbmRleF0gOiBudWxsLFxuICAgICAgYW5pbWF0aW9uUGhhc2VcbiAgICB9KTtcblxuICB9LCBbaG92ZXJlZFNvdXJjZUluZGV4LCBob3ZlcmVkVGFyZ2V0SW5kZXgsIGFuaW1hdGlvblBoYXNlLCBzb3J0ZWRTb3VyY2VzLCBzb3J0ZWRUYXJnZXRzRm9ySGlnaGxpZ2h0LCBjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0XSk7XG5cbiAgLy8gU2VwYXJhdGUgZWZmZWN0IGZvciBob3ZlciBpbnRlcmFjdGlvbnMgKGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSB2aXN1YWxpemF0aW9uKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc3ZnUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGNvbnN0IHN2ZyA9IGQzLnNlbGVjdDxTVkdTVkdFbGVtZW50LCB1bmtub3duPihzdmdSZWYuY3VycmVudCk7XG4gICAgY29uc3QgZyA9IHN2Zy5zZWxlY3QoJ2cnKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgbGluayBob3ZlciBlZmZlY3RzXG4gICAgZy5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgLmVhY2goZnVuY3Rpb24oZDogYW55KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgIGNvbnN0IGlzSG92ZXJlZCA9IGhvdmVyZWRMaW5rID09PSBkO1xuICAgICAgICBwYXRoLmF0dHIoJ2ZpbHRlcicsIGlzSG92ZXJlZCA/ICd1cmwoI2dsb3cpJyA6IG51bGwpO1xuICAgICAgfSk7XG5cbiAgfSwgW2hvdmVyZWROb2RlLCBob3ZlcmVkTGlua10pO1xuXG4gIC8vIFRvb2x0aXAgZmFkZW91dCBsb2dpY1xuICBjb25zdCBbdG9vbHRpcFZpc2libGUsIHNldFRvb2x0aXBWaXNpYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgdG9vbHRpcFRpbWVvdXRSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0b29sdGlwKSB7XG4gICAgICBzZXRUb29sdGlwVmlzaWJsZSh0cnVlKTtcbiAgICAgIGlmICh0b29sdGlwVGltZW91dFJlZi5jdXJyZW50KSBjbGVhclRpbWVvdXQodG9vbHRpcFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB0b29sdGlwVGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldFRvb2x0aXBWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRUb29sdGlwKG51bGwpLCA0MDApOyAvLyBXYWl0IGZvciBmYWRlb3V0XG4gICAgICB9LCA1MDAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VG9vbHRpcFZpc2libGUoZmFsc2UpO1xuICAgICAgaWYgKHRvb2x0aXBUaW1lb3V0UmVmLmN1cnJlbnQpIGNsZWFyVGltZW91dCh0b29sdGlwVGltZW91dFJlZi5jdXJyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0b29sdGlwVGltZW91dFJlZi5jdXJyZW50KSBjbGVhclRpbWVvdXQodG9vbHRpcFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW3Rvb2x0aXBdKTtcblxuICBjb25zdCB0b29sdGlwRWwgPSB0b29sdGlwID8gKFxuICAgIDxkaXZcbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBsZWZ0OiB0b29sdGlwLnggKyAxNixcbiAgICAgICAgdG9wOiB0b29sdGlwLnkgKyAxNixcbiAgICAgICAgYmFja2dyb3VuZDogc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdyZ2JhKDIwLDIwLDMwLDAuOTgpJyA6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuOTgpJyxcbiAgICAgICAgY29sb3I6IHNldHRpbmdzLmlzRGFya01vZGUgPyAnI2ZmZicgOiAnIzE3MEY1RicsXG4gICAgICAgIHBhZGRpbmc6ICc4cHggMTJweCcsXG4gICAgICAgIGJvcmRlclJhZGl1czogNixcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICB6SW5kZXg6IDEwMCxcbiAgICAgICAgZm9udEZhbWlseTogJ0F2ZW5pciBOZXh0IFdvcmxkLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgZm9udFdlaWdodDogNjAwLFxuICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgIGJveFNoYWRvdzogc2V0dGluZ3MuaXNEYXJrTW9kZSBcbiAgICAgICAgICA/ICcwIDRweCAyNHB4IDAgcmdiYSgxNiwgMTYsIDIzNSwgMC4xMiknIFxuICAgICAgICAgIDogJzAgNHB4IDI0cHggMCByZ2JhKDAsIDAsIDAsIDAuMTUpJyxcbiAgICAgICAgYm9yZGVyOiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJzFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMSknIDogJzFweCBzb2xpZCByZ2JhKDAsMCwwLDAuMSknLFxuICAgICAgICBtYXhXaWR0aDogMjgwLFxuICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICAgIG9wYWNpdHk6IHRvb2x0aXBWaXNpYmxlID8gMSA6IDAsXG4gICAgICAgIHRyYW5zaXRpb246ICdvcGFjaXR5IDAuNHMnLFxuICAgICAgfX1cbiAgICAgIHJvbGU9XCJ0b29sdGlwXCJcbiAgICAgIGFyaWEtbGl2ZT1cInBvbGl0ZVwiXG4gICAgPlxuICAgICAge3Rvb2x0aXAuY29udGVudH1cbiAgICA8L2Rpdj5cbiAgKSA6IG51bGw7XG5cbiAgLy8gQ3JlYXRlIHNvcnRlZCBzb3VyY2VzIGFycmF5IGZvciBoaWdobGlnaHRpbmcgKHNhbWUgYXMgcmVuZGVyaW5nIGFuZCBhbmltYXRpb24pXG4gIGNvbnN0IHNvcnRlZFNvdXJjZXNGb3JIaWdobGlnaHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdmlzdWFsT3JkZXI6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKGZpbHRlcmVkRGF0YS5sZW5ndGggJiYgY2hhcnRXaWR0aCA+IDAgJiYgY2hhcnRIZWlnaHQgPiAwKSB7XG4gICAgICBjb25zdCBzb3VyY2VzRm9yTm9kZXMgPSBbLi4uc291cmNlc107XG4gIGlmIChjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgICAgICBzb3VyY2VzRm9yTm9kZXMuc29ydCgoYSwgYikgPT4gWUVBUlNfQ0FURUdPUklFUy5pbmRleE9mKGEpIC0gWUVBUlNfQ0FURUdPUklFUy5pbmRleE9mKGIpKTtcbiAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlc0Zvck5vZGVzLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGVzID0gW1xuICAgICAgICAuLi5zb3VyY2VzRm9yTm9kZXMubWFwKChuYW1lKSA9PiAoeyBpZDogYCR7Y3VycmVudFNvdXJjZX06JHtuYW1lfWAsIG5hbWUsIGNhdGVnb3J5OiBjdXJyZW50U291cmNlIH0pKSxcbiAgICAgICAgLi4udGFyZ2V0cy5tYXAoKG5hbWUpID0+ICh7IGlkOiBgJHtjdXJyZW50VGFyZ2V0fToke25hbWV9YCwgbmFtZSwgY2F0ZWdvcnk6IGN1cnJlbnRUYXJnZXQgfSkpLFxuICAgICAgXTtcbiAgICAgIGNvbnN0IGxpbmtzTWFwID0gbmV3IE1hcDxzdHJpbmcsIHsgc291cmNlOiBzdHJpbmc7IHRhcmdldDogc3RyaW5nOyB2YWx1ZTogbnVtYmVyLCBpc0R1bW15PzogYm9vbGVhbiB9PigpO1xuICAgICAgZmlsdGVyZWREYXRhLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gY3VycmVudFNvdXJjZSA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycgPyBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApIDogKGQgYXMgYW55KVtjdXJyZW50U291cmNlXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gY3VycmVudFRhcmdldCA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycgPyBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApIDogKGQgYXMgYW55KVtjdXJyZW50VGFyZ2V0XTtcbiAgICAgICAgY29uc3Qgc291cmNlSWQgPSBgJHtjdXJyZW50U291cmNlfToke3NvdXJjZX1gO1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IGAke2N1cnJlbnRUYXJnZXR9OiR7dGFyZ2V0fWA7XG4gICAgICAgIGlmICghc291cmNlc0Zvck5vZGVzLmluY2x1ZGVzKHNvdXJjZSkgfHwgIXRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtzb3VyY2VJZH3ihpIke3RhcmdldElkfWA7XG4gICAgICAgIGlmICghbGlua3NNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICBsaW5rc01hcC5zZXQoa2V5LCB7IHNvdXJjZTogc291cmNlSWQsIHRhcmdldDogdGFyZ2V0SWQsIHZhbHVlOiAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxpbmtzTWFwLmdldChrZXkpIS52YWx1ZSArPSAxO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBsaW5rcyA9IEFycmF5LmZyb20obGlua3NNYXAudmFsdWVzKCkpO1xuICAgICAgY29uc3Qgc2Fua2V5R2VuZXJhdG9yID0gc2Fua2V5PGFueSwgYW55PigpXG4gICAgICAgIC5ub2RlSWQoKGQ6IGFueSkgPT4gZC5pZClcbiAgICAgICAgLm5vZGVXaWR0aCgxMilcbiAgICAgICAgLm5vZGVQYWRkaW5nKG5vZGVQYWRkaW5nKVxuICAgICAgICAuZXh0ZW50KFtbMCwgMF0sIFtjaGFydFdpZHRoLCBjaGFydEhlaWdodF1dKTtcbiAgICAgIGNvbnN0IHNhbmtleURhdGEgPSBzYW5rZXlHZW5lcmF0b3Ioe1xuICAgICAgICBub2Rlczogbm9kZXMubWFwKChkKSA9PiAoeyAuLi5kIH0pKSxcbiAgICAgICAgbGlua3M6IGxpbmtzLm1hcCgoZCkgPT4gKHsgLi4uZCB9KSksXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNvdXJjZU5vZGVzID0gc2Fua2V5RGF0YS5ub2Rlcy5maWx0ZXIoKGQ6IGFueSkgPT4gZC5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSk7XG4gICAgICB2aXN1YWxPcmRlciA9IHNvdXJjZU5vZGVzXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gYS55MCAtIGIueTApXG4gICAgICAgIC5tYXAoKGQ6IGFueSkgPT4gZC5uYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc3VhbE9yZGVyLmxlbmd0aCA/IHZpc3VhbE9yZGVyIDogWy4uLnNvdXJjZXNdO1xuICB9LCBbZmlsdGVyZWREYXRhLCBjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0LCBzb3VyY2VzLCB0YXJnZXRzLCBjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgbm9kZVBhZGRpbmddKTtcblxuICAvLyBEZXRlcm1pbmUgd2hpY2ggc291cmNlIG9yIHRhcmdldCB0byBoaWdobGlnaHQgYmFzZWQgb24gYW5pbWF0aW9uIHN0YXRlXG4gIGxldCBoaWdobGlnaHRTb3VyY2VOYW1lOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgbGV0IGhpZ2hsaWdodFRhcmdldE5hbWU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBpZiAoaXNJbkZ1bGxPcGFjaXR5U3RhdGUpIHtcbiAgICBoaWdobGlnaHRTb3VyY2VOYW1lID0gbnVsbDtcbiAgICBoaWdobGlnaHRUYXJnZXROYW1lID0gbnVsbDtcbiAgfSBlbHNlIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgaGlnaGxpZ2h0U291cmNlTmFtZSA9IHNvcnRlZFNvdXJjZXNGb3JIaWdobGlnaHRbaG92ZXJlZFNvdXJjZUluZGV4XTtcbiAgfSBlbHNlIGlmIChob3ZlcmVkVGFyZ2V0SW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgaGlnaGxpZ2h0VGFyZ2V0TmFtZSA9IHRhcmdldHNbaG92ZXJlZFRhcmdldEluZGV4XTtcbiAgfVxuXG4gIC8vIEVuaGFuY2VkIGFuaW1hdGlvbiBwYXVzZS9yZXN1bWUgd2l0aCBkZWJ1ZyB0cmFja2luZ1xuICBjb25zdCBwYXVzZUFuaW1hdGlvbiA9IHVzZUNhbGxiYWNrKChyZWFzb246IHN0cmluZykgPT4ge1xuICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nICYmICFhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KPuO+4jyAgUEFVU0lORyBBTklNQVRJT046JywgcmVhc29uLCB7XG4gICAgICAgIGN1cnJlbnRTb3VyY2VJbmRleDogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4LFxuICAgICAgICBjdXJyZW50VGFyZ2V0SW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCxcbiAgICAgICAgY3VycmVudFNvdXJjZSxcbiAgICAgICAgY3VycmVudFRhcmdldFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkID0gdHJ1ZTtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnBhdXNlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIFxuICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0XSk7XG5cbiAgY29uc3QgcmVzdW1lQW5pbWF0aW9uID0gdXNlQ2FsbGJhY2soKHJlYXNvbjogc3RyaW5nKSA9PiB7XG4gICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfilrbvuI8gIFJFU1VNSU5HIEFOSU1BVElPTjonLCByZWFzb24sIHtcbiAgICAgICAgY3VycmVudFNvdXJjZUluZGV4OiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXgsXG4gICAgICAgIGN1cnJlbnRUYXJnZXRJbmRleDogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4LFxuICAgICAgICBwYXVzZWREdXJhdGlvbjogRGF0ZS5ub3coKSAtIGFuaW1hdGlvblJlZi5jdXJyZW50LnBhdXNlZEF0XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnJlc3VtZUZyb20gPSAnc291cmNlJztcbiAgICAgIFxuICAgICAgLy8gUmVzdW1lIGFuaW1hdGlvbiBmcm9tIGN1cnJlbnQgcG9zaXRpb24gd2l0aCBhIHNtYWxsIGRlbGF5IHRvIGVuc3VyZSBzdGF0ZSBpcyB1cGRhdGVkXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfSwgW2FuaW1hdGVdKTtcblxuICAvLyBVcGRhdGUgaG92ZXIgaGFuZGxlcnMgd2l0aCBwcm9wZXIgc3RhdGUgbWFuYWdlbWVudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc3ZnUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGNvbnN0IHN2ZyA9IGQzLnNlbGVjdChzdmdSZWYuY3VycmVudCk7XG4gICAgXG4gICAgLy8gVXBkYXRlIGxpbmsgaG92ZXIgYmVoYXZpb3JcbiAgICBzdmcuc2VsZWN0QWxsKCdwYXRoJylcbiAgICAgIC5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKGV2ZW50OiBhbnksIGQ6IGFueSkge1xuICAgICAgICAvLyBQYXVzZSBhbmltYXRpb24gZHVyaW5nIGhvdmVyXG4gICAgICAgIHBhdXNlQW5pbWF0aW9uKCdsaW5rIGhvdmVyJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgaG92ZXIgc3RhdGVzXG4gICAgICAgIHNldEhvdmVyZWRMaW5rKGQpO1xuICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnaGlnaGxpZ2h0aW5nJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgc291cmNlIG5vZGUgaG92ZXJcbiAgICAgICAgaWYgKGQuc291cmNlICYmIGQuc291cmNlLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlKSB7XG4gICAgICAgICAgY29uc3QgaWR4ID0gc29ydGVkU291cmNlcy5pbmRleE9mKGQuc291cmNlLm5hbWUpO1xuICAgICAgICAgIHNldEhvdmVyZWRTb3VyY2VJbmRleChpZHgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46vIE1hbnVhbCBzb3VyY2UgaGlnaGxpZ2h0OicsIGQuc291cmNlLm5hbWUsICdpbmRleDonLCBpZHgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgdGFyZ2V0IG5vZGUgaG92ZXJcbiAgICAgICAgaWYgKGQudGFyZ2V0ICYmIGQudGFyZ2V0LmNhdGVnb3J5ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgaWR4ID0gc29ydGVkVGFyZ2V0c0ZvckhpZ2hsaWdodC5pbmRleE9mKGQudGFyZ2V0Lm5hbWUpO1xuICAgICAgICAgIHNldEhvdmVyZWRUYXJnZXRJbmRleChpZHgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46vIE1hbnVhbCB0YXJnZXQgaGlnaGxpZ2h0OicsIGQudGFyZ2V0Lm5hbWUsICdpbmRleDonLCBpZHgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFJlc3VtZSBhbmltYXRpb25cbiAgICAgICAgcmVzdW1lQW5pbWF0aW9uKCdsaW5rIGhvdmVyIGVuZCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgaG92ZXIgc3RhdGVzXG4gICAgICAgIHNldEhvdmVyZWRMaW5rKG51bGwpO1xuICAgICAgICBzZXRIb3ZlcmVkU291cmNlSW5kZXgobnVsbCk7XG4gICAgICAgIHNldEhvdmVyZWRUYXJnZXRJbmRleChudWxsKTtcbiAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIG5vZGUgaG92ZXIgYmVoYXZpb3JcbiAgICBzdmcuc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgIC5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKGV2ZW50OiBhbnksIGQ6IGFueSkge1xuICAgICAgICAvLyBQYXVzZSBhbmltYXRpb24gZHVyaW5nIGhvdmVyXG4gICAgICAgIHBhdXNlQW5pbWF0aW9uKCdub2RlIGhvdmVyJyk7XG4gICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEhhbmRsZSBzb3VyY2Ugbm9kZSBob3ZlclxuICAgICAgICBpZiAoZC5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSkge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IHNvcnRlZFNvdXJjZXMuaW5kZXhPZihkLm5hbWUpO1xuICAgICAgICAgIHNldEhvdmVyZWRTb3VyY2VJbmRleChpZHgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46vIE1hbnVhbCBzb3VyY2Ugbm9kZSBoaWdobGlnaHQ6JywgZC5uYW1lLCAnaW5kZXg6JywgaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSGFuZGxlIHRhcmdldCBub2RlIGhvdmVyXG4gICAgICAgIGlmIChkLmNhdGVnb3J5ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgaWR4ID0gc29ydGVkVGFyZ2V0c0ZvckhpZ2hsaWdodC5pbmRleE9mKGQubmFtZSk7XG4gICAgICAgICAgc2V0SG92ZXJlZFRhcmdldEluZGV4KGlkeCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gTWFudWFsIHRhcmdldCBub2RlIGhpZ2hsaWdodDonLCBkLm5hbWUsICdpbmRleDonLCBpZHgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFJlc3VtZSBhbmltYXRpb25cbiAgICAgICAgcmVzdW1lQW5pbWF0aW9uKCdub2RlIGhvdmVyIGVuZCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgaG92ZXIgc3RhdGVzXG4gICAgICAgIHNldEhvdmVyZWRTb3VyY2VJbmRleChudWxsKTtcbiAgICAgICAgc2V0SG92ZXJlZFRhcmdldEluZGV4KG51bGwpO1xuICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXAgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgc3ZnLnNlbGVjdEFsbCgncGF0aCwgcmVjdCcpXG4gICAgICAgIC5vbignbW91c2VlbnRlcicsIG51bGwpXG4gICAgICAgIC5vbignbW91c2VsZWF2ZScsIG51bGwpO1xuICAgIH07XG4gIH0sIFtzb3J0ZWRTb3VyY2VzLCBzb3J0ZWRUYXJnZXRzRm9ySGlnaGxpZ2h0LCBjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0LCBwYXVzZUFuaW1hdGlvbiwgcmVzdW1lQW5pbWF0aW9uXSk7XG5cbiAgLy8gTWFpbiByZW5kZXJpbmcgZWZmZWN0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzdmdSZWYuY3VycmVudCB8fCAhZGF0YS5sZW5ndGgpIHJldHVybjtcbiAgICBcbiAgICAvLyBUaGUgbWFpbiByZW5kZXJpbmcgbG9naWMgaGFuZGxlcyBhbGwgb3BhY2l0eSB1cGRhdGVzXG4gICAgLy8gVGhpcyBlbnN1cmVzIGRhdGEgYmluZGluZyBpcyBjb3JyZWN0IGFuZCBwcmV2ZW50cyB0aGUgdW5kZWZpbmVkIGVycm9yXG4gICAgXG4gIH0sIFtmaWx0ZXJlZERhdGEsIGhvdmVyZWRTb3VyY2VJbmRleCwgaG92ZXJlZFRhcmdldEluZGV4LCBhbmltYXRpb25QaGFzZSwgc29ydGVkU291cmNlcywgdGFyZ2V0cywgY3VycmVudFNvdXJjZSwgY3VycmVudFRhcmdldF0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiByZWY9e2NvbnRhaW5lclJlZn0gc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIG1pbkhlaWdodDogMjIwLCBtaW5XaWR0aDogMzIwLCBwb3NpdGlvbjogJ3JlbGF0aXZlJyB9fT5cbiAgICAgIHsvKiBTaG93IGEgbWVzc2FnZSBpZiBkYXRhIGlzIHZlcnkgc3BhcnNlICovfVxuICAgICAgeyhub2RlQ291bnQgPD0gMiB8fCAoc291cmNlcy5sZW5ndGggPD0gMSB8fCB0YXJnZXRzLmxlbmd0aCA8PSAxKSkgJiYgKFxuICAgICAgICA8ZGl2IHN0eWxlPXt7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiA0MCxcbiAgICAgICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAncmdiYSgyNTUsMjU1LDIwMCwwLjk1KScsXG4gICAgICAgICAgY29sb3I6ICcjMTcwRjVGJyxcbiAgICAgICAgICBwYWRkaW5nOiAnMTJweCAyNHB4JyxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IDgsXG4gICAgICAgICAgZm9udFdlaWdodDogNjAwLFxuICAgICAgICAgIGZvbnRTaXplOiAxOCxcbiAgICAgICAgICB6SW5kZXg6IDEwLFxuICAgICAgICAgIGJveFNoYWRvdzogJzAgMnB4IDEycHggMCByZ2JhKDAsMCwwLDAuMDgpJ1xuICAgICAgICB9fT5cbiAgICAgICAgICBOb3QgZW5vdWdoIGRhdGEgdG8gc2hvdyBhIG1lYW5pbmdmdWwgZmxvdyBkaWFncmFtLlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICA8c3ZnXG4gICAgICAgIHJlZj17c3ZnUmVmfVxuICAgICAgICB3aWR0aD17Y2hhcnRXaWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0fVxuICAgICAgICBoZWlnaHQ9e2NoYXJ0SGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b219XG4gICAgICAgIHZpZXdCb3g9e2AwIDAgJHtjaGFydFdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHR9ICR7Y2hhcnRIZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbX1gfVxuICAgICAgICBzdHlsZT17eyBkaXNwbGF5OiAnYmxvY2snLCB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJywgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyB9fVxuICAgICAgPlxuICAgICAgICB7LyogTWFpbiBjaGFydCBncm91cCwgdHJhbnNsYXRlZCBieSBtYXJnaW4gKi99XG4gICAgICAgIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwke21hcmdpbi50b3B9KWB9PlxuICAgICAgICAgIHsvKiAuLi4gbm9kZXMgYW5kIGxpbmtzIC4uLiAqL31cbiAgICAgICAgPC9nPlxuICAgICAgICB7LyogRGVidWcgb3V0bGluZXMgZm9yIGFsaWdubWVudCAob25seSBpZiBkZWJ1Z09uKSAqL31cbiAgICAgICAge2RlYnVnT24gJiYgKFxuICAgICAgICAgIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwke21hcmdpbi50b3B9KWB9PlxuICAgICAgICAgICAgey8qIE5vZGUgZGVidWcgb3V0bGluZXMgKi99XG4gICAgICAgICAgICB7QXJyYXkuaXNBcnJheShkZWJ1Z1NhbmtleURhdGE/Lm5vZGVzKSAmJiBkZWJ1Z1NhbmtleURhdGEubm9kZXMubWFwKChkOiBhbnksIGk6IG51bWJlcikgPT4gKFxuICAgICAgICAgICAgICA8cmVjdFxuICAgICAgICAgICAgICAgIGtleT17YGRlYnVnLW5vZGUtJHtpfWB9XG4gICAgICAgICAgICAgICAgeD17ZC54MH1cbiAgICAgICAgICAgICAgICB5PXtkLnkwfVxuICAgICAgICAgICAgICAgIHdpZHRoPXtkLngxIC0gZC54MH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9e2QueTEgLSBkLnkwfVxuICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICBzdHJva2U9XCJtYWdlbnRhXCJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9XCI0IDJcIlxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM9XCJub25lXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgey8qIExpbmsgZGVidWcgb3V0bGluZXMgKGlmIGFueSkgKi99XG4gICAgICAgICAgICB7QXJyYXkuaXNBcnJheShkZWJ1Z1NhbmtleURhdGE/LmxpbmtzKSAmJiBkZWJ1Z1NhbmtleURhdGEubGlua3MubWFwKChkOiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoID0gY2xhbXBlZFNhbmtleUxpbmtIb3Jpem9udGFsKCkoZCkgfHwgJyc7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgIGtleT17YGRlYnVnLWxpbmstJHtpfWB9XG4gICAgICAgICAgICAgICAgICBkPXtwYXRofVxuICAgICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiY3lhblwiXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbiAgICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM9XCJub25lXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9nPlxuICAgICAgICApfVxuICAgICAgPC9zdmc+XG4gICAgICB7dG9vbHRpcEVsfVxuICAgIDwvZGl2PlxuICApO1xufSAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsImQzIiwic2Fua2V5IiwidXNlVmlzdWFsaXphdGlvbkRhdGEiLCJnZXRZZWFyc0NhdGVnb3J5IiwiZ2V0Tm9kZUNvbG9yIiwidXNlQXBwQ29udGV4dCIsImF2YWlsYWJsZUZpZWxkcyIsInZhbHVlIiwibGFiZWwiLCJZRUFSU19DQVRFR09SSUVTIiwiZ2V0VmFsaWRZZWFyc0NhdGVnb3J5IiwieWVhcnMiLCJpc05hTiIsInNhbmtleUxpbmtXYXZlIiwiZCIsIndhdmVBbXBsaXR1ZGUiLCJ3YXZlRnJlcXVlbmN5IiwiY2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0IiwieDAiLCJzb3VyY2UiLCJ4MSIsInRhcmdldCIsInkwIiwieTEiLCJNYXRoIiwibWF4IiwibWluIiwibWlkWCIsIndhdmVZMCIsInNpbiIsIlBJIiwid2F2ZVkxIiwiY2xhbXBlZFNhbmtleUxpbmtIb3Jpem9udGFsIiwic3kiLCJ0eSIsImN1cnZhdHVyZSIsInhpIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJ4MiIsIngzIiwiQWxsdXZpYWxEaWFncmFtIiwid2lkdGgiLCJoZWlnaHQiLCJhdXRvUGxheSIsIm9uUXVlc3Rpb25DaGFuZ2UiLCJjb250YWluZXJSZWYiLCJjb250YWluZXJXaWR0aCIsInNldENvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0Iiwic2V0Q29udGFpbmVySGVpZ2h0IiwiY3VycmVudCIsIm9ic2VydmVyIiwid2luZG93IiwiUmVzaXplT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZW50cnkiLCJjb250ZW50UmVjdCIsIm9ic2VydmUiLCJkaXNjb25uZWN0Iiwic3ZnUmVmIiwiZGF0YSIsImlzTG9hZGluZyIsImVycm9yIiwic2V0dGluZ3MiLCJnZXRDdXJyZW50VGhlbWVDb2xvcnMiLCJjdXJyZW50U291cmNlIiwic2V0Q3VycmVudFNvdXJjZSIsImN1cnJlbnRUYXJnZXQiLCJzZXRDdXJyZW50VGFyZ2V0IiwiZmlsdGVyZWREYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwidXNlVGVzdERhdGEiLCJmaWx0ZXIiLCJpdGVtIiwidGVzdF9kYXRhIiwic291cmNlcyIsImNhdCIsInNvbWUiLCJ5ZWFyc19hdF9tZWR0cm9uaWMiLCJmcm9tIiwiU2V0IiwibWFwIiwidGFyZ2V0cyIsInNvcnQiLCJNSU5fQ0hBUlRfSEVJR0hUIiwiTUFYX0NIQVJUX0hFSUdIVCIsIk1JTl9DSEFSVF9XSURUSCIsIk1BWF9DSEFSVF9XSURUSCIsIm5vZGVDb3VudCIsImF2YWlsYWJsZUhlaWdodCIsIm1pbk5vZGVIZWlnaHQiLCJtYXhOb2RlSGVpZ2h0IiwibWluUGFkZGluZyIsIm5vZGVIZWlnaHQiLCJmbG9vciIsIm5vZGVQYWRkaW5nIiwibGFiZWxGb250U2l6ZSIsIm1lYXN1cmVUZXh0V2lkdGgiLCJ0ZXh0IiwiZm9udCIsIl9jYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjYW52YXMiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsIm1lYXN1cmVUZXh0IiwibGFiZWxGb250IiwiYWxsTGFiZWxzIiwibGFiZWxXaWR0aHMiLCJtYXhMYWJlbFdpZHRoIiwibGFiZWxQYWRkaW5nIiwibWFyZ2luIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiY29uc29sZSIsImxvZyIsImN1cnJlbnRTb3VyY2VSZWYiLCJjdXJyZW50VGFyZ2V0UmVmIiwiaW5zaWdodHMiLCJzZXRJbnNpZ2h0cyIsImhvdmVyZWROb2RlIiwic2V0SG92ZXJlZE5vZGUiLCJob3ZlcmVkTGluayIsInNldEhvdmVyZWRMaW5rIiwidG9vbHRpcCIsInNldFRvb2x0aXAiLCJsYXN0Q2F0ZWdvcnlDaGFuZ2UiLCJzZXRMYXN0Q2F0ZWdvcnlDaGFuZ2UiLCJjdXJyZW50VGFyZ2V0SW5kZXgiLCJzZXRDdXJyZW50VGFyZ2V0SW5kZXgiLCJpc0FuaW1hdGluZyIsInNldElzQW5pbWF0aW5nIiwiaG92ZXJlZFNvdXJjZUluZGV4Iiwic2V0SG92ZXJlZFNvdXJjZUluZGV4IiwiaG92ZXJlZFRhcmdldEluZGV4Iiwic2V0SG92ZXJlZFRhcmdldEluZGV4IiwiaXNJbkZ1bGxPcGFjaXR5U3RhdGUiLCJzZXRJc0luRnVsbE9wYWNpdHlTdGF0ZSIsImFuaW1hdGlvblBoYXNlIiwic2V0QW5pbWF0aW9uUGhhc2UiLCJhbmltYXRpb25SZWYiLCJ0aW1lciIsInJ1bm5pbmciLCJjdXJyZW50U291cmNlSW5kZXgiLCJpc1BhdXNlZCIsInBhdXNlZEF0IiwiRGF0ZSIsIm5vdyIsInJlc3VtZUZyb20iLCJjeWNsZUNvdW50IiwicHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImJhc2VTcGVlZCIsImF1dG9QbGF5U3BlZWQiLCJyZWR1Y3Rpb25GYWN0b3IiLCJzdGVwRHVyYXRpb24iLCJwYXVzZUR1cmF0aW9uIiwiY2F0ZWdvcnlQYXVzZUR1cmF0aW9uIiwibGlua1RyYW5zaXRpb25EdXJhdGlvbiIsInNvcnRlZFNvdXJjZXMiLCJzb3VyY2VzRm9yTm9kZXMiLCJhIiwiYiIsImluZGV4T2YiLCJub2RlcyIsIm5hbWUiLCJpZCIsImNhdGVnb3J5IiwibGlua3NNYXAiLCJNYXAiLCJmb3JFYWNoIiwiaW5jbHVkZXMiLCJzb3VyY2VJZCIsInRhcmdldElkIiwia2V5IiwiaGFzIiwic2V0IiwiZ2V0IiwibGlua3MiLCJ2YWx1ZXMiLCJzYW5rZXlHZW5lcmF0b3IiLCJub2RlSWQiLCJub2RlV2lkdGgiLCJleHRlbnQiLCJzYW5rZXlEYXRhIiwic291cmNlTm9kZXMiLCJhbmltYXRlIiwiZGF0YUxlbmd0aCIsInRhcmdldE9wdGlvbnMiLCJmIiwic291cmNlSW5kZXgiLCJ0YXJnZXRJbmRleCIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwic291cmNlT3B0aW9ucyIsInNvdXJjZVByb2dyZXNzIiwidGFyZ2V0UHJvZ3Jlc3MiLCJpc0xhc3RTb3VyY2UiLCJoYXNNb3JlVGFyZ2V0cyIsIm5leHRUaW1lb3V0IiwicHJvZ3Jlc3MiLCJzZXRUaW1lb3V0IiwidGFyZ2V0T3B0aW9uc0xlbmd0aCIsImF2YWlsYWJsZVRhcmdldHMiLCJjbGVhclRpbWVvdXQiLCJuZXh0VGFyZ2V0IiwicHJldmlvdXNUYXJnZXQiLCJhbGxUYXJnZXRPcHRpb25zIiwibmV4dFNvdXJjZUluZGV4IiwibmV4dFNvdXJjZSIsIm5ld1RhcmdldE9wdGlvbnMiLCJmaXJzdFRhcmdldCIsImlzQXV0b1BsYXlFbmFibGVkIiwic3ZnUmVmRXhpc3RzIiwiaXNSdW5uaW5nIiwic291cmNlQ2F0ZWdvcnkiLCJ0b3RhbFNvdXJjZXMiLCJ0b3RhbFRhcmdldHMiLCJzcGVlZCIsIm5vZGVMYWJlbEZvbnRTaXplIiwibm9kZUxhYmVsRm9udFdlaWdodCIsIm5vZGVMYWJlbENvbG9yIiwiaXNEYXJrTW9kZSIsIm5vZGVMYWJlbEZvbnRGYW1pbHkiLCJub2RlTGFiZWxPZmZzZXQiLCJsb2NhbERlYnVnIiwic2V0TG9jYWxEZWJ1ZyIsInNob3dUaGVtZVRvZ2dsZSIsInNldFNob3dUaGVtZVRvZ2dsZSIsImRlYnVnT24iLCJkZWJ1Z1NhbmtleURhdGEiLCJzZXREZWJ1Z1NhbmtleURhdGEiLCJzdmciLCJzZWxlY3QiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJhdHRyIiwic29ydGVkVGFyZ2V0cyIsInNvdXJjZUFjY2Vzc29yIiwidGFyZ2V0QWNjZXNzb3IiLCJ2YWxpZERhdGEiLCJpc0R1bW15IiwibGluayIsImxlZnRUb3RhbHMiLCJsIiwicmVkdWNlIiwic3VtIiwicmlnaHRUb3RhbHMiLCJsZWZ0U3VtIiwicmlnaHRTdW0iLCJsZWZ0U2NhbGUiLCJyaWdodFNjYWxlIiwicyIsInQiLCJkeW5hbWljTm9kZVBhZGRpbmciLCJsZWZ0Tm9kZXMiLCJuIiwicmlnaHROb2RlcyIsImV2ZXJ5IiwiaSIsImVudGVyIiwiYXBwZW5kIiwibG93ZXIiLCJub2RlWXMiLCJmbGF0IiwibWluWSIsIm1heFkiLCJ1c2VkSGVpZ2h0Iiwib2Zmc2V0WSIsImciLCJkZWZzIiwiZW1wdHkiLCJsaW5rc0ciLCJub2Rlc0ciLCJnbG93RmlsdGVyIiwiZmVNZXJnZSIsImZpbHRlcmVkTGlua3MiLCJzdHlsZSIsImxpbmtLZXkiLCJsaW5rU2VsIiwiZXhpdCIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImlzQ2F0ZWdvcnlDaGFuZ2UiLCJuZXdMaW5rcyIsImJhc2VPcGFjaXR5IiwiaGlnaGxpZ2h0T3BhY2l0eSIsImRpbU9wYWNpdHkiLCJob3ZlcmVkU291cmNlIiwiaG92ZXJlZFRhcmdldCIsImVhY2giLCJwYXRoIiwidG90YWxMZW5ndGgiLCJnZXRUb3RhbExlbmd0aCIsImRlbGF5IiwiZWFzZSIsImVhc2VDdWJpY0luT3V0Iiwib24iLCJldmVudCIsIngiLCJvZmZzZXRYIiwieSIsImNvbnRlbnQiLCJkaXYiLCJjbGFzc05hbWUiLCJmaWx0ZXJlZE5vZGVzIiwibm9kZVNlbCIsImpvaW4iLCJpc0Nvbm5lY3RlZCIsImlkeCIsInVwZGF0ZSIsImxhYmVsTGF5ZXIiLCJzb3VyY2VOb2RlU2V0IiwidGFyZ2V0Tm9kZVNldCIsInRhcmdldE5vZGVzIiwibm9kZSIsIm1vc3RDb21tb24iLCJ1bmRlZmluZWQiLCJ0aXRsZSIsInNwbGl0IiwiZGVzY3JpcHRpb24iLCJjYXRlZ29yeUNvbG9ycyIsInNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHQiLCJzb3J0ZWQiLCJpc0hvdmVyZWQiLCJ0b29sdGlwVmlzaWJsZSIsInNldFRvb2x0aXBWaXNpYmxlIiwidG9vbHRpcFRpbWVvdXRSZWYiLCJ0b29sdGlwRWwiLCJwb3NpdGlvbiIsImJhY2tncm91bmQiLCJjb2xvciIsInBhZGRpbmciLCJib3JkZXJSYWRpdXMiLCJwb2ludGVyRXZlbnRzIiwiekluZGV4IiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJmb250U2l6ZSIsImJveFNoYWRvdyIsImJvcmRlciIsIm1heFdpZHRoIiwid2hpdGVTcGFjZSIsIm92ZXJmbG93IiwidGV4dE92ZXJmbG93Iiwib3BhY2l0eSIsInJvbGUiLCJhcmlhLWxpdmUiLCJzb3J0ZWRTb3VyY2VzRm9ySGlnaGxpZ2h0IiwidmlzdWFsT3JkZXIiLCJzbGljZSIsImhpZ2hsaWdodFNvdXJjZU5hbWUiLCJoaWdobGlnaHRUYXJnZXROYW1lIiwicGF1c2VBbmltYXRpb24iLCJyZWFzb24iLCJyZXN1bWVBbmltYXRpb24iLCJwYXVzZWREdXJhdGlvbiIsInJlZiIsIm1pbkhlaWdodCIsIm1pbldpZHRoIiwidHJhbnNmb3JtIiwidmlld0JveCIsImRpc3BsYXkiLCJyZWN0IiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZVdpZHRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/DataVisualization/AlluvialDiagram.tsx\n"));

/***/ })

});