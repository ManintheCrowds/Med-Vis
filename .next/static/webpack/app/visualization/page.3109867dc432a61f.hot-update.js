"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/visualization/page",{

/***/ "(app-pages-browser)/./src/components/DataVisualization/AlluvialDiagram.tsx":
/*!**************************************************************!*\
  !*** ./src/components/DataVisualization/AlluvialDiagram.tsx ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AlluvialDiagram; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\");\n/* harmony import */ var d3_sankey__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-sankey */ \"(app-pages-browser)/./node_modules/d3-sankey/src/index.js\");\n/* harmony import */ var _shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/useVisualizationData */ \"(app-pages-browser)/./src/components/DataVisualization/shared/useVisualizationData.ts\");\n/* harmony import */ var _shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shared/colorUtils */ \"(app-pages-browser)/./src/components/DataVisualization/shared/colorUtils.ts\");\n/* harmony import */ var _lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/context/AppContext */ \"(app-pages-browser)/./src/lib/context/AppContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst availableFields = [\n    {\n        value: \"years_at_medtronic\",\n        label: \"Years at Medtronic\"\n    },\n    {\n        value: \"learning_style\",\n        label: \"Learning Style\"\n    },\n    {\n        value: \"shaped_by\",\n        label: \"Shaped By\"\n    },\n    {\n        value: \"peak_performance\",\n        label: \"Peak Performance\"\n    },\n    {\n        value: \"motivation\",\n        label: \"Motivation\"\n    }\n];\nconst YEARS_CATEGORIES = [\n    \"0-5\",\n    \"6-10\",\n    \"11-15\",\n    \"16-20\",\n    \"20+\"\n];\n// Move this function up so it is defined before use\nconst getValidYearsCategory = (years)=>{\n    if (typeof years !== \"number\" || isNaN(years) || years < 0) return \"0-5\";\n    if (years <= 5) return \"0-5\";\n    if (years <= 10) return \"6-10\";\n    if (years <= 15) return \"11-15\";\n    if (years <= 20) return \"16-20\";\n    return \"20+\";\n};\n// Custom wave path generator for Sankey links with bounds checking\nfunction sankeyLinkWave(d) {\n    let waveAmplitude = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8, waveFrequency = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.1, chartWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 800, chartHeight = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 600;\n    // d has source/target: {x0, x1, y0, y1}\n    let x0 = d.source.x1;\n    let x1 = d.target.x0;\n    let y0 = d.y0;\n    let y1 = d.y1;\n    // Clamp coordinates to chart bounds to prevent overflow\n    x0 = Math.max(0, Math.min(chartWidth, x0));\n    x1 = Math.max(0, Math.min(chartWidth, x1));\n    y0 = Math.max(0, Math.min(chartHeight, y0));\n    y1 = Math.max(0, Math.min(chartHeight, y1));\n    const midX = (x0 + x1) / 2;\n    // Add a sine wave to the control points, but ensure they stay within bounds\n    const waveY0 = Math.max(0, Math.min(chartHeight, y0 + waveAmplitude * Math.sin(waveFrequency * Math.PI * 0.25)));\n    const waveY1 = Math.max(0, Math.min(chartHeight, y1 + waveAmplitude * Math.sin(waveFrequency * Math.PI * 0.75)));\n    return \"M\".concat(x0, \",\").concat(y0, \"\\n    C\").concat(midX, \",\").concat(waveY0, \" \").concat(midX, \",\").concat(waveY1, \" \").concat(x1, \",\").concat(y1);\n}\n// Note: Using theme-aware getNodeColor function from colorUtils\nfunction AlluvialDiagram(param) {\n    let { width = 800, height = 600, autoPlay = true, onQuestionChange } = param;\n    _s();\n    // Responsive: use state for width/height, fallback to props\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [containerWidth, setContainerWidth] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(width);\n    const [containerHeight, setContainerHeight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(height);\n    // Responsive: observe container size\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!containerRef.current) return;\n        const observer = new window.ResizeObserver((entries)=>{\n            for (let entry of entries){\n                if (entry.contentRect) {\n                    setContainerWidth(entry.contentRect.width);\n                    setContainerHeight(entry.contentRect.height);\n                }\n            }\n        });\n        observer.observe(containerRef.current);\n        return ()=>observer.disconnect();\n    }, []);\n    const svgRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { data, isLoading, error } = (0,_shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_4__.useVisualizationData)();\n    const { settings, getCurrentThemeColors } = (0,_lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__.useAppContext)();\n    const [currentSource, setCurrentSource] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"years_at_medtronic\");\n    const [currentTarget, setCurrentTarget] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"learning_style\");\n    // Filter data based on test data setting\n    const filteredData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!Array.isArray(data) || !data.length) return [];\n        return settings.useTestData ? data : data.filter((item)=>!item.test_data);\n    }, [\n        data,\n        settings.useTestData\n    ]);\n    // Compute sources and targets with validation\n    const sources = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!Array.isArray(filteredData) || !filteredData.length) return [];\n        if (currentSource === \"years_at_medtronic\") {\n            return YEARS_CATEGORIES.filter((cat)=>filteredData.some((d)=>getValidYearsCategory(d.years_at_medtronic || 0) === cat));\n        } else {\n            return Array.from(new Set(filteredData.map((d)=>d[currentSource]))).filter((value)=>typeof value === \"string\" && value.length > 0);\n        }\n    }, [\n        filteredData,\n        currentSource\n    ]);\n    const targets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!Array.isArray(filteredData) || !filteredData.length) return [];\n        if (currentTarget === \"years_at_medtronic\") {\n            return YEARS_CATEGORIES.filter((cat)=>filteredData.some((d)=>getValidYearsCategory(d.years_at_medtronic || 0) === cat));\n        } else {\n            // Sort target nodes consistently to maintain fixed positions\n            return Array.from(new Set(filteredData.map((d)=>currentTarget === \"years_at_medtronic\" ? getValidYearsCategory(d.years_at_medtronic || 0) : d[currentTarget]))).filter((value)=>typeof value === \"string\" && value.length > 0).sort(); // Add consistent sorting\n        }\n    }, [\n        filteredData,\n        currentTarget\n    ]);\n    // --- Responsive chart sizing based on data size ---\n    // Set sensible min/max chart dimensions\n    const MIN_CHART_HEIGHT = 180;\n    const MAX_CHART_HEIGHT = 700;\n    const MIN_CHART_WIDTH = 320;\n    const MAX_CHART_WIDTH = 1400;\n    // Calculate node count for sizing\n    const nodeCount = Math.max(sources.length, targets.length, 1);\n    // Calculate available height for nodes and paddings\n    let availableHeight = Math.max(MIN_CHART_HEIGHT, Math.min(containerHeight - 40, MAX_CHART_HEIGHT));\n    // For very sparse data, shrink the chart height\n    if (nodeCount <= 3) {\n        availableHeight = Math.max(MIN_CHART_HEIGHT, Math.min(320, availableHeight));\n    }\n    // For very dense data, allow more height\n    if (nodeCount >= 10) {\n        availableHeight = Math.min(MAX_CHART_HEIGHT, Math.max(availableHeight, 500));\n    }\n    // Node height and padding logic\n    const minNodeHeight = 16;\n    const maxNodeHeight = nodeCount <= 3 ? 36 : 48; // Smaller max for sparse data\n    const minPadding = 8;\n    let nodeHeight = Math.floor((availableHeight - (nodeCount + 1) * minPadding) / nodeCount);\n    nodeHeight = Math.max(minNodeHeight, Math.min(nodeHeight, maxNodeHeight));\n    let nodePadding = (availableHeight - nodeCount * nodeHeight) / (nodeCount + 1);\n    nodePadding = Math.max(nodePadding, minPadding);\n    // Dynamically scale label font size with node height (clamp between 12px and 28px)\n    const labelFontSize = Math.max(12, Math.min(28, Math.floor(nodeHeight * 0.5)));\n    // --- Dynamic margin calculation for full label visibility ---\n    // Helper to measure text width in px\n    function measureTextWidth(text, font) {\n        if (false) {} // fallback for SSR\n        if (!measureTextWidth._canvas) {\n            measureTextWidth._canvas = document.createElement(\"canvas\");\n        }\n        const canvas = measureTextWidth._canvas;\n        const context = canvas.getContext(\"2d\");\n        if (!context) return 100;\n        context.font = font;\n        return context.measureText(text).width;\n    }\n    // Font for measuring\n    const labelFont = \"bold \".concat(labelFontSize, \"px Avenir Next World, -apple-system, BlinkMacSystemFont, 'SF Pro', 'Roboto', sans-serif\");\n    const allLabels = [\n        ...sources,\n        ...targets\n    ];\n    const labelWidths = allLabels.map((label)=>measureTextWidth(label, labelFont));\n    const maxLabelWidth = Math.max(...labelWidths, 80); // fallback min\n    const labelPadding = 24;\n    const margin = {\n        top: 20,\n        right: maxLabelWidth + labelPadding,\n        bottom: 20,\n        left: maxLabelWidth + labelPadding\n    };\n    // Responsive chart width\n    let chartWidth = Math.max(MIN_CHART_WIDTH, Math.min(containerWidth - margin.left - margin.right, MAX_CHART_WIDTH));\n    let chartHeight = availableHeight;\n    // If very sparse, shrink width too\n    if (nodeCount <= 3) {\n        chartWidth = Math.max(MIN_CHART_WIDTH, Math.min(chartWidth, 480));\n    }\n    // If very dense, allow more width\n    if (nodeCount >= 10) {\n        chartWidth = Math.min(MAX_CHART_WIDTH, Math.max(chartWidth, 900));\n    }\n    // Debug logging\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"[AlluvialDiagram Debug]\");\n        console.log(\"  Container:\", containerWidth, \"x\", containerHeight);\n        console.log(\"  Chart:\", chartWidth, \"x\", chartHeight);\n        console.log(\"  Node count (sources/targets):\", sources.length, targets.length);\n        console.log(\"  nodeHeight:\", nodeHeight);\n        console.log(\"  nodePadding:\", nodePadding);\n        console.log(\"  labelFontSize:\", labelFontSize);\n    }, [\n        containerWidth,\n        containerHeight,\n        chartWidth,\n        chartHeight,\n        sources.length,\n        targets.length,\n        nodeHeight,\n        nodePadding,\n        labelFontSize\n    ]);\n    // Use refs to track current values without triggering re-renders\n    const currentSourceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(currentSource);\n    const currentTargetRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(currentTarget);\n    // Update refs when state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentSourceRef.current = currentSource;\n    }, [\n        currentSource\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentTargetRef.current = currentTarget;\n    }, [\n        currentTarget\n    ]);\n    const [insights, setInsights] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [hoveredNode, setHoveredNode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [hoveredLink, setHoveredLink] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [tooltip, setTooltip] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [lastCategoryChange, setLastCategoryChange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        source: currentSource,\n        target: currentTarget\n    });\n    const [currentTargetIndex, setCurrentTargetIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [isAnimating, setIsAnimating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [hoveredSourceIndex, setHoveredSourceIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [hoveredTargetIndex, setHoveredTargetIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isInFullOpacityState, setIsInFullOpacityState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [animationPhase, setAnimationPhase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"full\");\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        timer: null,\n        running: false,\n        currentSourceIndex: 0,\n        currentTargetIndex: 0,\n        isPaused: false,\n        pausedAt: Date.now(),\n        resumeFrom: null,\n        cycleCount: 0\n    });\n    // Check for reduced motion preference\n    const prefersReducedMotion = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (false) {}\n        return window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\n    }, []);\n    // Adjust animation durations based on motion preference\n    const animationDurations = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const baseSpeed = settings.autoPlaySpeed || 3000;\n        const reductionFactor = prefersReducedMotion ? 0.5 : 1;\n        return {\n            stepDuration: Math.max(800, baseSpeed / 8 * reductionFactor),\n            pauseDuration: Math.max(400, baseSpeed / 12 * reductionFactor),\n            categoryPauseDuration: Math.max(1500, baseSpeed / 3 * reductionFactor),\n            linkTransitionDuration: prefersReducedMotion ? 400 : 750\n        };\n    }, [\n        settings.autoPlaySpeed,\n        prefersReducedMotion\n    ]);\n    // Get visual order of source nodes (top-to-bottom as they appear)\n    const sortedSources = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!filteredData.length || !chartWidth || !chartHeight) return sources;\n        const sourcesForNodes = [\n            ...sources\n        ];\n        if (currentSource === \"years_at_medtronic\") {\n            sourcesForNodes.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sourcesForNodes.sort();\n        }\n        // Create Sankey layout to get visual order\n        const nodes = [\n            ...sourcesForNodes.map((name)=>({\n                    id: \"\".concat(currentSource, \":\").concat(name),\n                    name,\n                    category: currentSource\n                })),\n            ...targets.map((name)=>({\n                    id: \"\".concat(currentTarget, \":\").concat(name),\n                    name,\n                    category: currentTarget\n                }))\n        ];\n        const linksMap = new Map();\n        filteredData.forEach((d)=>{\n            const source = currentSource === \"years_at_medtronic\" ? getValidYearsCategory(d.years_at_medtronic || 0) : d[currentSource];\n            const target = currentTarget === \"years_at_medtronic\" ? getValidYearsCategory(d.years_at_medtronic || 0) : d[currentTarget];\n            if (!sourcesForNodes.includes(source) || !targets.includes(target)) return;\n            const sourceId = \"\".concat(currentSource, \":\").concat(source);\n            const targetId = \"\".concat(currentTarget, \":\").concat(target);\n            const key = \"\".concat(sourceId, \"→\").concat(targetId);\n            if (!linksMap.has(key)) {\n                linksMap.set(key, {\n                    source: sourceId,\n                    target: targetId,\n                    value: 0\n                });\n            }\n            linksMap.get(key).value += 1;\n        });\n        const links = Array.from(linksMap.values());\n        const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(nodePadding).extent([\n            [\n                0,\n                0\n            ],\n            [\n                chartWidth,\n                chartHeight\n            ]\n        ]);\n        const sankeyData = sankeyGenerator({\n            nodes: nodes.map((d)=>({\n                    ...d\n                })),\n            links: links.map((d)=>({\n                    ...d\n                }))\n        });\n        // Get source nodes in visual order (top to bottom)\n        const sourceNodes = sankeyData.nodes.filter((d)=>d.category === currentSource).sort((a, b)=>a.y0 - b.y0);\n        return sourceNodes.map((d)=>d.name);\n    }, [\n        filteredData,\n        sources,\n        targets,\n        currentSource,\n        currentTarget,\n        chartWidth,\n        chartHeight,\n        nodePadding\n    ]);\n    // Enhanced animation function with comprehensive debug tracking\n    const animate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        // Check if animation is paused\n        if (animationRef.current.isPaused) {\n            console.log(\"⏸️  Animation is paused, skipping cycle\");\n            return;\n        }\n        if (!animationRef.current.running || !filteredData.length) {\n            console.log(\"❌ Animation stopped:\", {\n                running: animationRef.current.running,\n                dataLength: filteredData.length\n            });\n            return;\n        }\n        // Safety check: prevent infinite loops\n        if (animationRef.current.cycleCount > 1000) {\n            console.log(\"\\uD83D\\uDED1 Animation cycle limit reached, resetting\");\n            animationRef.current.cycleCount = 0;\n            animationRef.current.currentSourceIndex = 0;\n            animationRef.current.currentTargetIndex = 0;\n        }\n        // Increment cycle counter\n        animationRef.current.cycleCount++;\n        // Set animation phase to highlighting\n        setAnimationPhase(\"highlighting\");\n        setIsInFullOpacityState(false);\n        // Set the hovered source index to match the animation\n        setHoveredSourceIndex(animationRef.current.currentSourceIndex);\n        const targetOptions = availableFields.filter((f)=>f.value !== currentSourceRef.current).map((f)=>f.value);\n        // Debug: Log the target options to verify they're correct\n        if (animationRef.current.currentSourceIndex === 0) {\n            console.log(\"\\uD83C\\uDFAF Available target options for\", currentSourceRef.current, \":\", targetOptions);\n        }\n        // COMPREHENSIVE DEBUG: Log current state with full detail\n        console.log(\"\\uD83D\\uDD0D ANIMATION CYCLE DEBUG:\", {\n            \"\\uD83D\\uDCCD Current Position\": {\n                sourceIndex: animationRef.current.currentSourceIndex,\n                targetIndex: animationRef.current.currentTargetIndex,\n                sourceName: sortedSources[animationRef.current.currentSourceIndex],\n                targetName: currentTargetRef.current\n            },\n            \"\\uD83D\\uDCCA Categories\": {\n                currentSource: currentSourceRef.current,\n                currentTarget: currentTargetRef.current,\n                sourceOptions: availableFields.map((f)=>f.value),\n                targetOptions\n            },\n            \"\\uD83D\\uDCC8 Progress\": {\n                sourceProgress: \"\".concat(animationRef.current.currentSourceIndex + 1, \"/\").concat(sortedSources.length),\n                targetProgress: \"\".concat(animationRef.current.currentTargetIndex + 1, \"/\").concat(targetOptions.length),\n                isLastSource: animationRef.current.currentSourceIndex >= sortedSources.length - 1,\n                hasMoreTargets: animationRef.current.currentTargetIndex < targetOptions.length - 1\n            },\n            \"\\uD83C\\uDFAF Sources\": sortedSources,\n            \"\\uD83C\\uDFAF Targets\": targetOptions,\n            \"⏱️  Timings\": animationDurations\n        });\n        if (animationRef.current.currentSourceIndex < sortedSources.length - 1) {\n            // Move to next source\n            const nextTimeout = animationDurations.stepDuration + animationDurations.pauseDuration;\n            const progress = \"\".concat(animationRef.current.currentSourceIndex + 1, \"/\").concat(sortedSources.length);\n            console.log(\"\\uD83C\\uDFAF Source \".concat(progress, \": Highlighting '\").concat(sortedSources[animationRef.current.currentSourceIndex], \"' → '\").concat(currentTargetRef.current, \"' for \").concat(nextTimeout, \"ms\"));\n            animationRef.current.timer = setTimeout(()=>{\n                if (!animationRef.current.running || animationRef.current.isPaused) return;\n                animationRef.current.currentSourceIndex++;\n                animate();\n            }, nextTimeout);\n        } else {\n            // After last source, check if we need to cycle targets or change source category\n            console.log(\"\\uD83D\\uDD0D END OF SOURCES - Checking target cycling:\", {\n                currentTargetIndex: animationRef.current.currentTargetIndex,\n                targetOptionsLength: targetOptions.length,\n                hasMoreTargets: animationRef.current.currentTargetIndex < targetOptions.length - 1,\n                availableTargets: targetOptions\n            });\n            if (animationRef.current.currentTargetIndex < targetOptions.length - 1) {\n                // Still have more target categories to cycle through\n                const targetProgress = \"\".concat(animationRef.current.currentTargetIndex + 2, \"/\").concat(targetOptions.length);\n                console.log(\"\\uD83D\\uDD04 ✅ COMPLETED ALL SOURCES for '\".concat(currentTargetRef.current, \"', moving to next target (\").concat(targetProgress, \")\"));\n                // Clear any existing timer to prevent conflicts\n                if (animationRef.current.timer) {\n                    clearTimeout(animationRef.current.timer);\n                    animationRef.current.timer = null;\n                }\n                animationRef.current.timer = setTimeout(()=>{\n                    if (!animationRef.current.running || animationRef.current.isPaused) return;\n                    setAnimationPhase(\"transitioning\");\n                    // Move to next target category\n                    animationRef.current.currentTargetIndex++;\n                    const nextTarget = targetOptions[animationRef.current.currentTargetIndex];\n                    console.log(\"\\uD83C\\uDFAF ✨ NEW TARGET CATEGORY:\", nextTarget, \"(\".concat(animationRef.current.currentTargetIndex + 1, \"/\").concat(targetOptions.length, \")\"));\n                    console.log(\"\\uD83D\\uDD0D Target progression debug:\", {\n                        previousTarget: currentTargetRef.current,\n                        nextTarget,\n                        currentTargetIndex: animationRef.current.currentTargetIndex,\n                        allTargetOptions: targetOptions\n                    });\n                    setCurrentTarget(nextTarget);\n                    setLastCategoryChange({\n                        source: currentSourceRef.current,\n                        target: nextTarget\n                    });\n                    onQuestionChange === null || onQuestionChange === void 0 ? void 0 : onQuestionChange(currentSourceRef.current, nextTarget);\n                    // Reset source index and restart with new target\n                    animationRef.current.currentSourceIndex = 0;\n                    // Start the next cycle after a brief pause\n                    setTimeout(()=>{\n                        if (animationRef.current.running && !animationRef.current.isPaused) {\n                            animate();\n                        }\n                    }, animationDurations.categoryPauseDuration);\n                }, animationDurations.categoryPauseDuration);\n            } else {\n                // We've cycled through all targets, now change the source category\n                console.log(\"\\uD83D\\uDD04 ✨ COMPLETED ALL TARGETS for '\".concat(currentSourceRef.current, \"' - Moving to next source category! ✨\"));\n                // Clear any existing timer to prevent conflicts\n                if (animationRef.current.timer) {\n                    clearTimeout(animationRef.current.timer);\n                    animationRef.current.timer = null;\n                }\n                animationRef.current.timer = setTimeout(()=>{\n                    if (!animationRef.current.running || animationRef.current.isPaused) return;\n                    setAnimationPhase(\"transitioning\");\n                    // Move to next source category\n                    const sourceOptions = availableFields.map((f)=>f.value);\n                    const currentSourceIndex = sourceOptions.indexOf(currentSourceRef.current);\n                    const nextSourceIndex = (currentSourceIndex + 1) % sourceOptions.length;\n                    const nextSource = sourceOptions[nextSourceIndex];\n                    console.log(\"\\uD83C\\uDFAF \\uD83C\\uDD95 NEW SOURCE CATEGORY:\", nextSource, \"- Starting fresh cycle with all targets\");\n                    // Calculate target options for the NEW source (including years_at_medtronic)\n                    const newTargetOptions = availableFields.filter((f)=>f.value !== nextSource).map((f)=>f.value);\n                    console.log(\"\\uD83D\\uDD0D New target options for\", nextSource, \":\", newTargetOptions);\n                    setCurrentSource(nextSource);\n                    // Reset both indices and start with first target again\n                    animationRef.current.currentSourceIndex = 0;\n                    animationRef.current.currentTargetIndex = 0;\n                    const firstTarget = newTargetOptions[0];\n                    setCurrentTarget(firstTarget);\n                    setLastCategoryChange({\n                        source: nextSource,\n                        target: firstTarget\n                    });\n                    onQuestionChange === null || onQuestionChange === void 0 ? void 0 : onQuestionChange(nextSource, firstTarget);\n                    // Start the next cycle after a longer pause\n                    setTimeout(()=>{\n                        if (animationRef.current.running && !animationRef.current.isPaused) {\n                            animate();\n                        }\n                    }, animationDurations.categoryPauseDuration * 1.5); // Longer pause for source category change\n                }, animationDurations.categoryPauseDuration);\n            }\n        }\n    }, [\n        data.length,\n        sortedSources.length,\n        onQuestionChange,\n        animationDurations,\n        availableFields\n    ]);\n    // Animation effect - restart when settings change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"\\uD83C\\uDFAC Animation useEffect triggered:\", {\n            autoPlay,\n            isAutoPlayEnabled: settings.isAutoPlayEnabled,\n            dataLength: data.length,\n            svgRefExists: !!svgRef.current,\n            currentSource,\n            currentTarget,\n            autoPlaySpeed: settings.autoPlaySpeed,\n            isRunning: animationRef.current.running\n        });\n        if (!autoPlay || !settings.isAutoPlayEnabled) {\n            console.log(\"❌ Animation disabled\");\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n            setAnimationPhase(\"full\");\n            setIsInFullOpacityState(true);\n            return;\n        }\n        if (!filteredData.length) {\n            console.log(\"❌ No data available for animation\");\n            return;\n        }\n        if (!svgRef.current) {\n            console.log(\"❌ SVG ref not available\");\n            return;\n        }\n        // Restart animation when speed changes or on major changes\n        if (animationRef.current.running) {\n            console.log(\"\\uD83D\\uDD04 Restarting animation with new settings:\", {\n                sourceCategory: currentSource,\n                totalSources: sortedSources.length,\n                totalTargets: availableFields.filter((f)=>f.value !== currentSource).length,\n                speed: settings.autoPlaySpeed + \"ms\"\n            });\n            // Stop current animation\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n        }\n        // Start new animation cycle\n        console.log(\"✅ Starting animation cycle:\", {\n            sourceCategory: currentSource,\n            totalSources: sortedSources.length,\n            totalTargets: availableFields.filter((f)=>f.value !== currentSource).length,\n            speed: settings.autoPlaySpeed + \"ms\"\n        });\n        // Initialize animation state\n        animationRef.current.running = true;\n        animationRef.current.currentSourceIndex = 0;\n        animationRef.current.currentTargetIndex = 0;\n        animationRef.current.cycleCount = 0; // Reset cycle counter\n        // Start animation\n        animate();\n        return ()=>{\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n            animationRef.current.running = false;\n            setAnimationPhase(\"full\");\n            setIsInFullOpacityState(true);\n        };\n    }, [\n        autoPlay,\n        settings.isAutoPlayEnabled,\n        settings.autoPlaySpeed,\n        filteredData.length,\n        currentSource // Only restart on source changes, not target changes\n    ]);\n    const nodeLabelFontSize = 18; // larger for readability\n    const nodeLabelFontWeight = 700;\n    const nodeLabelColor = settings.isDarkMode ? \"#FFFFFF\" : \"#170F5F\";\n    const nodeLabelFontFamily = 'Avenir Next World, -apple-system, BlinkMacSystemFont, \"SF Pro\", \"Roboto\", sans-serif';\n    const nodeLabelOffset = 24;\n    // Local debug toggle for this component if no global admin context\n    const [localDebug, setLocalDebug] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showThemeToggle, setShowThemeToggle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const debugOn = localDebug;\n    // Debug Sankey data for outlines\n    const [debugSankeyData, setDebugSankeyData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!Array.isArray(sources) || !Array.isArray(targets)) return;\n        const nodes = [\n            ...sources.map((name)=>({\n                    id: \"source:\".concat(name),\n                    name,\n                    category: \"source\"\n                })),\n            ...targets.map((name)=>({\n                    id: \"target:\".concat(name),\n                    name,\n                    category: \"target\"\n                }))\n        ];\n        // Only create links if both sides have at least one node\n        const links = sources.length && targets.length ? [\n            {\n                source: \"source:\".concat(sources[0]),\n                target: \"target:\".concat(targets[0]),\n                value: 1\n            }\n        ] : [];\n        if (nodes.length < 2 || links.length < 1) return; // Prevent invalid array length\n        const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(nodePadding).extent([\n            [\n                0,\n                0\n            ],\n            [\n                chartWidth,\n                chartHeight\n            ]\n        ]);\n        const sankeyData = sankeyGenerator({\n            nodes: nodes.map((d)=>({\n                    ...d\n                })),\n            links: links.map((d)=>({\n                    ...d\n                }))\n        });\n        setDebugSankeyData(sankeyData);\n    }, [\n        sources,\n        targets,\n        chartWidth,\n        chartHeight,\n        nodePadding\n    ]);\n    // Render Sankey diagram\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current || !filteredData.length) return;\n        // --- Persistent SVG structure ---\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        svg.selectAll(\"*\").remove(); // Clear previous content\n        svg.attr(\"width\", containerWidth).attr(\"height\", containerHeight);\n        // --- Sankey node/link creation and vertical centering (deduplicated) ---\n        // Sort source nodes to maintain a fixed order (same as animation)\n        const sortedSources = [\n            ...sources\n        ];\n        if (currentSource === \"years_at_medtronic\") {\n            sortedSources.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sortedSources.sort();\n        }\n        // Sort target nodes to maintain a fixed order\n        const sortedTargets = [\n            ...targets\n        ];\n        if (currentTarget === \"years_at_medtronic\") {\n            sortedTargets.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sortedTargets.sort();\n        }\n        // Sankey transformation accessors\n        const sourceAccessor = (d)=>currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentSource];\n        const targetAccessor = (d)=>currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentTarget];\n        // Filter data to only include valid values\n        const validData = filteredData.filter((d)=>(currentSource !== \"years_at_medtronic\" || d.years_at_medtronic !== null) && (currentTarget !== \"years_at_medtronic\" || d.years_at_medtronic !== null));\n        // Build nodes array with unique ids\n        const nodes = [\n            ...sortedSources.map((name)=>({\n                    id: \"\".concat(currentSource, \":\").concat(name),\n                    name,\n                    category: currentSource\n                })),\n            ...sortedTargets.map((name)=>({\n                    id: \"\".concat(currentTarget, \":\").concat(name),\n                    name,\n                    category: currentTarget\n                }))\n        ];\n        // Build links array (aggregate counts for each source-target pair)\n        const linksMap = new Map();\n        // 1. For every possible source-target pair, create a link (dummy if no data)\n        sortedSources.forEach((source)=>{\n            sortedTargets.forEach((target)=>{\n                const sourceId = \"\".concat(currentSource, \":\").concat(source);\n                const targetId = \"\".concat(currentTarget, \":\").concat(target);\n                const key = \"\".concat(sourceId, \"→\").concat(targetId);\n                linksMap.set(key, {\n                    source: sourceId,\n                    target: targetId,\n                    value: 0,\n                    isDummy: true\n                });\n            });\n        });\n        // 2. Fill in real data, marking links as not dummy\n        validData.forEach((d)=>{\n            const source = sourceAccessor(d);\n            const target = targetAccessor(d);\n            if (!sortedSources.includes(source) || !sortedTargets.includes(target)) return;\n            const sourceId = \"\".concat(currentSource, \":\").concat(source);\n            const targetId = \"\".concat(currentTarget, \":\").concat(target);\n            const key = \"\".concat(sourceId, \"→\").concat(targetId);\n            if (!linksMap.has(key)) {\n                linksMap.set(key, {\n                    source: sourceId,\n                    target: targetId,\n                    value: 1,\n                    isDummy: false\n                });\n            } else {\n                const link = linksMap.get(key);\n                link.value += 1;\n                link.isDummy = false;\n            }\n        });\n        // 3. Set dummy links to a very small value if still dummy\n        Array.from(linksMap.values()).forEach((link)=>{\n            if (link.isDummy) link.value = 0.0001;\n        });\n        const links = Array.from(linksMap.values());\n        // Sankey layout\n        const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(nodePadding).extent([\n            [\n                0,\n                0\n            ],\n            [\n                chartWidth,\n                chartHeight\n            ]\n        ]);\n        const sankeyData = sankeyGenerator({\n            nodes: nodes.map((d)=>({\n                    ...d\n                })),\n            links: links.map((d)=>({\n                    ...d\n                }))\n        });\n        // Compute vertical offset to center the diagram\n        const nodeYs = sankeyData.nodes.map((d)=>[\n                d.y0,\n                d.y1\n            ]).flat();\n        const minY = Math.min(...nodeYs);\n        const maxY = Math.max(...nodeYs);\n        const usedHeight = maxY - minY;\n        const offsetY = Math.max(0, (chartHeight - usedHeight) / 2 - minY);\n        // Create a group for the chart area with margin translation and vertical centering\n        const g = svg.append(\"g\").attr(\"transform\", \"translate(\".concat(margin.left, \",\").concat(margin.top + offsetY, \")\"));\n        let defs = svg.select(\"defs\");\n        if (defs.empty()) defs = svg.append(\"defs\");\n        let linksG = g.append(\"g\").attr(\"class\", \"links\");\n        let nodesG = g.append(\"g\").attr(\"class\", \"nodes\");\n        // Remove old gradients (no longer needed)\n        defs.selectAll(\"linearGradient.link-gradient\").remove();\n        // --- Add clipPath for links group with tighter bounds ---\n        svg.select(\"defs\").selectAll(\"#link-clip\").remove();\n        defs.append(\"clipPath\").attr(\"id\", \"link-clip\").append(\"rect\").attr(\"x\", margin.left).attr(\"y\", margin.top).attr(\"width\", chartWidth).attr(\"height\", chartHeight);\n        linksG.attr(\"clip-path\", \"url(#link-clip)\");\n        // Add glow filter for dark mode\n        defs.selectAll(\"#dark-mode-glow\").remove();\n        if (settings.isDarkMode) {\n            const glowFilter = defs.append(\"filter\").attr(\"id\", \"dark-mode-glow\").attr(\"x\", \"-50%\").attr(\"y\", \"-50%\").attr(\"width\", \"200%\").attr(\"height\", \"200%\");\n            glowFilter.append(\"feGaussianBlur\").attr(\"stdDeviation\", \"1.5\").attr(\"result\", \"coloredBlur\");\n            const feMerge = glowFilter.append(\"feMerge\");\n            feMerge.append(\"feMergeNode\").attr(\"in\", \"coloredBlur\");\n            feMerge.append(\"feMergeNode\").attr(\"in\", \"SourceGraphic\");\n        }\n        // --- Links update pattern ---\n        // All links are now between real nodes, with isDummy property for visual distinction\n        const filteredLinks = sankeyData.links;\n        // Remove mix-blend-mode in dark mode to prevent color washing out\n        linksG.style(\"mix-blend-mode\", settings.isDarkMode ? \"normal\" : \"multiply\");\n        const linkKey = (d)=>\"\".concat(d.source.id, \"→\").concat(d.target.id);\n        const linkSel = linksG.selectAll(\"path\").data(filteredLinks, linkKey);\n        // EXIT: fade out and remove all old links\n        linkSel.exit().transition().duration(400).attr(\"opacity\", 0).remove();\n        // Check if this is a category change that should trigger animation\n        const isCategoryChange = lastCategoryChange.source !== currentSource || lastCategoryChange.target !== currentTarget;\n        // ENTER: draw in all new links with improved animation\n        const newLinks = linksG.selectAll(\"path\").data(filteredLinks, linkKey).enter().append(\"path\").attr(\"d\", (d)=>(0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankeyLinkHorizontal)()(d)).attr(\"stroke\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d.source, getCurrentThemeColors(), settings.isDarkMode)).attr(\"stroke-width\", (d)=>Math.max(settings.isDarkMode ? 2 : 1, d.width)).attr(\"fill\", \"none\").attr(\"filter\", (d)=>{\n            if (hoveredLink === d) return \"url(#glow)\";\n            return settings.isDarkMode ? \"url(#dark-mode-glow)\" : null;\n        }).attr(\"pointer-events\", \"all\").attr(\"stroke-linecap\", \"round\").attr(\"opacity\", (d)=>{\n            // Dummy links: very low opacity\n            if (d.isDummy) return 0.08;\n            // Adjust opacity based on dark mode for better visibility\n            const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n            const highlightOpacity = settings.isDarkMode ? 1.0 : 0.9;\n            const dimOpacity = settings.isDarkMode ? 0.4 : 0.1;\n            // Default opacity when no highlighting\n            if (animationPhase !== \"highlighting\") return baseOpacity;\n            // Highlight links from the active source\n            if (hoveredSourceIndex !== null) {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n            }\n            // Highlight links to the active target\n            if (hoveredTargetIndex !== null) {\n                const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n            }\n            return baseOpacity;\n        }).attr(\"stroke-dasharray\", (d)=>d.isDummy ? \"4,4\" : null); // Dashed for dummy links\n        // Apply drawing animation only on category changes to prevent flickering\n        if (isCategoryChange) {\n            newLinks.each(function(d) {\n                const path = d3__WEBPACK_IMPORTED_MODULE_2__.select(this);\n                const totalLength = this.getTotalLength();\n                // Start with invisible path\n                path.attr(\"stroke-dasharray\", totalLength).attr(\"stroke-dashoffset\", totalLength).attr(\"opacity\", 0).transition().delay((d, i)=>i * 25) // Reduced stagger delay\n                .duration(600) // Reduced from 1200ms to 600ms\n                .ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut).attr(\"opacity\", (d)=>{\n                    // Adjust opacity based on dark mode for better visibility\n                    const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n                    const highlightOpacity = settings.isDarkMode ? 1.0 : 0.9;\n                    const dimOpacity = settings.isDarkMode ? 0.4 : 0.1;\n                    // Highlight links from the active source or to the active target\n                    if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                        const hoveredSource = sortedSources[hoveredSourceIndex];\n                        return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n                    }\n                    if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                        const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                        return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n                    }\n                    return baseOpacity;\n                }).attr(\"stroke-dashoffset\", 0).on(\"end\", function() {\n                    d3__WEBPACK_IMPORTED_MODULE_2__.select(this).attr(\"stroke-linecap\", \"butt\") // crisp edge after animation\n                    .attr(\"stroke-dasharray\", null).attr(\"stroke-dashoffset\", null);\n                });\n            });\n        } else {\n            // For non-category changes, just set the opacity directly\n            newLinks.attr(\"opacity\", (d)=>{\n                // Adjust opacity based on dark mode for better visibility\n                const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n                const highlightOpacity = settings.isDarkMode ? 1.0 : 0.9;\n                const dimOpacity = settings.isDarkMode ? 0.4 : 0.1;\n                // Highlight links from the active source or to the active target\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredSource = sortedSources[hoveredSourceIndex];\n                    return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n                }\n                if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                    return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n                }\n                return baseOpacity;\n            });\n        }\n        // Add hover interactions\n        newLinks.on(\"mousemove\", function(event, d) {\n            setHoveredLink(d);\n            setTooltip({\n                x: event.offsetX,\n                y: event.offsetY,\n                content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"font-bold\",\n                            children: [\n                                d.source.name,\n                                \" → \",\n                                d.target.name\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                            lineNumber: 948,\n                            columnNumber: 15\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                d.value,\n                                \" attendees\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                            lineNumber: 949,\n                            columnNumber: 15\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                    lineNumber: 947,\n                    columnNumber: 13\n                }, this)\n            });\n        }).on(\"mouseleave\", function() {\n            setHoveredLink(null);\n            setTooltip(null);\n        });\n        // --- Nodes update pattern (rects) ---\n        const filteredNodes = sankeyData.nodes;\n        const nodeSel = nodesG.selectAll(\"rect\").data(filteredNodes, (d)=>d.id);\n        nodeSel.exit().remove();\n        nodeSel.join((enter)=>enter.append(\"rect\").attr(\"x\", (d)=>d.x0).attr(\"y\", (d)=>d.y0).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"width\", (d)=>d.x1 - d.x0).attr(\"fill\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d, getCurrentThemeColors(), settings.isDarkMode)).attr(\"stroke\", settings.isDarkMode ? \"#444\" : \"#22223b\").attr(\"opacity\", (d)=>{\n                // Source nodes: only the highlighted one is bright\n                if (d.category === currentSource) {\n                    if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                        return d.name === sortedSources[hoveredSourceIndex] ? 1 : 0.3;\n                    }\n                    return 0.9; // Increased from 0.6 to 0.9 for more prominence\n                }\n                // Target nodes: only those connected to the highlighted source or hovered target are bright\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredSource = sortedSources[hoveredSourceIndex];\n                    const isConnected = filteredLinks.some((l)=>l.source.name === hoveredSource && l.target.name === d.name);\n                    return isConnected ? 1 : 0.3;\n                }\n                if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                    return d.name === hoveredTarget ? 1 : 0.3;\n                }\n                return 0.9; // Increased from 0.6 to 0.9 for more prominence\n            }).on(\"mousemove\", function(event, d) {\n                setHoveredNode(d);\n                setTooltip({\n                    x: event.offsetX,\n                    y: event.offsetY,\n                    content: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"font-bold\",\n                                children: d.name\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                lineNumber: 1001,\n                                columnNumber: 17\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Category: \",\n                                    d.category\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                lineNumber: 1002,\n                                columnNumber: 17\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Responses: \",\n                                    d.value\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                lineNumber: 1003,\n                                columnNumber: 17\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                        lineNumber: 1000,\n                        columnNumber: 15\n                    }, this)\n                });\n            }).on(\"mouseleave\", function() {\n                setHoveredNode(null);\n                setTooltip(null);\n            }).on(\"mouseenter\", function(event, d) {\n                if (d.category === currentSource) {\n                    const idx = sortedSources.indexOf(d.name);\n                    setHoveredSourceIndex(idx);\n                    setAnimationPhase(\"highlighting\");\n                }\n                if (d.category === currentTarget) {\n                    const idx = sortedTargets.indexOf(d.name);\n                    setHoveredTargetIndex(idx);\n                    setAnimationPhase(\"highlighting\");\n                }\n            }).on(\"mouseleave\", function(event, d) {\n                if (d.category === currentSource) {\n                    setHoveredSourceIndex(null);\n                    setAnimationPhase(\"full\");\n                }\n                if (d.category === currentTarget) {\n                    setHoveredTargetIndex(null);\n                    setAnimationPhase(\"full\");\n                }\n            }), (update)=>update.transition(d3__WEBPACK_IMPORTED_MODULE_2__.transition().duration(750).ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut)).attr(\"x\", (d)=>d.x0).attr(\"y\", (d)=>d.y0).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"width\", (d)=>d.x1 - d.x0).attr(\"fill\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d, getCurrentThemeColors(), settings.isDarkMode)).attr(\"opacity\", (d)=>{\n                // Source nodes: only the highlighted one is bright\n                if (d.category === currentSource) {\n                    if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                        return d.name === sortedSources[hoveredSourceIndex] ? 1 : 0.3;\n                    }\n                    return 0.9; // Increased from 0.6 to 0.9 for more prominence\n                }\n                // Target nodes: only those connected to the highlighted source or hovered target are bright\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredSource = sortedSources[hoveredSourceIndex];\n                    const isConnected = filteredLinks.some((l)=>l.source.name === hoveredSource && l.target.name === d.name);\n                    return isConnected ? 1 : 0.3;\n                }\n                if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                    const hoveredTarget = sortedTargets[hoveredTargetIndex];\n                    return d.name === hoveredTarget ? 1 : 0.3;\n                }\n                return 0.9; // Increased from 0.6 to 0.9 for more prominence\n            }));\n        // --- Node labels (re-render as before) ---\n        g.selectAll(\"g.label-layer\").remove();\n        const labelLayer = g.append(\"g\").attr(\"class\", \"label-layer\");\n        const sourceNodeSet = new Set(sortedSources);\n        const targetNodeSet = new Set(sortedTargets);\n        const sourceNodes = sankeyData.nodes.filter((d)=>d.category === currentSource);\n        const targetNodes = sankeyData.nodes.filter((d)=>d.category === currentTarget);\n        sourceNodes.forEach((node)=>{\n            if (sourceNodeSet.has(node.name)) {\n                labelLayer.append(\"text\").attr(\"x\", -labelPadding).attr(\"y\", (node.y0 + node.y1) / 2).attr(\"text-anchor\", \"end\").attr(\"alignment-baseline\", \"middle\").attr(\"font-family\", nodeLabelFontFamily).attr(\"font-weight\", nodeLabelFontWeight).attr(\"font-size\", labelFontSize).attr(\"fill\", nodeLabelColor).attr(\"aria-label\", node.name).attr(\"opacity\", node.value === 0 ? 0.5 : 1).text(node.name);\n            }\n        });\n        targetNodes.forEach((node)=>{\n            if (targetNodeSet.has(node.name)) {\n                labelLayer.append(\"text\").attr(\"x\", chartWidth + labelPadding).attr(\"y\", (node.y0 + node.y1) / 2).attr(\"text-anchor\", \"start\").attr(\"alignment-baseline\", \"middle\").attr(\"font-family\", nodeLabelFontFamily).attr(\"font-weight\", nodeLabelFontWeight).attr(\"font-size\", labelFontSize).attr(\"fill\", nodeLabelColor).attr(\"aria-label\", node.name).attr(\"opacity\", node.value === 0 ? 0.5 : 1).text(node.name);\n            }\n        });\n        // 6. Update insights\n        let mostCommon = links.length > 0 ? links.reduce((a, b)=>b.value > a.value ? b : a, links[0]) : undefined;\n        setInsights([\n            {\n                title: \"Total Responses\",\n                value: data.length\n            },\n            {\n                title: \"Current View\",\n                value: \"\".concat(currentSource, \" → \").concat(currentTarget)\n            },\n            mostCommon ? {\n                title: \"Most Common Flow\",\n                value: \"\".concat(mostCommon.source.split(\":\")[1], \" → \").concat(mostCommon.target.split(\":\")[1]),\n                description: \"\".concat(mostCommon.value, \" attendees\")\n            } : {\n                title: \"Most Common Flow\",\n                value: \"N/A\",\n                description: \"\"\n            }\n        ]);\n        // 7. Automatic animation on question change only\n        const transition = d3__WEBPACK_IMPORTED_MODULE_2__.transition().duration(750).ease(d3__WEBPACK_IMPORTED_MODULE_2__.easeCubicInOut);\n        // Animate nodes\n        nodeSel.transition(transition).attr(\"x\", (d)=>d.x0).attr(\"y\", (d)=>d.y0).attr(\"height\", (d)=>d.y1 - d.y0).attr(\"width\", (d)=>d.x1 - d.x0).attr(\"fill\", (d)=>(0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getNodeColor)(d, getCurrentThemeColors(), settings.isDarkMode));\n    }, [\n        filteredData,\n        currentSource,\n        currentTarget,\n        containerWidth,\n        containerHeight,\n        settings.categoryColors,\n        settings.isDarkMode,\n        lastCategoryChange,\n        getCurrentThemeColors\n    ]);\n    // Create sorted targets for consistent highlighting\n    const sortedTargetsForHighlight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const sorted = [\n            ...targets\n        ];\n        if (currentTarget === \"years_at_medtronic\") {\n            sorted.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n        } else {\n            sorted.sort();\n        }\n        return sorted;\n    }, [\n        targets,\n        currentTarget\n    ]);\n    // Separate effect to update visual highlighting during animation\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        const g = svg.select(\"g\");\n        // Update node opacity based on animation state\n        g.selectAll(\"rect\").transition().duration(200).attr(\"opacity\", function(d) {\n            // Source nodes: only the highlighted one is bright\n            if (d.category === currentSource) {\n                if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                    return d.name === sortedSources[hoveredSourceIndex] ? 1 : 0.2; // Slightly higher for better visibility\n                }\n                return 0.9; // Increased from 0.6 to 0.9 for more prominence\n            }\n            // Target nodes: highlight those connected to the highlighted source\n            if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                // Check if this target node is connected to the highlighted source\n                const isConnected = svg.selectAll(\"path\").data().some((link)=>link.source.name === hoveredSource && link.target.name === d.name);\n                return isConnected ? 1 : 0.2; // Slightly higher for better visibility\n            }\n            if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n                const hoveredTarget = sortedTargetsForHighlight[hoveredTargetIndex];\n                return d.name === hoveredTarget ? 1 : 0.2;\n            }\n            return 0.9; // Increased from 0.6 to 0.9 for more prominence\n        }).attr(\"stroke-width\", function(d) {\n            // Add thicker stroke to highlighted source node\n            if (d.category === currentSource && hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n                return d.name === sortedSources[hoveredSourceIndex] ? 3 : 1;\n            }\n            return 1;\n        });\n        // Update link opacity based on animation state\n        g.selectAll(\"path\").transition().duration(200).attr(\"opacity\", function(d) {\n            // Adjust opacity based on dark mode for better visibility\n            const baseOpacity = settings.isDarkMode ? 0.85 : 0.4;\n            const highlightOpacity = settings.isDarkMode ? 1.0 : 0.95;\n            const dimOpacity = settings.isDarkMode ? 0.35 : 0.05;\n            // Default opacity when no highlighting\n            if (animationPhase !== \"highlighting\") return baseOpacity;\n            // Highlight links from the active source\n            if (hoveredSourceIndex !== null) {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                return d.source.name === hoveredSource ? highlightOpacity : dimOpacity;\n            }\n            // Highlight links to the active target\n            if (hoveredTargetIndex !== null) {\n                const hoveredTarget = sortedTargetsForHighlight[hoveredTargetIndex];\n                return d.target.name === hoveredTarget ? highlightOpacity : dimOpacity;\n            }\n            return baseOpacity;\n        }).attr(\"stroke-width\", function(d) {\n            // Make highlighted links thicker\n            if (animationPhase === \"highlighting\" && hoveredSourceIndex !== null) {\n                const hoveredSource = sortedSources[hoveredSourceIndex];\n                return d.source.name === hoveredSource ? Math.max(2, d.width * 1.2) : Math.max(1, d.width);\n            }\n            return Math.max(1, d.width);\n        });\n        console.log(\"\\uD83C\\uDFA8 Visual highlighting updated:\", {\n            hoveredSourceIndex,\n            sourceName: hoveredSourceIndex !== null ? sortedSources[hoveredSourceIndex] : null,\n            hoveredTargetIndex,\n            targetName: hoveredTargetIndex !== null ? sortedTargetsForHighlight[hoveredTargetIndex] : null,\n            animationPhase\n        });\n    }, [\n        hoveredSourceIndex,\n        hoveredTargetIndex,\n        animationPhase,\n        sortedSources,\n        sortedTargetsForHighlight,\n        currentSource,\n        currentTarget\n    ]);\n    // Separate effect for hover interactions (doesn't re-render the whole visualization)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        const g = svg.select(\"g\");\n        // Update link hover effects\n        g.selectAll(\"path\").each(function(d) {\n            const path = d3__WEBPACK_IMPORTED_MODULE_2__.select(this);\n            const isHovered = hoveredLink === d;\n            path.attr(\"filter\", isHovered ? \"url(#glow)\" : null);\n        });\n    }, [\n        hoveredNode,\n        hoveredLink\n    ]);\n    // Tooltip rendering with dark mode support\n    const tooltipEl = tooltip ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: \"absolute\",\n            left: tooltip.x + 16,\n            top: tooltip.y + 16,\n            background: settings.isDarkMode ? \"rgba(20,20,30,0.98)\" : \"rgba(255,255,255,0.98)\",\n            color: settings.isDarkMode ? \"#fff\" : \"#170F5F\",\n            padding: \"8px 12px\",\n            borderRadius: 6,\n            pointerEvents: \"none\",\n            zIndex: 100,\n            fontFamily: \"Avenir Next World, sans-serif\",\n            fontWeight: 600,\n            fontSize: 14,\n            boxShadow: settings.isDarkMode ? \"0 4px 24px 0 rgba(16, 16, 235, 0.12)\" : \"0 4px 24px 0 rgba(0, 0, 0, 0.15)\",\n            border: settings.isDarkMode ? \"1px solid rgba(255,255,255,0.1)\" : \"1px solid rgba(0,0,0,0.1)\",\n            maxWidth: 280,\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden\",\n            textOverflow: \"ellipsis\"\n        },\n        role: \"tooltip\",\n        \"aria-live\": \"polite\",\n        children: tooltip.content\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n        lineNumber: 1247,\n        columnNumber: 5\n    }, this) : null;\n    // Create sorted sources array for highlighting (same as rendering and animation)\n    const sortedSourcesForHighlight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        let visualOrder = [];\n        if (filteredData.length && chartWidth > 0 && chartHeight > 0) {\n            const sourcesForNodes = [\n                ...sources\n            ];\n            if (currentSource === \"years_at_medtronic\") {\n                sourcesForNodes.sort((a, b)=>YEARS_CATEGORIES.indexOf(a) - YEARS_CATEGORIES.indexOf(b));\n            } else {\n                sourcesForNodes.sort();\n            }\n            const nodes = [\n                ...sourcesForNodes.map((name)=>({\n                        id: \"\".concat(currentSource, \":\").concat(name),\n                        name,\n                        category: currentSource\n                    })),\n                ...targets.map((name)=>({\n                        id: \"\".concat(currentTarget, \":\").concat(name),\n                        name,\n                        category: currentTarget\n                    }))\n            ];\n            const linksMap = new Map();\n            filteredData.forEach((d)=>{\n                const source = currentSource === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentSource];\n                const target = currentTarget === \"years_at_medtronic\" ? (0,_shared_colorUtils__WEBPACK_IMPORTED_MODULE_5__.getYearsCategory)(d.years_at_medtronic || 0) : d[currentTarget];\n                const sourceId = \"\".concat(currentSource, \":\").concat(source);\n                const targetId = \"\".concat(currentTarget, \":\").concat(target);\n                if (!sourcesForNodes.includes(source) || !targets.includes(target)) return;\n                const key = \"\".concat(sourceId, \"→\").concat(targetId);\n                if (!linksMap.has(key)) {\n                    linksMap.set(key, {\n                        source: sourceId,\n                        target: targetId,\n                        value: 0\n                    });\n                }\n                linksMap.get(key).value += 1;\n            });\n            const links = Array.from(linksMap.values());\n            const sankeyGenerator = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankey)().nodeId((d)=>d.id).nodeWidth(12).nodePadding(nodePadding).extent([\n                [\n                    0,\n                    0\n                ],\n                [\n                    chartWidth,\n                    chartHeight\n                ]\n            ]);\n            const sankeyData = sankeyGenerator({\n                nodes: nodes.map((d)=>({\n                        ...d\n                    })),\n                links: links.map((d)=>({\n                        ...d\n                    }))\n            });\n            const sourceNodes = sankeyData.nodes.filter((d)=>d.category === currentSource);\n            visualOrder = sourceNodes.slice().sort((a, b)=>a.y0 - b.y0).map((d)=>d.name);\n        }\n        return visualOrder.length ? visualOrder : [\n            ...sources\n        ];\n    }, [\n        filteredData,\n        currentSource,\n        currentTarget,\n        sources,\n        targets,\n        chartWidth,\n        chartHeight,\n        nodePadding\n    ]);\n    // Determine which source or target to highlight based on animation state\n    let highlightSourceName = null;\n    let highlightTargetName = null;\n    if (isInFullOpacityState) {\n        highlightSourceName = null;\n        highlightTargetName = null;\n    } else if (hoveredSourceIndex !== null && animationPhase === \"highlighting\") {\n        highlightSourceName = sortedSourcesForHighlight[hoveredSourceIndex];\n    } else if (hoveredTargetIndex !== null && animationPhase === \"highlighting\") {\n        highlightTargetName = targets[hoveredTargetIndex];\n    }\n    // Enhanced animation pause/resume with debug tracking\n    const pauseAnimation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((reason)=>{\n        if (animationRef.current.running && !animationRef.current.isPaused) {\n            console.log(\"⏸️  PAUSING ANIMATION:\", reason, {\n                currentSourceIndex: animationRef.current.currentSourceIndex,\n                currentTargetIndex: animationRef.current.currentTargetIndex,\n                currentSource,\n                currentTarget\n            });\n            animationRef.current.isPaused = true;\n            animationRef.current.pausedAt = Date.now();\n            if (animationRef.current.timer) {\n                clearTimeout(animationRef.current.timer);\n                animationRef.current.timer = null;\n            }\n        }\n    }, [\n        currentSource,\n        currentTarget\n    ]);\n    const resumeAnimation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((reason)=>{\n        if (animationRef.current.running && animationRef.current.isPaused) {\n            console.log(\"▶️  RESUMING ANIMATION:\", reason, {\n                currentSourceIndex: animationRef.current.currentSourceIndex,\n                currentTargetIndex: animationRef.current.currentTargetIndex,\n                pausedDuration: Date.now() - animationRef.current.pausedAt\n            });\n            animationRef.current.isPaused = false;\n            animationRef.current.resumeFrom = \"source\";\n            // Resume animation from current position with a small delay to ensure state is updated\n            setTimeout(()=>{\n                if (animationRef.current.running && !animationRef.current.isPaused) {\n                    animate();\n                }\n            }, 100);\n        }\n    }, [\n        animate\n    ]);\n    // Update hover handlers with proper state management\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current) return;\n        const svg = d3__WEBPACK_IMPORTED_MODULE_2__.select(svgRef.current);\n        // Update link hover behavior\n        svg.selectAll(\"path\").on(\"mouseenter\", function(event, d) {\n            // Pause animation during hover\n            pauseAnimation(\"link hover\");\n            // Set hover states\n            setHoveredLink(d);\n            setAnimationPhase(\"highlighting\");\n            // Handle source node hover\n            if (d.source && d.source.category === currentSource) {\n                const idx = sortedSources.indexOf(d.source.name);\n                setHoveredSourceIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual source highlight:\", d.source.name, \"index:\", idx);\n            }\n            // Handle target node hover\n            if (d.target && d.target.category === currentTarget) {\n                const idx = sortedTargetsForHighlight.indexOf(d.target.name);\n                setHoveredTargetIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual target highlight:\", d.target.name, \"index:\", idx);\n            }\n        }).on(\"mouseleave\", function() {\n            // Resume animation\n            resumeAnimation(\"link hover end\");\n            // Clear hover states\n            setHoveredLink(null);\n            setHoveredSourceIndex(null);\n            setHoveredTargetIndex(null);\n            setAnimationPhase(\"full\");\n        });\n        // Update node hover behavior\n        svg.selectAll(\"rect\").on(\"mouseenter\", function(event, d) {\n            // Pause animation during hover\n            pauseAnimation(\"node hover\");\n            setAnimationPhase(\"highlighting\");\n            // Handle source node hover\n            if (d.category === currentSource) {\n                const idx = sortedSources.indexOf(d.name);\n                setHoveredSourceIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual source node highlight:\", d.name, \"index:\", idx);\n            }\n            // Handle target node hover\n            if (d.category === currentTarget) {\n                const idx = sortedTargetsForHighlight.indexOf(d.name);\n                setHoveredTargetIndex(idx);\n                console.log(\"\\uD83C\\uDFAF Manual target node highlight:\", d.name, \"index:\", idx);\n            }\n        }).on(\"mouseleave\", function() {\n            // Resume animation\n            resumeAnimation(\"node hover end\");\n            // Clear hover states\n            setHoveredSourceIndex(null);\n            setHoveredTargetIndex(null);\n            setAnimationPhase(\"full\");\n        });\n        return ()=>{\n            // Clean up all event listeners\n            svg.selectAll(\"path, rect\").on(\"mouseenter\", null).on(\"mouseleave\", null);\n        };\n    }, [\n        sortedSources,\n        sortedTargetsForHighlight,\n        currentSource,\n        currentTarget,\n        pauseAnimation,\n        resumeAnimation\n    ]);\n    // Main rendering effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!svgRef.current || !data.length) return;\n    // The main rendering logic handles all opacity updates\n    // This ensures data binding is correct and prevents the undefined error\n    }, [\n        filteredData,\n        hoveredSourceIndex,\n        hoveredTargetIndex,\n        animationPhase,\n        sortedSources,\n        targets,\n        currentSource,\n        currentTarget\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\",\n            minHeight: 220,\n            minWidth: 320,\n            position: \"relative\"\n        },\n        children: [\n            (nodeCount <= 2 || sources.length <= 1 || targets.length <= 1) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"absolute\",\n                    top: 40,\n                    left: \"50%\",\n                    transform: \"translateX(-50%)\",\n                    background: \"rgba(255,255,200,0.95)\",\n                    color: \"#170F5F\",\n                    padding: \"12px 24px\",\n                    borderRadius: 8,\n                    fontWeight: 600,\n                    fontSize: 18,\n                    zIndex: 10,\n                    boxShadow: \"0 2px 12px 0 rgba(0,0,0,0.08)\"\n                },\n                children: \"Not enough data to show a meaningful flow diagram.\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                lineNumber: 1468,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                ref: svgRef,\n                width: chartWidth + margin.left + margin.right,\n                height: chartHeight + margin.top + margin.bottom,\n                viewBox: \"0 0 \".concat(chartWidth + margin.left + margin.right, \" \").concat(chartHeight + margin.top + margin.bottom),\n                style: {\n                    display: \"block\",\n                    width: \"100%\",\n                    height: \"100%\",\n                    background: \"transparent\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                        transform: \"translate(\".concat(margin.left, \",\").concat(margin.top, \")\")\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                        lineNumber: 1493,\n                        columnNumber: 9\n                    }, this),\n                    debugOn && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                        transform: \"translate(\".concat(margin.left, \",\").concat(margin.top, \")\"),\n                        children: [\n                            Array.isArray(debugSankeyData === null || debugSankeyData === void 0 ? void 0 : debugSankeyData.nodes) && debugSankeyData.nodes.map((d, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                                    x: d.x0,\n                                    y: d.y0,\n                                    width: d.x1 - d.x0,\n                                    height: d.y1 - d.y0,\n                                    fill: \"none\",\n                                    stroke: \"magenta\",\n                                    strokeDasharray: \"4 2\",\n                                    pointerEvents: \"none\"\n                                }, \"debug-node-\".concat(i), false, {\n                                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                    lineNumber: 1501,\n                                    columnNumber: 15\n                                }, this)),\n                            Array.isArray(debugSankeyData === null || debugSankeyData === void 0 ? void 0 : debugSankeyData.links) && debugSankeyData.links.map((d, i)=>{\n                                const path = (0,d3_sankey__WEBPACK_IMPORTED_MODULE_3__.sankeyLinkHorizontal)()(d) || \"\";\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                    d: path,\n                                    fill: \"none\",\n                                    stroke: \"cyan\",\n                                    strokeWidth: 2,\n                                    pointerEvents: \"none\"\n                                }, \"debug-link-\".concat(i), false, {\n                                    fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                                    lineNumber: 1517,\n                                    columnNumber: 17\n                                }, this);\n                            })\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                        lineNumber: 1498,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n                lineNumber: 1485,\n                columnNumber: 7\n            }, this),\n            tooltipEl\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\artin\\\\Downloads\\\\MEDTRONIC\\\\MEDTRONIC\\\\src\\\\components\\\\DataVisualization\\\\AlluvialDiagram.tsx\",\n        lineNumber: 1465,\n        columnNumber: 5\n    }, this);\n}\n_s(AlluvialDiagram, \"kQCnbN9KZVUa3MxgRjVvTvbhZk8=\", false, function() {\n    return [\n        _shared_useVisualizationData__WEBPACK_IMPORTED_MODULE_4__.useVisualizationData,\n        _lib_context_AppContext__WEBPACK_IMPORTED_MODULE_6__.useAppContext\n    ];\n});\n_c = AlluvialDiagram;\nvar _c;\n$RefreshReg$(_c, \"AlluvialDiagram\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0RhdGFWaXN1YWxpemF0aW9uL0FsbHV2aWFsRGlhZ3JhbS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFFNkY7QUFDcEU7QUFDZ0M7QUFHWTtBQUdvQjtBQUVoQztBQW1EekQsTUFBTWEsa0JBQWtCO0lBQ3RCO1FBQUVDLE9BQU87UUFBc0JDLE9BQU87SUFBcUI7SUFDM0Q7UUFBRUQsT0FBTztRQUFrQkMsT0FBTztJQUFpQjtJQUNuRDtRQUFFRCxPQUFPO1FBQWFDLE9BQU87SUFBWTtJQUN6QztRQUFFRCxPQUFPO1FBQW9CQyxPQUFPO0lBQW1CO0lBQ3ZEO1FBQUVELE9BQU87UUFBY0MsT0FBTztJQUFhO0NBRTVDO0FBRUQsTUFBTUMsbUJBQW1CO0lBQUM7SUFBTztJQUFRO0lBQVM7SUFBUztDQUFNO0FBRWpFLG9EQUFvRDtBQUNwRCxNQUFNQyx3QkFBd0IsQ0FBQ0M7SUFDN0IsSUFBSSxPQUFPQSxVQUFVLFlBQVlDLE1BQU1ELFVBQVVBLFFBQVEsR0FBRyxPQUFPO0lBQ25FLElBQUlBLFNBQVMsR0FBRyxPQUFPO0lBQ3ZCLElBQUlBLFNBQVMsSUFBSSxPQUFPO0lBQ3hCLElBQUlBLFNBQVMsSUFBSSxPQUFPO0lBQ3hCLElBQUlBLFNBQVMsSUFBSSxPQUFPO0lBQ3hCLE9BQU87QUFDVDtBQUVBLG1FQUFtRTtBQUNuRSxTQUFTRSxlQUFlQyxDQUFNO1FBQUVDLGdCQUFBQSxpRUFBZ0IsR0FBR0MsZ0JBQUFBLGlFQUFnQixLQUFLQyxhQUFBQSxpRUFBYSxLQUFLQyxjQUFBQSxpRUFBYztJQUN0Ryx3Q0FBd0M7SUFDeEMsSUFBSUMsS0FBS0wsRUFBRU0sTUFBTSxDQUFDQyxFQUFFO0lBQ3BCLElBQUlBLEtBQUtQLEVBQUVRLE1BQU0sQ0FBQ0gsRUFBRTtJQUNwQixJQUFJSSxLQUFLVCxFQUFFUyxFQUFFO0lBQ2IsSUFBSUMsS0FBS1YsRUFBRVUsRUFBRTtJQUViLHdEQUF3RDtJQUN4REws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aXN1YWxpemF0aW9uL0FsbHV2aWFsRGlhZ3JhbS50c3g/Yjk2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZU1lbW8sIHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHsgc2Fua2V5LCBzYW5rZXlMaW5rSG9yaXpvbnRhbCB9IGZyb20gJ2QzLXNhbmtleSc7XG4vLyBAdHMtZXhwZWN0LWVycm9yOiBObyB0eXBlcyBmb3IgZDMtaW50ZXJwb2xhdGUtcGF0aFxuaW1wb3J0IHsgaW50ZXJwb2xhdGVQYXRoIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUtcGF0aCc7XG5pbXBvcnQgeyB1c2VWaXN1YWxpemF0aW9uRGF0YSB9IGZyb20gJy4vc2hhcmVkL3VzZVZpc3VhbGl6YXRpb25EYXRhJztcbmltcG9ydCB7IFZpc3VhbGl6YXRpb25Db250YWluZXIgfSBmcm9tICcuL3NoYXJlZC9WaXN1YWxpemF0aW9uQ29udGFpbmVyJztcbmltcG9ydCB7IERhdGFJbnNpZ2h0UGFuZWwgfSBmcm9tICcuL3NoYXJlZC9EYXRhSW5zaWdodFBhbmVsJztcbmltcG9ydCB7IGdldFllYXJzQ29sb3JTY2FsZSwgZ2V0WWVhcnNDYXRlZ29yeSwgZ2V0Tm9kZUNvbG9yIH0gZnJvbSAnLi9zaGFyZWQvY29sb3JVdGlscyc7XG5pbXBvcnQgeyBRdWVzdGlvblNlbGVjdG9yIH0gZnJvbSAnLi9zaGFyZWQvUXVlc3Rpb25TZWxlY3Rvcic7XG5pbXBvcnQgeyB1c2VBcHBDb250ZXh0IH0gZnJvbSAnQC9saWIvY29udGV4dC9BcHBDb250ZXh0JztcbmltcG9ydCB0eXBlIHsgRGF0YWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZS90eXBlcyc7XG5cbmludGVyZmFjZSBBbGx1dmlhbERpYWdyYW1Qcm9wcyB7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIGF1dG9QbGF5PzogYm9vbGVhbjtcbiAgb25RdWVzdGlvbkNoYW5nZT86IChzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cbnR5cGUgU3VydmV5UmVzcG9uc2UgPSBEYXRhYmFzZVsncHVibGljJ11bJ1RhYmxlcyddWydzdXJ2ZXlfcmVzcG9uc2VzJ11bJ1JvdyddICYge1xuICBhdHRlbmRlZTogRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsnYXR0ZW5kZWVzJ11bJ1JvdyddO1xufTtcblxuaW50ZXJmYWNlIFNhbmtleU5vZGUge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIHgwOiBudW1iZXI7XG4gIHgxOiBudW1iZXI7XG4gIHkwOiBudW1iZXI7XG4gIHkxOiBudW1iZXI7XG4gIHZhbHVlOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBTYW5rZXlMaW5rIHtcbiAgc291cmNlOiBTYW5rZXlOb2RlO1xuICB0YXJnZXQ6IFNhbmtleU5vZGU7XG4gIHZhbHVlOiBudW1iZXI7XG4gIHdpZHRoOiBudW1iZXI7XG4gIHkwOiBudW1iZXI7XG4gIHkxOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBBbmltYXRpb25TdGF0ZSB7XG4gIHRpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGw7XG4gIHJ1bm5pbmc6IGJvb2xlYW47XG4gIGN1cnJlbnRTb3VyY2VJbmRleDogbnVtYmVyO1xuICBjdXJyZW50VGFyZ2V0SW5kZXg6IG51bWJlcjtcbiAgaXNQYXVzZWQ6IGJvb2xlYW47XG4gIHBhdXNlZEF0OiBudW1iZXI7XG4gIHJlc3VtZUZyb206ICdzb3VyY2UnIHwgJ3RhcmdldCcgfCBudWxsO1xuICBjeWNsZUNvdW50OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBUb29sdGlwU3RhdGUge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgY29udGVudDogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5jb25zdCBhdmFpbGFibGVGaWVsZHMgPSBbXG4gIHsgdmFsdWU6ICd5ZWFyc19hdF9tZWR0cm9uaWMnLCBsYWJlbDogJ1llYXJzIGF0IE1lZHRyb25pYycgfSxcbiAgeyB2YWx1ZTogJ2xlYXJuaW5nX3N0eWxlJywgbGFiZWw6ICdMZWFybmluZyBTdHlsZScgfSxcbiAgeyB2YWx1ZTogJ3NoYXBlZF9ieScsIGxhYmVsOiAnU2hhcGVkIEJ5JyB9LFxuICB7IHZhbHVlOiAncGVha19wZXJmb3JtYW5jZScsIGxhYmVsOiAnUGVhayBQZXJmb3JtYW5jZScgfSxcbiAgeyB2YWx1ZTogJ21vdGl2YXRpb24nLCBsYWJlbDogJ01vdGl2YXRpb24nIH0sXG4gIC8vIEFkZCBtb3JlIGZpZWxkcyBhcyBuZWVkZWRcbl07XG5cbmNvbnN0IFlFQVJTX0NBVEVHT1JJRVMgPSBbJzAtNScsICc2LTEwJywgJzExLTE1JywgJzE2LTIwJywgJzIwKyddO1xuXG4vLyBNb3ZlIHRoaXMgZnVuY3Rpb24gdXAgc28gaXQgaXMgZGVmaW5lZCBiZWZvcmUgdXNlXG5jb25zdCBnZXRWYWxpZFllYXJzQ2F0ZWdvcnkgPSAoeWVhcnM6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGlmICh0eXBlb2YgeWVhcnMgIT09ICdudW1iZXInIHx8IGlzTmFOKHllYXJzKSB8fCB5ZWFycyA8IDApIHJldHVybiAnMC01JztcbiAgaWYgKHllYXJzIDw9IDUpIHJldHVybiAnMC01JztcbiAgaWYgKHllYXJzIDw9IDEwKSByZXR1cm4gJzYtMTAnO1xuICBpZiAoeWVhcnMgPD0gMTUpIHJldHVybiAnMTEtMTUnO1xuICBpZiAoeWVhcnMgPD0gMjApIHJldHVybiAnMTYtMjAnO1xuICByZXR1cm4gJzIwKyc7XG59O1xuXG4vLyBDdXN0b20gd2F2ZSBwYXRoIGdlbmVyYXRvciBmb3IgU2Fua2V5IGxpbmtzIHdpdGggYm91bmRzIGNoZWNraW5nXG5mdW5jdGlvbiBzYW5rZXlMaW5rV2F2ZShkOiBhbnksIHdhdmVBbXBsaXR1ZGUgPSA4LCB3YXZlRnJlcXVlbmN5ID0gMS4xLCBjaGFydFdpZHRoID0gODAwLCBjaGFydEhlaWdodCA9IDYwMCkge1xuICAvLyBkIGhhcyBzb3VyY2UvdGFyZ2V0OiB7eDAsIHgxLCB5MCwgeTF9XG4gIGxldCB4MCA9IGQuc291cmNlLngxO1xuICBsZXQgeDEgPSBkLnRhcmdldC54MDtcbiAgbGV0IHkwID0gZC55MDtcbiAgbGV0IHkxID0gZC55MTtcbiAgXG4gIC8vIENsYW1wIGNvb3JkaW5hdGVzIHRvIGNoYXJ0IGJvdW5kcyB0byBwcmV2ZW50IG92ZXJmbG93XG4gIHgwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY2hhcnRXaWR0aCwgeDApKTtcbiAgeDEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjaGFydFdpZHRoLCB4MSkpO1xuICB5MCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNoYXJ0SGVpZ2h0LCB5MCkpO1xuICB5MSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNoYXJ0SGVpZ2h0LCB5MSkpO1xuICBcbiAgY29uc3QgbWlkWCA9ICh4MCArIHgxKSAvIDI7XG4gIFxuICAvLyBBZGQgYSBzaW5lIHdhdmUgdG8gdGhlIGNvbnRyb2wgcG9pbnRzLCBidXQgZW5zdXJlIHRoZXkgc3RheSB3aXRoaW4gYm91bmRzXG4gIGNvbnN0IHdhdmVZMCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNoYXJ0SGVpZ2h0LCB5MCArIHdhdmVBbXBsaXR1ZGUgKiBNYXRoLnNpbih3YXZlRnJlcXVlbmN5ICogTWF0aC5QSSAqIDAuMjUpKSk7XG4gIGNvbnN0IHdhdmVZMSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNoYXJ0SGVpZ2h0LCB5MSArIHdhdmVBbXBsaXR1ZGUgKiBNYXRoLnNpbih3YXZlRnJlcXVlbmN5ICogTWF0aC5QSSAqIDAuNzUpKSk7XG4gIFxuICByZXR1cm4gYE0ke3gwfSwke3kwfVxuICAgIEMke21pZFh9LCR7d2F2ZVkwfSAke21pZFh9LCR7d2F2ZVkxfSAke3gxfSwke3kxfWA7XG59XG5cbi8vIE5vdGU6IFVzaW5nIHRoZW1lLWF3YXJlIGdldE5vZGVDb2xvciBmdW5jdGlvbiBmcm9tIGNvbG9yVXRpbHNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWxsdXZpYWxEaWFncmFtKHtcbiAgd2lkdGggPSA4MDAsXG4gIGhlaWdodCA9IDYwMCxcbiAgYXV0b1BsYXkgPSB0cnVlLFxuICBvblF1ZXN0aW9uQ2hhbmdlLFxufTogQWxsdXZpYWxEaWFncmFtUHJvcHMpIHtcbiAgLy8gUmVzcG9uc2l2ZTogdXNlIHN0YXRlIGZvciB3aWR0aC9oZWlnaHQsIGZhbGxiYWNrIHRvIHByb3BzXG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IFtjb250YWluZXJXaWR0aCwgc2V0Q29udGFpbmVyV2lkdGhdID0gdXNlU3RhdGUod2lkdGgpO1xuICBjb25zdCBbY29udGFpbmVySGVpZ2h0LCBzZXRDb250YWluZXJIZWlnaHRdID0gdXNlU3RhdGUoaGVpZ2h0KTtcblxuICAvLyBSZXNwb25zaXZlOiBvYnNlcnZlIGNvbnRhaW5lciBzaXplXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IHdpbmRvdy5SZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKGVudHJ5LmNvbnRlbnRSZWN0KSB7XG4gICAgICAgICAgc2V0Q29udGFpbmVyV2lkdGgoZW50cnkuY29udGVudFJlY3Qud2lkdGgpO1xuICAgICAgICAgIHNldENvbnRhaW5lckhlaWdodChlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXJSZWYuY3VycmVudCk7XG4gICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHN2Z1JlZiA9IHVzZVJlZjxTVkdTVkdFbGVtZW50PihudWxsKTtcbiAgY29uc3QgeyBkYXRhLCBpc0xvYWRpbmcsIGVycm9yIH0gPSB1c2VWaXN1YWxpemF0aW9uRGF0YSgpO1xuICBjb25zdCB7IHNldHRpbmdzLCBnZXRDdXJyZW50VGhlbWVDb2xvcnMgfSA9IHVzZUFwcENvbnRleHQoKTtcbiAgY29uc3QgW2N1cnJlbnRTb3VyY2UsIHNldEN1cnJlbnRTb3VyY2VdID0gdXNlU3RhdGUoJ3llYXJzX2F0X21lZHRyb25pYycpO1xuICBjb25zdCBbY3VycmVudFRhcmdldCwgc2V0Q3VycmVudFRhcmdldF0gPSB1c2VTdGF0ZSgnbGVhcm5pbmdfc3R5bGUnKTtcblxuICAvLyBGaWx0ZXIgZGF0YSBiYXNlZCBvbiB0ZXN0IGRhdGEgc2V0dGluZ1xuICBjb25zdCBmaWx0ZXJlZERhdGEgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHNldHRpbmdzLnVzZVRlc3REYXRhID8gZGF0YSA6IGRhdGEuZmlsdGVyKGl0ZW0gPT4gIShpdGVtIGFzIGFueSkudGVzdF9kYXRhKTtcbiAgfSwgW2RhdGEsIHNldHRpbmdzLnVzZVRlc3REYXRhXSk7XG5cbiAgLy8gQ29tcHV0ZSBzb3VyY2VzIGFuZCB0YXJnZXRzIHdpdGggdmFsaWRhdGlvblxuICBjb25zdCBzb3VyY2VzOiBzdHJpbmdbXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWx0ZXJlZERhdGEpIHx8ICFmaWx0ZXJlZERhdGEubGVuZ3RoKSByZXR1cm4gW107XG4gICAgaWYgKGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgICByZXR1cm4gWUVBUlNfQ0FURUdPUklFUy5maWx0ZXIoY2F0ID0+IFxuICAgICAgICBmaWx0ZXJlZERhdGEuc29tZShkID0+IGdldFZhbGlkWWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKSA9PT0gY2F0KVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChcbiAgICAgICAgZmlsdGVyZWREYXRhLm1hcCgoZDogU3VydmV5UmVzcG9uc2UpID0+IGRbY3VycmVudFNvdXJjZSBhcyBrZXlvZiBTdXJ2ZXlSZXNwb25zZV0pXG4gICAgICApKS5maWx0ZXIoKHZhbHVlKTogdmFsdWUgaXMgc3RyaW5nID0+IFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA+IDBcbiAgICAgICk7XG4gICAgfVxuICB9LCBbZmlsdGVyZWREYXRhLCBjdXJyZW50U291cmNlXSk7XG5cbiAgY29uc3QgdGFyZ2V0czogc3RyaW5nW10gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyZWREYXRhKSB8fCAhZmlsdGVyZWREYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIGlmIChjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgICAgcmV0dXJuIFlFQVJTX0NBVEVHT1JJRVMuZmlsdGVyKGNhdCA9PiBcbiAgICAgICAgZmlsdGVyZWREYXRhLnNvbWUoZCA9PiBnZXRWYWxpZFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMCkgPT09IGNhdClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvcnQgdGFyZ2V0IG5vZGVzIGNvbnNpc3RlbnRseSB0byBtYWludGFpbiBmaXhlZCBwb3NpdGlvbnNcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoXG4gICAgICAgIGZpbHRlcmVkRGF0YS5tYXAoKGQ6IFN1cnZleVJlc3BvbnNlKSA9PiBcbiAgICAgICAgY3VycmVudFRhcmdldCA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycgXG4gICAgICAgICAgICA/IGdldFZhbGlkWWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKVxuICAgICAgICAgICAgOiBkW2N1cnJlbnRUYXJnZXQgYXMga2V5b2YgU3VydmV5UmVzcG9uc2VdXG4gICAgICAgIClcbiAgICAgICkpLmZpbHRlcigodmFsdWUpOiB2YWx1ZSBpcyBzdHJpbmcgPT4gXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID4gMFxuICAgICAgKS5zb3J0KCk7IC8vIEFkZCBjb25zaXN0ZW50IHNvcnRpbmdcbiAgICB9XG4gIH0sIFtmaWx0ZXJlZERhdGEsIGN1cnJlbnRUYXJnZXRdKTtcblxuICAvLyAtLS0gUmVzcG9uc2l2ZSBjaGFydCBzaXppbmcgYmFzZWQgb24gZGF0YSBzaXplIC0tLVxuICAvLyBTZXQgc2Vuc2libGUgbWluL21heCBjaGFydCBkaW1lbnNpb25zXG4gIGNvbnN0IE1JTl9DSEFSVF9IRUlHSFQgPSAxODA7XG4gIGNvbnN0IE1BWF9DSEFSVF9IRUlHSFQgPSA3MDA7XG4gIGNvbnN0IE1JTl9DSEFSVF9XSURUSCA9IDMyMDtcbiAgY29uc3QgTUFYX0NIQVJUX1dJRFRIID0gMTQwMDtcblxuICAvLyBDYWxjdWxhdGUgbm9kZSBjb3VudCBmb3Igc2l6aW5nXG4gIGNvbnN0IG5vZGVDb3VudCA9IE1hdGgubWF4KHNvdXJjZXMubGVuZ3RoLCB0YXJnZXRzLmxlbmd0aCwgMSk7XG4gIC8vIENhbGN1bGF0ZSBhdmFpbGFibGUgaGVpZ2h0IGZvciBub2RlcyBhbmQgcGFkZGluZ3NcbiAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KE1JTl9DSEFSVF9IRUlHSFQsIE1hdGgubWluKGNvbnRhaW5lckhlaWdodCAtIDQwLCBNQVhfQ0hBUlRfSEVJR0hUKSk7XG4gIC8vIEZvciB2ZXJ5IHNwYXJzZSBkYXRhLCBzaHJpbmsgdGhlIGNoYXJ0IGhlaWdodFxuICBpZiAobm9kZUNvdW50IDw9IDMpIHtcbiAgICBhdmFpbGFibGVIZWlnaHQgPSBNYXRoLm1heChNSU5fQ0hBUlRfSEVJR0hULCBNYXRoLm1pbigzMjAsIGF2YWlsYWJsZUhlaWdodCkpO1xuICB9XG4gIC8vIEZvciB2ZXJ5IGRlbnNlIGRhdGEsIGFsbG93IG1vcmUgaGVpZ2h0XG4gIGlmIChub2RlQ291bnQgPj0gMTApIHtcbiAgICBhdmFpbGFibGVIZWlnaHQgPSBNYXRoLm1pbihNQVhfQ0hBUlRfSEVJR0hULCBNYXRoLm1heChhdmFpbGFibGVIZWlnaHQsIDUwMCkpO1xuICB9XG5cbiAgLy8gTm9kZSBoZWlnaHQgYW5kIHBhZGRpbmcgbG9naWNcbiAgY29uc3QgbWluTm9kZUhlaWdodCA9IDE2O1xuICBjb25zdCBtYXhOb2RlSGVpZ2h0ID0gbm9kZUNvdW50IDw9IDMgPyAzNiA6IDQ4OyAvLyBTbWFsbGVyIG1heCBmb3Igc3BhcnNlIGRhdGFcbiAgY29uc3QgbWluUGFkZGluZyA9IDg7XG4gIGxldCBub2RlSGVpZ2h0ID0gTWF0aC5mbG9vcigoYXZhaWxhYmxlSGVpZ2h0IC0gKG5vZGVDb3VudCArIDEpICogbWluUGFkZGluZykgLyBub2RlQ291bnQpO1xuICBub2RlSGVpZ2h0ID0gTWF0aC5tYXgobWluTm9kZUhlaWdodCwgTWF0aC5taW4obm9kZUhlaWdodCwgbWF4Tm9kZUhlaWdodCkpO1xuICBsZXQgbm9kZVBhZGRpbmcgPSAoYXZhaWxhYmxlSGVpZ2h0IC0gbm9kZUNvdW50ICogbm9kZUhlaWdodCkgLyAobm9kZUNvdW50ICsgMSk7XG4gIG5vZGVQYWRkaW5nID0gTWF0aC5tYXgobm9kZVBhZGRpbmcsIG1pblBhZGRpbmcpO1xuXG4gIC8vIER5bmFtaWNhbGx5IHNjYWxlIGxhYmVsIGZvbnQgc2l6ZSB3aXRoIG5vZGUgaGVpZ2h0IChjbGFtcCBiZXR3ZWVuIDEycHggYW5kIDI4cHgpXG4gIGNvbnN0IGxhYmVsRm9udFNpemUgPSBNYXRoLm1heCgxMiwgTWF0aC5taW4oMjgsIE1hdGguZmxvb3Iobm9kZUhlaWdodCAqIDAuNSkpKTtcblxuICAvLyAtLS0gRHluYW1pYyBtYXJnaW4gY2FsY3VsYXRpb24gZm9yIGZ1bGwgbGFiZWwgdmlzaWJpbGl0eSAtLS1cbiAgLy8gSGVscGVyIHRvIG1lYXN1cmUgdGV4dCB3aWR0aCBpbiBweFxuICBmdW5jdGlvbiBtZWFzdXJlVGV4dFdpZHRoKHRleHQ6IHN0cmluZywgZm9udDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAxMDA7IC8vIGZhbGxiYWNrIGZvciBTU1JcbiAgICBpZiAoIShtZWFzdXJlVGV4dFdpZHRoIGFzIGFueSkuX2NhbnZhcykge1xuICAgICAgKG1lYXN1cmVUZXh0V2lkdGggYXMgYW55KS5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IChtZWFzdXJlVGV4dFdpZHRoIGFzIGFueSkuX2NhbnZhcyBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKCFjb250ZXh0KSByZXR1cm4gMTAwO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgcmV0dXJuIGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gIH1cblxuICAvLyBGb250IGZvciBtZWFzdXJpbmdcbiAgY29uc3QgbGFiZWxGb250ID0gYGJvbGQgJHtsYWJlbEZvbnRTaXplfXB4IEF2ZW5pciBOZXh0IFdvcmxkLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTRiBQcm8nLCAnUm9ib3RvJywgc2Fucy1zZXJpZmA7XG4gIGNvbnN0IGFsbExhYmVscyA9IFsuLi5zb3VyY2VzLCAuLi50YXJnZXRzXTtcbiAgY29uc3QgbGFiZWxXaWR0aHMgPSBhbGxMYWJlbHMubWFwKGxhYmVsID0+IG1lYXN1cmVUZXh0V2lkdGgobGFiZWwsIGxhYmVsRm9udCkpO1xuICBjb25zdCBtYXhMYWJlbFdpZHRoID0gTWF0aC5tYXgoLi4ubGFiZWxXaWR0aHMsIDgwKTsgLy8gZmFsbGJhY2sgbWluXG4gIGNvbnN0IGxhYmVsUGFkZGluZyA9IDI0O1xuICBjb25zdCBtYXJnaW4gPSB7IHRvcDogMjAsIHJpZ2h0OiBtYXhMYWJlbFdpZHRoICsgbGFiZWxQYWRkaW5nLCBib3R0b206IDIwLCBsZWZ0OiBtYXhMYWJlbFdpZHRoICsgbGFiZWxQYWRkaW5nIH07XG5cbiAgLy8gUmVzcG9uc2l2ZSBjaGFydCB3aWR0aFxuICBsZXQgY2hhcnRXaWR0aCA9IE1hdGgubWF4KE1JTl9DSEFSVF9XSURUSCwgTWF0aC5taW4oY29udGFpbmVyV2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCwgTUFYX0NIQVJUX1dJRFRIKSk7XG4gIGxldCBjaGFydEhlaWdodCA9IGF2YWlsYWJsZUhlaWdodDtcblxuICAvLyBJZiB2ZXJ5IHNwYXJzZSwgc2hyaW5rIHdpZHRoIHRvb1xuICBpZiAobm9kZUNvdW50IDw9IDMpIHtcbiAgICBjaGFydFdpZHRoID0gTWF0aC5tYXgoTUlOX0NIQVJUX1dJRFRILCBNYXRoLm1pbihjaGFydFdpZHRoLCA0ODApKTtcbiAgfVxuXG4gIC8vIElmIHZlcnkgZGVuc2UsIGFsbG93IG1vcmUgd2lkdGhcbiAgaWYgKG5vZGVDb3VudCA+PSAxMCkge1xuICAgIGNoYXJ0V2lkdGggPSBNYXRoLm1pbihNQVhfQ0hBUlRfV0lEVEgsIE1hdGgubWF4KGNoYXJ0V2lkdGgsIDkwMCkpO1xuICB9XG5cbiAgLy8gRGVidWcgbG9nZ2luZ1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbQWxsdXZpYWxEaWFncmFtIERlYnVnXScpO1xuICAgIGNvbnNvbGUubG9nKCcgIENvbnRhaW5lcjonLCBjb250YWluZXJXaWR0aCwgJ3gnLCBjb250YWluZXJIZWlnaHQpO1xuICAgIGNvbnNvbGUubG9nKCcgIENoYXJ0OicsIGNoYXJ0V2lkdGgsICd4JywgY2hhcnRIZWlnaHQpO1xuICAgIGNvbnNvbGUubG9nKCcgIE5vZGUgY291bnQgKHNvdXJjZXMvdGFyZ2V0cyk6Jywgc291cmNlcy5sZW5ndGgsIHRhcmdldHMubGVuZ3RoKTtcbiAgICBjb25zb2xlLmxvZygnICBub2RlSGVpZ2h0OicsIG5vZGVIZWlnaHQpO1xuICAgIGNvbnNvbGUubG9nKCcgIG5vZGVQYWRkaW5nOicsIG5vZGVQYWRkaW5nKTtcbiAgICBjb25zb2xlLmxvZygnICBsYWJlbEZvbnRTaXplOicsIGxhYmVsRm9udFNpemUpO1xuICB9LCBbY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCwgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQsIHNvdXJjZXMubGVuZ3RoLCB0YXJnZXRzLmxlbmd0aCwgbm9kZUhlaWdodCwgbm9kZVBhZGRpbmcsIGxhYmVsRm9udFNpemVdKTtcblxuICAvLyBVc2UgcmVmcyB0byB0cmFjayBjdXJyZW50IHZhbHVlcyB3aXRob3V0IHRyaWdnZXJpbmcgcmUtcmVuZGVyc1xuICBjb25zdCBjdXJyZW50U291cmNlUmVmID0gdXNlUmVmKGN1cnJlbnRTb3VyY2UpO1xuICBjb25zdCBjdXJyZW50VGFyZ2V0UmVmID0gdXNlUmVmKGN1cnJlbnRUYXJnZXQpO1xuICBcbiAgLy8gVXBkYXRlIHJlZnMgd2hlbiBzdGF0ZSBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY3VycmVudFNvdXJjZVJlZi5jdXJyZW50ID0gY3VycmVudFNvdXJjZTtcbiAgfSwgW2N1cnJlbnRTb3VyY2VdKTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY3VycmVudFRhcmdldFJlZi5jdXJyZW50ID0gY3VycmVudFRhcmdldDtcbiAgfSwgW2N1cnJlbnRUYXJnZXRdKTtcbiAgY29uc3QgW2luc2lnaHRzLCBzZXRJbnNpZ2h0c10gPSB1c2VTdGF0ZTxBcnJheTx7IHRpdGxlOiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfCBudW1iZXI7IGRlc2NyaXB0aW9uPzogc3RyaW5nIH0+PihbXSk7XG4gIGNvbnN0IFtob3ZlcmVkTm9kZSwgc2V0SG92ZXJlZE5vZGVdID0gdXNlU3RhdGU8U2Fua2V5Tm9kZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaG92ZXJlZExpbmssIHNldEhvdmVyZWRMaW5rXSA9IHVzZVN0YXRlPFNhbmtleUxpbmsgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3Rvb2x0aXAsIHNldFRvb2x0aXBdID0gdXNlU3RhdGU8VG9vbHRpcFN0YXRlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsYXN0Q2F0ZWdvcnlDaGFuZ2UsIHNldExhc3RDYXRlZ29yeUNoYW5nZV0gPSB1c2VTdGF0ZTx7IHNvdXJjZTogc3RyaW5nOyB0YXJnZXQ6IHN0cmluZyB9Pih7IHNvdXJjZTogY3VycmVudFNvdXJjZSwgdGFyZ2V0OiBjdXJyZW50VGFyZ2V0IH0pO1xuICBjb25zdCBbY3VycmVudFRhcmdldEluZGV4LCBzZXRDdXJyZW50VGFyZ2V0SW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgY29uc3QgW2lzQW5pbWF0aW5nLCBzZXRJc0FuaW1hdGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2hvdmVyZWRTb3VyY2VJbmRleCwgc2V0SG92ZXJlZFNvdXJjZUluZGV4XSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaG92ZXJlZFRhcmdldEluZGV4LCBzZXRIb3ZlcmVkVGFyZ2V0SW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpc0luRnVsbE9wYWNpdHlTdGF0ZSwgc2V0SXNJbkZ1bGxPcGFjaXR5U3RhdGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbYW5pbWF0aW9uUGhhc2UsIHNldEFuaW1hdGlvblBoYXNlXSA9IHVzZVN0YXRlPCdmdWxsJyB8ICdoaWdobGlnaHRpbmcnIHwgJ3RyYW5zaXRpb25pbmcnPignZnVsbCcpO1xuXG4gIGNvbnN0IGFuaW1hdGlvblJlZiA9IHVzZVJlZjxBbmltYXRpb25TdGF0ZT4oe1xuICAgIHRpbWVyOiBudWxsLFxuICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgIGN1cnJlbnRTb3VyY2VJbmRleDogMCxcbiAgICBjdXJyZW50VGFyZ2V0SW5kZXg6IDAsXG4gICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgIHBhdXNlZEF0OiBEYXRlLm5vdygpLFxuICAgIHJlc3VtZUZyb206IG51bGwsXG4gICAgY3ljbGVDb3VudDogMFxuICB9KTtcblxuICAvLyBDaGVjayBmb3IgcmVkdWNlZCBtb3Rpb24gcHJlZmVyZW5jZVxuICBjb25zdCBwcmVmZXJzUmVkdWNlZE1vdGlvbiA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSknKS5tYXRjaGVzO1xuICB9LCBbXSk7XG5cbiAgLy8gQWRqdXN0IGFuaW1hdGlvbiBkdXJhdGlvbnMgYmFzZWQgb24gbW90aW9uIHByZWZlcmVuY2VcbiAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgYmFzZVNwZWVkID0gc2V0dGluZ3MuYXV0b1BsYXlTcGVlZCB8fCAzMDAwO1xuICAgIGNvbnN0IHJlZHVjdGlvbkZhY3RvciA9IHByZWZlcnNSZWR1Y2VkTW90aW9uID8gMC41IDogMTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RlcER1cmF0aW9uOiBNYXRoLm1heCg4MDAsIChiYXNlU3BlZWQgLyA4KSAqIHJlZHVjdGlvbkZhY3RvciksXG4gICAgICBwYXVzZUR1cmF0aW9uOiBNYXRoLm1heCg0MDAsIChiYXNlU3BlZWQgLyAxMikgKiByZWR1Y3Rpb25GYWN0b3IpLFxuICAgICAgY2F0ZWdvcnlQYXVzZUR1cmF0aW9uOiBNYXRoLm1heCgxNTAwLCAoYmFzZVNwZWVkIC8gMykgKiByZWR1Y3Rpb25GYWN0b3IpLFxuICAgICAgbGlua1RyYW5zaXRpb25EdXJhdGlvbjogcHJlZmVyc1JlZHVjZWRNb3Rpb24gPyA0MDAgOiA3NTBcbiAgICB9O1xuICB9LCBbc2V0dGluZ3MuYXV0b1BsYXlTcGVlZCwgcHJlZmVyc1JlZHVjZWRNb3Rpb25dKTtcblxuICAvLyBHZXQgdmlzdWFsIG9yZGVyIG9mIHNvdXJjZSBub2RlcyAodG9wLXRvLWJvdHRvbSBhcyB0aGV5IGFwcGVhcilcbiAgY29uc3Qgc29ydGVkU291cmNlcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZmlsdGVyZWREYXRhLmxlbmd0aCB8fCAhY2hhcnRXaWR0aCB8fCAhY2hhcnRIZWlnaHQpIHJldHVybiBzb3VyY2VzO1xuXG4gICAgY29uc3Qgc291cmNlc0Zvck5vZGVzID0gWy4uLnNvdXJjZXNdO1xuICAgIGlmIChjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJykge1xuICAgICAgc291cmNlc0Zvck5vZGVzLnNvcnQoKGEsIGIpID0+IFlFQVJTX0NBVEVHT1JJRVMuaW5kZXhPZihhKSAtIFlFQVJTX0NBVEVHT1JJRVMuaW5kZXhPZihiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZXNGb3JOb2Rlcy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIFNhbmtleSBsYXlvdXQgdG8gZ2V0IHZpc3VhbCBvcmRlclxuICAgIGNvbnN0IG5vZGVzID0gW1xuICAgICAgLi4uc291cmNlc0Zvck5vZGVzLm1hcCgobmFtZSkgPT4gKHsgaWQ6IGAke2N1cnJlbnRTb3VyY2V9OiR7bmFtZX1gLCBuYW1lLCBjYXRlZ29yeTogY3VycmVudFNvdXJjZSB9KSksXG4gICAgICAuLi50YXJnZXRzLm1hcCgobmFtZSkgPT4gKHsgaWQ6IGAke2N1cnJlbnRUYXJnZXR9OiR7bmFtZX1gLCBuYW1lLCBjYXRlZ29yeTogY3VycmVudFRhcmdldCB9KSksXG4gICAgXTtcblxuICAgIGNvbnN0IGxpbmtzTWFwID0gbmV3IE1hcDxzdHJpbmcsIHsgc291cmNlOiBzdHJpbmc7IHRhcmdldDogc3RyaW5nOyB2YWx1ZTogbnVtYmVyIH0+KCk7IFxuICAgIGZpbHRlcmVkRGF0YS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJyBcbiAgICAgICAgPyBnZXRWYWxpZFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMCkgXG4gICAgICAgIDogKGQgYXMgYW55KVtjdXJyZW50U291cmNlXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGN1cnJlbnRUYXJnZXQgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICAgID8gZ2V0VmFsaWRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApXG4gICAgICAgIDogKGQgYXMgYW55KVtjdXJyZW50VGFyZ2V0XTtcbiAgICAgIFxuICAgICAgaWYgKCFzb3VyY2VzRm9yTm9kZXMuaW5jbHVkZXMoc291cmNlKSB8fCAhdGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IHNvdXJjZUlkID0gYCR7Y3VycmVudFNvdXJjZX06JHtzb3VyY2V9YDtcbiAgICAgIGNvbnN0IHRhcmdldElkID0gYCR7Y3VycmVudFRhcmdldH06JHt0YXJnZXR9YDtcbiAgICAgIGNvbnN0IGtleSA9IGAke3NvdXJjZUlkfeKGkiR7dGFyZ2V0SWR9YDtcbiAgICAgIFxuICAgICAgaWYgKCFsaW5rc01hcC5oYXMoa2V5KSkge1xuICAgICAgICBsaW5rc01hcC5zZXQoa2V5LCB7IHNvdXJjZTogc291cmNlSWQsIHRhcmdldDogdGFyZ2V0SWQsIHZhbHVlOiAwIH0pO1xuICAgICAgfVxuICAgICAgbGlua3NNYXAuZ2V0KGtleSkhLnZhbHVlICs9IDE7XG4gICAgfSk7XG5cbiAgICBjb25zdCBsaW5rcyA9IEFycmF5LmZyb20obGlua3NNYXAudmFsdWVzKCkpO1xuICAgIGNvbnN0IHNhbmtleUdlbmVyYXRvciA9IHNhbmtleTxhbnksIGFueT4oKVxuICAgICAgLm5vZGVJZCgoZDogYW55KSA9PiBkLmlkKVxuICAgICAgLm5vZGVXaWR0aCgxMilcbiAgICAgIC5ub2RlUGFkZGluZyhub2RlUGFkZGluZylcbiAgICAgIC5leHRlbnQoW1swLCAwXSwgW2NoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0XV0pO1xuXG4gICAgY29uc3Qgc2Fua2V5RGF0YSA9IHNhbmtleUdlbmVyYXRvcih7XG4gICAgICBub2Rlczogbm9kZXMubWFwKChkKSA9PiAoeyAuLi5kIH0pKSxcbiAgICAgIGxpbmtzOiBsaW5rcy5tYXAoKGQpID0+ICh7IC4uLmQgfSkpLFxuICAgIH0pO1xuXG4gICAgLy8gR2V0IHNvdXJjZSBub2RlcyBpbiB2aXN1YWwgb3JkZXIgKHRvcCB0byBib3R0b20pXG4gICAgY29uc3Qgc291cmNlTm9kZXMgPSBzYW5rZXlEYXRhLm5vZGVzXG4gICAgICAuZmlsdGVyKChkOiBhbnkpID0+IGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpXG4gICAgICAuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IGEueTAgLSBiLnkwKTtcblxuICAgIHJldHVybiBzb3VyY2VOb2Rlcy5tYXAoKGQ6IGFueSkgPT4gZC5uYW1lKTtcbiAgfSwgW2ZpbHRlcmVkRGF0YSwgc291cmNlcywgdGFyZ2V0cywgY3VycmVudFNvdXJjZSwgY3VycmVudFRhcmdldCwgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQsIG5vZGVQYWRkaW5nXSk7XG5cbiAgLy8gRW5oYW5jZWQgYW5pbWF0aW9uIGZ1bmN0aW9uIHdpdGggY29tcHJlaGVuc2l2ZSBkZWJ1ZyB0cmFja2luZ1xuICBjb25zdCBhbmltYXRlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIENoZWNrIGlmIGFuaW1hdGlvbiBpcyBwYXVzZWRcbiAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfij7jvuI8gIEFuaW1hdGlvbiBpcyBwYXVzZWQsIHNraXBwaW5nIGN5Y2xlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nIHx8ICFmaWx0ZXJlZERhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIEFuaW1hdGlvbiBzdG9wcGVkOicsIHtcbiAgICAgICAgcnVubmluZzogYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyxcbiAgICAgICAgZGF0YUxlbmd0aDogZmlsdGVyZWREYXRhLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2FmZXR5IGNoZWNrOiBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LmN5Y2xlQ291bnQgPiAxMDAwKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+bkSBBbmltYXRpb24gY3ljbGUgbGltaXQgcmVhY2hlZCwgcmVzZXR0aW5nJyk7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jeWNsZUNvdW50ID0gMDtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCA9IDA7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8vIEluY3JlbWVudCBjeWNsZSBjb3VudGVyXG4gICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3ljbGVDb3VudCsrO1xuXG4gICAgLy8gU2V0IGFuaW1hdGlvbiBwaGFzZSB0byBoaWdobGlnaHRpbmdcbiAgICBzZXRBbmltYXRpb25QaGFzZSgnaGlnaGxpZ2h0aW5nJyk7XG4gICAgICAgIHNldElzSW5GdWxsT3BhY2l0eVN0YXRlKGZhbHNlKTtcbiAgICBcbiAgICAvLyBTZXQgdGhlIGhvdmVyZWQgc291cmNlIGluZGV4IHRvIG1hdGNoIHRoZSBhbmltYXRpb25cbiAgICBzZXRIb3ZlcmVkU291cmNlSW5kZXgoYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4KTtcblxuICAgIGNvbnN0IHRhcmdldE9wdGlvbnMgPSBhdmFpbGFibGVGaWVsZHNcbiAgICAgIC5maWx0ZXIoZiA9PiBmLnZhbHVlICE9PSBjdXJyZW50U291cmNlUmVmLmN1cnJlbnQpXG4gICAgICAubWFwKGYgPT4gZi52YWx1ZSk7XG4gICAgXG4gICAgLy8gRGVidWc6IExvZyB0aGUgdGFyZ2V0IG9wdGlvbnMgdG8gdmVyaWZ5IHRoZXkncmUgY29ycmVjdFxuICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn46vIEF2YWlsYWJsZSB0YXJnZXQgb3B0aW9ucyBmb3InLCBjdXJyZW50U291cmNlUmVmLmN1cnJlbnQsICc6JywgdGFyZ2V0T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgICAgICAgLy8gQ09NUFJFSEVOU0lWRSBERUJVRzogTG9nIGN1cnJlbnQgc3RhdGUgd2l0aCBmdWxsIGRldGFpbFxuICAgICAgY29uc29sZS5sb2coJ/CflI0gQU5JTUFUSU9OIENZQ0xFIERFQlVHOicsIHtcbiAgICAgICAgJ/Cfk40gQ3VycmVudCBQb3NpdGlvbic6IHtcbiAgICAgICAgICBzb3VyY2VJbmRleDogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4LFxuICAgICAgICAgIHRhcmdldEluZGV4OiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXgsXG4gICAgICAgICAgc291cmNlTmFtZTogc29ydGVkU291cmNlc1thbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXhdLFxuICAgICAgICAgIHRhcmdldE5hbWU6IGN1cnJlbnRUYXJnZXRSZWYuY3VycmVudFxuICAgICAgICB9LFxuICAgICAgICAn8J+TiiBDYXRlZ29yaWVzJzoge1xuICAgICAgICAgIGN1cnJlbnRTb3VyY2U6IGN1cnJlbnRTb3VyY2VSZWYuY3VycmVudCxcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBjdXJyZW50VGFyZ2V0UmVmLmN1cnJlbnQsXG4gICAgICAgICAgc291cmNlT3B0aW9uczogYXZhaWxhYmxlRmllbGRzLm1hcChmID0+IGYudmFsdWUpLFxuICAgICAgICAgIHRhcmdldE9wdGlvbnNcbiAgICAgICAgfSxcbiAgICAgICfwn5OIIFByb2dyZXNzJzoge1xuICAgICAgICBzb3VyY2VQcm9ncmVzczogYCR7YW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4ICsgMX0vJHtzb3J0ZWRTb3VyY2VzLmxlbmd0aH1gLFxuICAgICAgICB0YXJnZXRQcm9ncmVzczogYCR7YW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4ICsgMX0vJHt0YXJnZXRPcHRpb25zLmxlbmd0aH1gLFxuICAgICAgICBpc0xhc3RTb3VyY2U6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCA+PSBzb3J0ZWRTb3VyY2VzLmxlbmd0aCAtIDEsXG4gICAgICAgIGhhc01vcmVUYXJnZXRzOiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXggPCB0YXJnZXRPcHRpb25zLmxlbmd0aCAtIDFcbiAgICAgIH0sXG4gICAgICAn8J+OryBTb3VyY2VzJzogc29ydGVkU291cmNlcyxcbiAgICAgICfwn46vIFRhcmdldHMnOiB0YXJnZXRPcHRpb25zLFxuICAgICAgJ+KPse+4jyAgVGltaW5ncyc6IGFuaW1hdGlvbkR1cmF0aW9uc1xuICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCA8IHNvcnRlZFNvdXJjZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBNb3ZlIHRvIG5leHQgc291cmNlXG4gICAgICAgIGNvbnN0IG5leHRUaW1lb3V0ID0gYW5pbWF0aW9uRHVyYXRpb25zLnN0ZXBEdXJhdGlvbiArIGFuaW1hdGlvbkR1cmF0aW9ucy5wYXVzZUR1cmF0aW9uO1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IGAke2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCArIDF9LyR7c29ydGVkU291cmNlcy5sZW5ndGh9YDtcbiAgICAgICAgY29uc29sZS5sb2coYPCfjq8gU291cmNlICR7cHJvZ3Jlc3N9OiBIaWdobGlnaHRpbmcgJyR7c29ydGVkU291cmNlc1thbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXhdfScg4oaSICcke2N1cnJlbnRUYXJnZXRSZWYuY3VycmVudH0nIGZvciAke25leHRUaW1lb3V0fW1zYCk7XG4gICAgICBcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyB8fCBhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkgcmV0dXJuO1xuICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXgrKztcbiAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgfSwgbmV4dFRpbWVvdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIEFmdGVyIGxhc3Qgc291cmNlLCBjaGVjayBpZiB3ZSBuZWVkIHRvIGN5Y2xlIHRhcmdldHMgb3IgY2hhbmdlIHNvdXJjZSBjYXRlZ29yeVxuICAgICAgY29uc29sZS5sb2coJ/CflI0gRU5EIE9GIFNPVVJDRVMgLSBDaGVja2luZyB0YXJnZXQgY3ljbGluZzonLCB7XG4gICAgICAgIGN1cnJlbnRUYXJnZXRJbmRleDogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4LFxuICAgICAgICB0YXJnZXRPcHRpb25zTGVuZ3RoOiB0YXJnZXRPcHRpb25zLmxlbmd0aCxcbiAgICAgICAgaGFzTW9yZVRhcmdldHM6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCA8IHRhcmdldE9wdGlvbnMubGVuZ3RoIC0gMSxcbiAgICAgICAgYXZhaWxhYmxlVGFyZ2V0czogdGFyZ2V0T3B0aW9uc1xuICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCA8IHRhcmdldE9wdGlvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIFN0aWxsIGhhdmUgbW9yZSB0YXJnZXQgY2F0ZWdvcmllcyB0byBjeWNsZSB0aHJvdWdoXG4gICAgICAgICAgY29uc3QgdGFyZ2V0UHJvZ3Jlc3MgPSBgJHthbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXggKyAyfS8ke3RhcmdldE9wdGlvbnMubGVuZ3RofWA7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCflIQg4pyFIENPTVBMRVRFRCBBTEwgU09VUkNFUyBmb3IgJyR7Y3VycmVudFRhcmdldFJlZi5jdXJyZW50fScsIG1vdmluZyB0byBuZXh0IHRhcmdldCAoJHt0YXJnZXRQcm9ncmVzc30pYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyIHRvIHByZXZlbnQgY29uZmxpY3RzXG4gICAgICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpO1xuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nIHx8IGFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSByZXR1cm47XG4gICAgICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgndHJhbnNpdGlvbmluZycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgdGFyZ2V0IGNhdGVnb3J5XG4gICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXgrKztcbiAgICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSB0YXJnZXRPcHRpb25zW2FuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleF07XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+OryDinKggTkVXIFRBUkdFVCBDQVRFR09SWTonLCBuZXh0VGFyZ2V0LCBgKCR7YW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4ICsgMX0vJHt0YXJnZXRPcHRpb25zLmxlbmd0aH0pYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBUYXJnZXQgcHJvZ3Jlc3Npb24gZGVidWc6Jywge1xuICAgICAgICAgICAgICBwcmV2aW91c1RhcmdldDogY3VycmVudFRhcmdldFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICBuZXh0VGFyZ2V0LFxuICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0SW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRUYXJnZXRJbmRleCxcbiAgICAgICAgICAgICAgYWxsVGFyZ2V0T3B0aW9uczogdGFyZ2V0T3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRDdXJyZW50VGFyZ2V0KG5leHRUYXJnZXQpO1xuICAgICAgICAgICAgc2V0TGFzdENhdGVnb3J5Q2hhbmdlKHsgc291cmNlOiBjdXJyZW50U291cmNlUmVmLmN1cnJlbnQsIHRhcmdldDogbmV4dFRhcmdldCB9KTtcbiAgICAgICAgICAgIG9uUXVlc3Rpb25DaGFuZ2U/LihjdXJyZW50U291cmNlUmVmLmN1cnJlbnQsIG5leHRUYXJnZXQpO1xuICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVzZXQgc291cmNlIGluZGV4IGFuZCByZXN0YXJ0IHdpdGggbmV3IHRhcmdldFxuICAgICAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFNvdXJjZUluZGV4ID0gMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgY3ljbGUgYWZ0ZXIgYSBicmllZiBwYXVzZVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nICYmICFhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgYW5pbWF0aW9uRHVyYXRpb25zLmNhdGVnb3J5UGF1c2VEdXJhdGlvbik7XG4gICAgICAgICAgfSwgYW5pbWF0aW9uRHVyYXRpb25zLmNhdGVnb3J5UGF1c2VEdXJhdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2UndmUgY3ljbGVkIHRocm91Z2ggYWxsIHRhcmdldHMsIG5vdyBjaGFuZ2UgdGhlIHNvdXJjZSBjYXRlZ29yeVxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIOKcqCBDT01QTEVURUQgQUxMIFRBUkdFVFMgZm9yICcke2N1cnJlbnRTb3VyY2VSZWYuY3VycmVudH0nIC0gTW92aW5nIHRvIG5leHQgc291cmNlIGNhdGVnb3J5ISDinKhgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZXIgdG8gcHJldmVudCBjb25mbGljdHNcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgfHwgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHJldHVybjtcbiAgICAgICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCd0cmFuc2l0aW9uaW5nJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1vdmUgdG8gbmV4dCBzb3VyY2UgY2F0ZWdvcnlcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU9wdGlvbnMgPSBhdmFpbGFibGVGaWVsZHMubWFwKGYgPT4gZi52YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U291cmNlSW5kZXggPSBzb3VyY2VPcHRpb25zLmluZGV4T2YoY3VycmVudFNvdXJjZVJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTb3VyY2VJbmRleCA9IChjdXJyZW50U291cmNlSW5kZXggKyAxKSAlIHNvdXJjZU9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IHNvdXJjZU9wdGlvbnNbbmV4dFNvdXJjZUluZGV4XTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8g8J+GlSBORVcgU09VUkNFIENBVEVHT1JZOicsIG5leHRTb3VyY2UsICctIFN0YXJ0aW5nIGZyZXNoIGN5Y2xlIHdpdGggYWxsIHRhcmdldHMnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRhcmdldCBvcHRpb25zIGZvciB0aGUgTkVXIHNvdXJjZSAoaW5jbHVkaW5nIHllYXJzX2F0X21lZHRyb25pYylcbiAgICAgICAgICAgIGNvbnN0IG5ld1RhcmdldE9wdGlvbnMgPSBhdmFpbGFibGVGaWVsZHNcbiAgICAgICAgICAgICAgLmZpbHRlcihmID0+IGYudmFsdWUgIT09IG5leHRTb3VyY2UpXG4gICAgICAgICAgICAgIC5tYXAoZiA9PiBmLnZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflI0gTmV3IHRhcmdldCBvcHRpb25zIGZvcicsIG5leHRTb3VyY2UsICc6JywgbmV3VGFyZ2V0T3B0aW9ucyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldEN1cnJlbnRTb3VyY2UobmV4dFNvdXJjZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlc2V0IGJvdGggaW5kaWNlcyBhbmQgc3RhcnQgd2l0aCBmaXJzdCB0YXJnZXQgYWdhaW5cbiAgICAgICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCA9IDA7XG4gICAgICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXggPSAwO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RUYXJnZXQgPSBuZXdUYXJnZXRPcHRpb25zWzBdO1xuICAgICAgICAgICAgc2V0Q3VycmVudFRhcmdldChmaXJzdFRhcmdldCk7XG4gICAgICAgICAgICBzZXRMYXN0Q2F0ZWdvcnlDaGFuZ2UoeyBzb3VyY2U6IG5leHRTb3VyY2UsIHRhcmdldDogZmlyc3RUYXJnZXQgfSk7XG4gICAgICAgICAgICBvblF1ZXN0aW9uQ2hhbmdlPy4obmV4dFNvdXJjZSwgZmlyc3RUYXJnZXQpO1xuICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgY3ljbGUgYWZ0ZXIgYSBsb25nZXIgcGF1c2VcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyAmJiAhYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGFuaW1hdGlvbkR1cmF0aW9ucy5jYXRlZ29yeVBhdXNlRHVyYXRpb24gKiAxLjUpOyAvLyBMb25nZXIgcGF1c2UgZm9yIHNvdXJjZSBjYXRlZ29yeSBjaGFuZ2VcbiAgICAgICAgICB9LCBhbmltYXRpb25EdXJhdGlvbnMuY2F0ZWdvcnlQYXVzZUR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtcbiAgICBkYXRhLmxlbmd0aCxcbiAgICBzb3J0ZWRTb3VyY2VzLmxlbmd0aCxcbiAgICBvblF1ZXN0aW9uQ2hhbmdlLFxuICAgIGFuaW1hdGlvbkR1cmF0aW9ucyxcbiAgICBhdmFpbGFibGVGaWVsZHNcbiAgICAvLyBSZW1vdmVkIHNvcnRlZFNvdXJjZXMgdG8gcHJldmVudCBkZXBlbmRlbmN5IGxvb3BzXG4gIF0pO1xuXG5cblxuICAvLyBBbmltYXRpb24gZWZmZWN0IC0gcmVzdGFydCB3aGVuIHNldHRpbmdzIGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCfwn46sIEFuaW1hdGlvbiB1c2VFZmZlY3QgdHJpZ2dlcmVkOicsIHtcbiAgICAgIGF1dG9QbGF5LFxuICAgICAgaXNBdXRvUGxheUVuYWJsZWQ6IHNldHRpbmdzLmlzQXV0b1BsYXlFbmFibGVkLFxuICAgICAgZGF0YUxlbmd0aDogZGF0YS5sZW5ndGgsXG4gICAgICBzdmdSZWZFeGlzdHM6ICEhc3ZnUmVmLmN1cnJlbnQsXG4gICAgICBjdXJyZW50U291cmNlLFxuICAgICAgY3VycmVudFRhcmdldCxcbiAgICAgIGF1dG9QbGF5U3BlZWQ6IHNldHRpbmdzLmF1dG9QbGF5U3BlZWQsXG4gICAgICBpc1J1bm5pbmc6IGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmdcbiAgICB9KTtcblxuICAgIGlmICghYXV0b1BsYXkgfHwgIXNldHRpbmdzLmlzQXV0b1BsYXlFbmFibGVkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIEFuaW1hdGlvbiBkaXNhYmxlZCcpO1xuICAgICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcik7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICBzZXRJc0luRnVsbE9wYWNpdHlTdGF0ZSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFmaWx0ZXJlZERhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIE5vIGRhdGEgYXZhaWxhYmxlIGZvciBhbmltYXRpb24nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzdmdSZWYuY3VycmVudCkge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBTVkcgcmVmIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXN0YXJ0IGFuaW1hdGlvbiB3aGVuIHNwZWVkIGNoYW5nZXMgb3Igb24gbWFqb3IgY2hhbmdlc1xuICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBSZXN0YXJ0aW5nIGFuaW1hdGlvbiB3aXRoIG5ldyBzZXR0aW5nczonLCB7XG4gICAgICAgIHNvdXJjZUNhdGVnb3J5OiBjdXJyZW50U291cmNlLFxuICAgICAgICB0b3RhbFNvdXJjZXM6IHNvcnRlZFNvdXJjZXMubGVuZ3RoLFxuICAgICAgICB0b3RhbFRhcmdldHM6IGF2YWlsYWJsZUZpZWxkcy5maWx0ZXIoZiA9PiBmLnZhbHVlICE9PSBjdXJyZW50U291cmNlKS5sZW5ndGgsXG4gICAgICAgIHNwZWVkOiBzZXR0aW5ncy5hdXRvUGxheVNwZWVkICsgJ21zJ1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFN0b3AgY3VycmVudCBhbmltYXRpb25cbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpO1xuICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgbmV3IGFuaW1hdGlvbiBjeWNsZVxuICAgICAgY29uc29sZS5sb2coJ+KchSBTdGFydGluZyBhbmltYXRpb24gY3ljbGU6Jywge1xuICAgICAgICBzb3VyY2VDYXRlZ29yeTogY3VycmVudFNvdXJjZSxcbiAgICAgICAgdG90YWxTb3VyY2VzOiBzb3J0ZWRTb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgdG90YWxUYXJnZXRzOiBhdmFpbGFibGVGaWVsZHMuZmlsdGVyKGYgPT4gZi52YWx1ZSAhPT0gY3VycmVudFNvdXJjZSkubGVuZ3RoLFxuICAgICAgICBzcGVlZDogc2V0dGluZ3MuYXV0b1BsYXlTcGVlZCArICdtcydcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJbml0aWFsaXplIGFuaW1hdGlvbiBzdGF0ZVxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyA9IHRydWU7XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXggPSAwO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4ID0gMDtcbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50LmN5Y2xlQ291bnQgPSAwOyAvLyBSZXNldCBjeWNsZSBjb3VudGVyXG5cbiAgICAgIC8vIFN0YXJ0IGFuaW1hdGlvblxuICAgICAgYW5pbWF0ZSgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudC50aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpO1xuICAgICAgICBhbmltYXRpb25SZWYuY3VycmVudC50aW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBzZXRBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgc2V0SXNJbkZ1bGxPcGFjaXR5U3RhdGUodHJ1ZSk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGF1dG9QbGF5LFxuICAgIHNldHRpbmdzLmlzQXV0b1BsYXlFbmFibGVkLFxuICAgIHNldHRpbmdzLmF1dG9QbGF5U3BlZWQsIC8vIEFkZCB0aGlzIHRvIHJlc3RhcnQgd2hlbiBzcGVlZCBjaGFuZ2VzXG4gICAgZmlsdGVyZWREYXRhLmxlbmd0aCxcbiAgICBjdXJyZW50U291cmNlIC8vIE9ubHkgcmVzdGFydCBvbiBzb3VyY2UgY2hhbmdlcywgbm90IHRhcmdldCBjaGFuZ2VzXG4gIF0pO1xuXG4gIGNvbnN0IG5vZGVMYWJlbEZvbnRTaXplID0gMTg7IC8vIGxhcmdlciBmb3IgcmVhZGFiaWxpdHlcbiAgY29uc3Qgbm9kZUxhYmVsRm9udFdlaWdodCA9IDcwMDtcbiAgY29uc3Qgbm9kZUxhYmVsQ29sb3IgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJyNGRkZGRkYnIDogJyMxNzBGNUYnO1xuICBjb25zdCBub2RlTGFiZWxGb250RmFtaWx5ID0gJ0F2ZW5pciBOZXh0IFdvcmxkLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFwiU0YgUHJvXCIsIFwiUm9ib3RvXCIsIHNhbnMtc2VyaWYnO1xuICBjb25zdCBub2RlTGFiZWxPZmZzZXQgPSAyNDtcblxuICAvLyBMb2NhbCBkZWJ1ZyB0b2dnbGUgZm9yIHRoaXMgY29tcG9uZW50IGlmIG5vIGdsb2JhbCBhZG1pbiBjb250ZXh0XG4gIGNvbnN0IFtsb2NhbERlYnVnLCBzZXRMb2NhbERlYnVnXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dUaGVtZVRvZ2dsZSwgc2V0U2hvd1RoZW1lVG9nZ2xlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgZGVidWdPbiA9IGxvY2FsRGVidWc7XG5cbiAgLy8gRGVidWcgU2Fua2V5IGRhdGEgZm9yIG91dGxpbmVzXG4gIGNvbnN0IFtkZWJ1Z1NhbmtleURhdGEsIHNldERlYnVnU2Fua2V5RGF0YV0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2VzKSB8fCAhQXJyYXkuaXNBcnJheSh0YXJnZXRzKSkgcmV0dXJuO1xuICAgIGNvbnN0IG5vZGVzID0gW1xuICAgICAgLi4uc291cmNlcy5tYXAoKG5hbWUpID0+ICh7IGlkOiBgc291cmNlOiR7bmFtZX1gLCBuYW1lLCBjYXRlZ29yeTogJ3NvdXJjZScgfSkpLFxuICAgICAgLi4udGFyZ2V0cy5tYXAoKG5hbWUpID0+ICh7IGlkOiBgdGFyZ2V0OiR7bmFtZX1gLCBuYW1lLCBjYXRlZ29yeTogJ3RhcmdldCcgfSkpLFxuICAgIF07XG4gICAgLy8gT25seSBjcmVhdGUgbGlua3MgaWYgYm90aCBzaWRlcyBoYXZlIGF0IGxlYXN0IG9uZSBub2RlXG4gICAgY29uc3QgbGlua3MgPSAoc291cmNlcy5sZW5ndGggJiYgdGFyZ2V0cy5sZW5ndGgpXG4gICAgICA/IFt7IHNvdXJjZTogYHNvdXJjZToke3NvdXJjZXNbMF19YCwgdGFyZ2V0OiBgdGFyZ2V0OiR7dGFyZ2V0c1swXX1gLCB2YWx1ZTogMSB9XVxuICAgICAgOiBbXTtcbiAgICBpZiAobm9kZXMubGVuZ3RoIDwgMiB8fCBsaW5rcy5sZW5ndGggPCAxKSByZXR1cm47IC8vIFByZXZlbnQgaW52YWxpZCBhcnJheSBsZW5ndGhcbiAgICBjb25zdCBzYW5rZXlHZW5lcmF0b3IgPSBzYW5rZXk8YW55LCBhbnk+KClcbiAgICAgIC5ub2RlSWQoKGQ6IGFueSkgPT4gZC5pZClcbiAgICAgIC5ub2RlV2lkdGgoMTIpXG4gICAgICAubm9kZVBhZGRpbmcobm9kZVBhZGRpbmcpXG4gICAgICAuZXh0ZW50KFtbMCwgMF0sIFtjaGFydFdpZHRoLCBjaGFydEhlaWdodF1dKTtcbiAgICBjb25zdCBzYW5rZXlEYXRhID0gc2Fua2V5R2VuZXJhdG9yKHsgbm9kZXM6IG5vZGVzLm1hcCgoZCkgPT4gKHsgLi4uZCB9KSksIGxpbmtzOiBsaW5rcy5tYXAoKGQpID0+ICh7IC4uLmQgfSkpIH0pO1xuICAgIHNldERlYnVnU2Fua2V5RGF0YShzYW5rZXlEYXRhKTtcbiAgfSwgW3NvdXJjZXMsIHRhcmdldHMsIGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0LCBub2RlUGFkZGluZ10pO1xuXG4gIC8vIFJlbmRlciBTYW5rZXkgZGlhZ3JhbVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc3ZnUmVmLmN1cnJlbnQgfHwgIWZpbHRlcmVkRGF0YS5sZW5ndGgpIHJldHVybjtcblxuICAgIC8vIC0tLSBQZXJzaXN0ZW50IFNWRyBzdHJ1Y3R1cmUgLS0tXG4gICAgY29uc3Qgc3ZnID0gZDMuc2VsZWN0PFNWR1NWR0VsZW1lbnQsIHVua25vd24+KHN2Z1JlZi5jdXJyZW50KTtcbiAgICBzdmcuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7IC8vIENsZWFyIHByZXZpb3VzIGNvbnRlbnRcbiAgICBzdmdcbiAgICAgIC5hdHRyKCd3aWR0aCcsIGNvbnRhaW5lcldpZHRoKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIGNvbnRhaW5lckhlaWdodCk7XG5cbiAgICAvLyAtLS0gU2Fua2V5IG5vZGUvbGluayBjcmVhdGlvbiBhbmQgdmVydGljYWwgY2VudGVyaW5nIChkZWR1cGxpY2F0ZWQpIC0tLVxuICAgIC8vIFNvcnQgc291cmNlIG5vZGVzIHRvIG1haW50YWluIGEgZml4ZWQgb3JkZXIgKHNhbWUgYXMgYW5pbWF0aW9uKVxuICAgIGNvbnN0IHNvcnRlZFNvdXJjZXMgPSBbLi4uc291cmNlc107XG4gICAgaWYgKGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgICBzb3J0ZWRTb3VyY2VzLnNvcnQoKGEsIGIpID0+IFlFQVJTX0NBVEVHT1JJRVMuaW5kZXhPZihhKSAtIFlFQVJTX0NBVEVHT1JJRVMuaW5kZXhPZihiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvcnRlZFNvdXJjZXMuc29ydCgpO1xuICAgIH1cbiAgICAvLyBTb3J0IHRhcmdldCBub2RlcyB0byBtYWludGFpbiBhIGZpeGVkIG9yZGVyXG4gICAgY29uc3Qgc29ydGVkVGFyZ2V0cyA9IFsuLi50YXJnZXRzXTtcbiAgICBpZiAoY3VycmVudFRhcmdldCA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycpIHtcbiAgICAgIHNvcnRlZFRhcmdldHMuc29ydCgoYSwgYikgPT4gWUVBUlNfQ0FURUdPUklFUy5pbmRleE9mKGEpIC0gWUVBUlNfQ0FURUdPUklFUy5pbmRleE9mKGIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ydGVkVGFyZ2V0cy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLy8gU2Fua2V5IHRyYW5zZm9ybWF0aW9uIGFjY2Vzc29yc1xuICAgIGNvbnN0IHNvdXJjZUFjY2Vzc29yID0gKGQ6IGFueSkgPT5cbiAgICAgIGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnXG4gICAgICAgID8gZ2V0WWVhcnNDYXRlZ29yeShkLnllYXJzX2F0X21lZHRyb25pYyB8fCAwKVxuICAgICAgICA6IChkIGFzIGFueSlbY3VycmVudFNvdXJjZV07XG4gICAgY29uc3QgdGFyZ2V0QWNjZXNzb3IgPSAoZDogYW55KSA9PlxuICAgICAgY3VycmVudFRhcmdldCA9PT0gJ3llYXJzX2F0X21lZHRyb25pYydcbiAgICAgICAgPyBnZXRZZWFyc0NhdGVnb3J5KGQueWVhcnNfYXRfbWVkdHJvbmljIHx8IDApXG4gICAgICAgIDogKGQgYXMgYW55KVtjdXJyZW50VGFyZ2V0XTtcblxuICAgIC8vIEZpbHRlciBkYXRhIHRvIG9ubHkgaW5jbHVkZSB2YWxpZCB2YWx1ZXNcbiAgICBjb25zdCB2YWxpZERhdGEgPSBmaWx0ZXJlZERhdGEuZmlsdGVyKGQgPT5cbiAgICAgIChjdXJyZW50U291cmNlICE9PSAneWVhcnNfYXRfbWVkdHJvbmljJyB8fCBkLnllYXJzX2F0X21lZHRyb25pYyAhPT0gbnVsbCkgJiZcbiAgICAgIChjdXJyZW50VGFyZ2V0ICE9PSAneWVhcnNfYXRfbWVkdHJvbmljJyB8fCBkLnllYXJzX2F0X21lZHRyb25pYyAhPT0gbnVsbClcbiAgICApO1xuXG4gICAgLy8gQnVpbGQgbm9kZXMgYXJyYXkgd2l0aCB1bmlxdWUgaWRzXG4gICAgY29uc3Qgbm9kZXMgPSBbXG4gICAgICAuLi5zb3J0ZWRTb3VyY2VzLm1hcCgobmFtZSkgPT4gKHsgaWQ6IGAke2N1cnJlbnRTb3VyY2V9OiR7bmFtZX1gLCBuYW1lLCBjYXRlZ29yeTogY3VycmVudFNvdXJjZSB9KSksXG4gICAgICAuLi5zb3J0ZWRUYXJnZXRzLm1hcCgobmFtZSkgPT4gKHsgaWQ6IGAke2N1cnJlbnRUYXJnZXR9OiR7bmFtZX1gLCBuYW1lLCBjYXRlZ29yeTogY3VycmVudFRhcmdldCB9KSksXG4gICAgXTtcblxuICAgIC8vIEJ1aWxkIGxpbmtzIGFycmF5IChhZ2dyZWdhdGUgY291bnRzIGZvciBlYWNoIHNvdXJjZS10YXJnZXQgcGFpcilcbiAgICBjb25zdCBsaW5rc01hcCA9IG5ldyBNYXA8c3RyaW5nLCB7IHNvdXJjZTogc3RyaW5nOyB0YXJnZXQ6IHN0cmluZzsgdmFsdWU6IG51bWJlciwgaXNEdW1teT86IGJvb2xlYW4gfT4oKTtcbiAgICAvLyAxLiBGb3IgZXZlcnkgcG9zc2libGUgc291cmNlLXRhcmdldCBwYWlyLCBjcmVhdGUgYSBsaW5rIChkdW1teSBpZiBubyBkYXRhKVxuICAgIHNvcnRlZFNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICBzb3J0ZWRUYXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4ge1xuICAgICAgICBjb25zdCBzb3VyY2VJZCA9IGAke2N1cnJlbnRTb3VyY2V9OiR7c291cmNlfWA7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gYCR7Y3VycmVudFRhcmdldH06JHt0YXJnZXR9YDtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7c291cmNlSWR94oaSJHt0YXJnZXRJZH1gO1xuICAgICAgICBsaW5rc01hcC5zZXQoa2V5LCB7IHNvdXJjZTogc291cmNlSWQsIHRhcmdldDogdGFyZ2V0SWQsIHZhbHVlOiAwLCBpc0R1bW15OiB0cnVlIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gMi4gRmlsbCBpbiByZWFsIGRhdGEsIG1hcmtpbmcgbGlua3MgYXMgbm90IGR1bW15XG4gICAgdmFsaWREYXRhLmZvckVhY2goKGQpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZUFjY2Vzc29yKGQpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0QWNjZXNzb3IoZCk7XG4gICAgICBpZiAoIXNvcnRlZFNvdXJjZXMuaW5jbHVkZXMoc291cmNlKSB8fCAhc29ydGVkVGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSByZXR1cm47XG4gICAgICBjb25zdCBzb3VyY2VJZCA9IGAke2N1cnJlbnRTb3VyY2V9OiR7c291cmNlfWA7XG4gICAgICBjb25zdCB0YXJnZXRJZCA9IGAke2N1cnJlbnRUYXJnZXR9OiR7dGFyZ2V0fWA7XG4gICAgICBjb25zdCBrZXkgPSBgJHtzb3VyY2VJZH3ihpIke3RhcmdldElkfWA7XG4gICAgICBpZiAoIWxpbmtzTWFwLmhhcyhrZXkpKSB7XG4gICAgICAgIGxpbmtzTWFwLnNldChrZXksIHsgc291cmNlOiBzb3VyY2VJZCwgdGFyZ2V0OiB0YXJnZXRJZCwgdmFsdWU6IDEsIGlzRHVtbXk6IGZhbHNlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGluayA9IGxpbmtzTWFwLmdldChrZXkpITtcbiAgICAgICAgbGluay52YWx1ZSArPSAxO1xuICAgICAgICBsaW5rLmlzRHVtbXkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyAzLiBTZXQgZHVtbXkgbGlua3MgdG8gYSB2ZXJ5IHNtYWxsIHZhbHVlIGlmIHN0aWxsIGR1bW15XG4gICAgQXJyYXkuZnJvbShsaW5rc01hcC52YWx1ZXMoKSkuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgIGlmIChsaW5rLmlzRHVtbXkpIGxpbmsudmFsdWUgPSAwLjAwMDE7XG4gICAgfSk7XG5cbiAgICBjb25zdCBsaW5rcyA9IEFycmF5LmZyb20obGlua3NNYXAudmFsdWVzKCkpO1xuXG4gICAgLy8gU2Fua2V5IGxheW91dFxuICAgIGNvbnN0IHNhbmtleUdlbmVyYXRvciA9IHNhbmtleTxhbnksIGFueT4oKVxuICAgICAgLm5vZGVJZCgoZDogYW55KSA9PiBkLmlkKVxuICAgICAgLm5vZGVXaWR0aCgxMilcbiAgICAgIC5ub2RlUGFkZGluZyhub2RlUGFkZGluZylcbiAgICAgIC5leHRlbnQoW1swLCAwXSwgW2NoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0XV0pO1xuXG4gICAgY29uc3Qgc2Fua2V5RGF0YSA9IHNhbmtleUdlbmVyYXRvcih7XG4gICAgICBub2Rlczogbm9kZXMubWFwKChkKSA9PiAoeyAuLi5kIH0pKSxcbiAgICAgIGxpbmtzOiBsaW5rcy5tYXAoKGQpID0+ICh7IC4uLmQgfSkpLFxuICAgIH0pO1xuXG4gICAgLy8gQ29tcHV0ZSB2ZXJ0aWNhbCBvZmZzZXQgdG8gY2VudGVyIHRoZSBkaWFncmFtXG4gICAgY29uc3Qgbm9kZVlzID0gc2Fua2V5RGF0YS5ub2Rlcy5tYXAoKGQ6IGFueSkgPT4gW2QueTAsIGQueTFdKS5mbGF0KCk7XG4gICAgY29uc3QgbWluWSA9IE1hdGgubWluKC4uLm5vZGVZcyk7XG4gICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KC4uLm5vZGVZcyk7XG4gICAgY29uc3QgdXNlZEhlaWdodCA9IG1heFkgLSBtaW5ZO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLm1heCgwLCAoY2hhcnRIZWlnaHQgLSB1c2VkSGVpZ2h0KSAvIDIgLSBtaW5ZKTtcblxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgY2hhcnQgYXJlYSB3aXRoIG1hcmdpbiB0cmFuc2xhdGlvbiBhbmQgdmVydGljYWwgY2VudGVyaW5nXG4gICAgY29uc3QgZyA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCR7bWFyZ2luLnRvcCArIG9mZnNldFl9KWApO1xuXG4gICAgbGV0IGRlZnMgPSBzdmcuc2VsZWN0PFNWR0RlZnNFbGVtZW50PignZGVmcycpO1xuICAgIGlmIChkZWZzLmVtcHR5KCkpIGRlZnMgPSBzdmcuYXBwZW5kKCdkZWZzJykgYXMgZDMuU2VsZWN0aW9uPFNWR0RlZnNFbGVtZW50LCB1bmtub3duLCBudWxsLCB1bmRlZmluZWQ+O1xuICAgIGxldCBsaW5rc0cgPSBnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2xpbmtzJyk7XG4gICAgbGV0IG5vZGVzRyA9IGcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbm9kZXMnKTtcblxuICAgIC8vIFJlbW92ZSBvbGQgZ3JhZGllbnRzIChubyBsb25nZXIgbmVlZGVkKVxuICAgIGRlZnMuc2VsZWN0QWxsKCdsaW5lYXJHcmFkaWVudC5saW5rLWdyYWRpZW50JykucmVtb3ZlKCk7XG5cbiAgICAvLyAtLS0gQWRkIGNsaXBQYXRoIGZvciBsaW5rcyBncm91cCB3aXRoIHRpZ2h0ZXIgYm91bmRzIC0tLVxuICAgIHN2Zy5zZWxlY3QoJ2RlZnMnKS5zZWxlY3RBbGwoJyNsaW5rLWNsaXAnKS5yZW1vdmUoKTtcbiAgICBkZWZzLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgLmF0dHIoJ2lkJywgJ2xpbmstY2xpcCcpXG4gICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQpXG4gICAgICAuYXR0cigneScsIG1hcmdpbi50b3ApXG4gICAgICAuYXR0cignd2lkdGgnLCBjaGFydFdpZHRoKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIGNoYXJ0SGVpZ2h0KTtcbiAgICBsaW5rc0cuYXR0cignY2xpcC1wYXRoJywgJ3VybCgjbGluay1jbGlwKScpO1xuXG4gICAgLy8gQWRkIGdsb3cgZmlsdGVyIGZvciBkYXJrIG1vZGVcbiAgICBkZWZzLnNlbGVjdEFsbCgnI2RhcmstbW9kZS1nbG93JykucmVtb3ZlKCk7XG4gICAgaWYgKHNldHRpbmdzLmlzRGFya01vZGUpIHtcbiAgICAgIGNvbnN0IGdsb3dGaWx0ZXIgPSBkZWZzLmFwcGVuZCgnZmlsdGVyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2RhcmstbW9kZS1nbG93JylcbiAgICAgICAgLmF0dHIoJ3gnLCAnLTUwJScpXG4gICAgICAgIC5hdHRyKCd5JywgJy01MCUnKVxuICAgICAgICAuYXR0cignd2lkdGgnLCAnMjAwJScpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnMjAwJScpO1xuICAgICAgXG4gICAgICBnbG93RmlsdGVyLmFwcGVuZCgnZmVHYXVzc2lhbkJsdXInKVxuICAgICAgICAuYXR0cignc3RkRGV2aWF0aW9uJywgJzEuNScpXG4gICAgICAgIC5hdHRyKCdyZXN1bHQnLCAnY29sb3JlZEJsdXInKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmVNZXJnZSA9IGdsb3dGaWx0ZXIuYXBwZW5kKCdmZU1lcmdlJyk7XG4gICAgICBmZU1lcmdlLmFwcGVuZCgnZmVNZXJnZU5vZGUnKS5hdHRyKCdpbicsICdjb2xvcmVkQmx1cicpO1xuICAgICAgZmVNZXJnZS5hcHBlbmQoJ2ZlTWVyZ2VOb2RlJykuYXR0cignaW4nLCAnU291cmNlR3JhcGhpYycpO1xuICAgIH1cblxuICAgIC8vIC0tLSBMaW5rcyB1cGRhdGUgcGF0dGVybiAtLS1cbiAgICAvLyBBbGwgbGlua3MgYXJlIG5vdyBiZXR3ZWVuIHJlYWwgbm9kZXMsIHdpdGggaXNEdW1teSBwcm9wZXJ0eSBmb3IgdmlzdWFsIGRpc3RpbmN0aW9uXG4gICAgY29uc3QgZmlsdGVyZWRMaW5rcyA9IHNhbmtleURhdGEubGlua3M7XG4gICAgLy8gUmVtb3ZlIG1peC1ibGVuZC1tb2RlIGluIGRhcmsgbW9kZSB0byBwcmV2ZW50IGNvbG9yIHdhc2hpbmcgb3V0XG4gICAgbGlua3NHLnN0eWxlKCdtaXgtYmxlbmQtbW9kZScsIHNldHRpbmdzLmlzRGFya01vZGUgPyAnbm9ybWFsJyA6ICdtdWx0aXBseScpO1xuICAgIGNvbnN0IGxpbmtLZXkgPSAoZDogYW55KSA9PiBgJHtkLnNvdXJjZS5pZH3ihpIke2QudGFyZ2V0LmlkfWA7XG4gICAgY29uc3QgbGlua1NlbCA9IGxpbmtzRy5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgLmRhdGEoZmlsdGVyZWRMaW5rcywgbGlua0tleSk7XG5cbiAgICAvLyBFWElUOiBmYWRlIG91dCBhbmQgcmVtb3ZlIGFsbCBvbGQgbGlua3NcbiAgICBsaW5rU2VsLmV4aXQoKVxuICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbig0MDApXG4gICAgICAuYXR0cignb3BhY2l0eScsIDApXG4gICAgICAucmVtb3ZlKCk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgY2F0ZWdvcnkgY2hhbmdlIHRoYXQgc2hvdWxkIHRyaWdnZXIgYW5pbWF0aW9uXG4gICAgY29uc3QgaXNDYXRlZ29yeUNoYW5nZSA9IGxhc3RDYXRlZ29yeUNoYW5nZS5zb3VyY2UgIT09IGN1cnJlbnRTb3VyY2UgfHwgbGFzdENhdGVnb3J5Q2hhbmdlLnRhcmdldCAhPT0gY3VycmVudFRhcmdldDtcblxuICAgIC8vIEVOVEVSOiBkcmF3IGluIGFsbCBuZXcgbGlua3Mgd2l0aCBpbXByb3ZlZCBhbmltYXRpb25cbiAgICBjb25zdCBuZXdMaW5rcyA9IGxpbmtzRy5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgLmRhdGEoZmlsdGVyZWRMaW5rcywgbGlua0tleSlcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdwYXRoJylcbiAgICAgIC5hdHRyKCdkJywgKGQ6IGFueSkgPT4gc2Fua2V5TGlua0hvcml6b250YWwoKShkKSlcbiAgICAgIC5hdHRyKCdzdHJva2UnLCAoZDogYW55KSA9PiBnZXROb2RlQ29sb3IoZC5zb3VyY2UsIGdldEN1cnJlbnRUaGVtZUNvbG9ycygpLCBzZXR0aW5ncy5pc0RhcmtNb2RlKSlcbiAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAoZDogYW55KSA9PiBNYXRoLm1heChzZXR0aW5ncy5pc0RhcmtNb2RlID8gMiA6IDEsIGQud2lkdGgpKVxuICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAuYXR0cignZmlsdGVyJywgKGQ6IGFueSkgPT4ge1xuICAgICAgICBpZiAoaG92ZXJlZExpbmsgPT09IGQpIHJldHVybiAndXJsKCNnbG93KSc7XG4gICAgICAgIHJldHVybiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJ3VybCgjZGFyay1tb2RlLWdsb3cpJyA6IG51bGw7XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3BvaW50ZXItZXZlbnRzJywgJ2FsbCcpXG4gICAgICAuYXR0cignc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKVxuICAgICAgLmF0dHIoJ29wYWNpdHknLCAoZDogYW55KSA9PiB7XG4gICAgICAgIC8vIER1bW15IGxpbmtzOiB2ZXJ5IGxvdyBvcGFjaXR5XG4gICAgICAgIGlmIChkLmlzRHVtbXkpIHJldHVybiAwLjA4O1xuICAgICAgICAvLyBBZGp1c3Qgb3BhY2l0eSBiYXNlZCBvbiBkYXJrIG1vZGUgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgICAgIGNvbnN0IGJhc2VPcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuODUgOiAwLjQ7XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodE9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMS4wIDogMC45O1xuICAgICAgICBjb25zdCBkaW1PcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuNCA6IDAuMTtcbiAgICAgICAgLy8gRGVmYXVsdCBvcGFjaXR5IHdoZW4gbm8gaGlnaGxpZ2h0aW5nXG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSAhPT0gJ2hpZ2hsaWdodGluZycpIHJldHVybiBiYXNlT3BhY2l0eTtcbiAgICAgICAgLy8gSGlnaGxpZ2h0IGxpbmtzIGZyb20gdGhlIGFjdGl2ZSBzb3VyY2VcbiAgICAgICAgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGhvdmVyZWRTb3VyY2UgPSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF07XG4gICAgICAgICAgcmV0dXJuIGQuc291cmNlLm5hbWUgPT09IGhvdmVyZWRTb3VyY2UgPyBoaWdobGlnaHRPcGFjaXR5IDogZGltT3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIaWdobGlnaHQgbGlua3MgdG8gdGhlIGFjdGl2ZSB0YXJnZXRcbiAgICAgICAgaWYgKGhvdmVyZWRUYXJnZXRJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGhvdmVyZWRUYXJnZXQgPSBzb3J0ZWRUYXJnZXRzW2hvdmVyZWRUYXJnZXRJbmRleF07XG4gICAgICAgICAgcmV0dXJuIGQudGFyZ2V0Lm5hbWUgPT09IGhvdmVyZWRUYXJnZXQgPyBoaWdobGlnaHRPcGFjaXR5IDogZGltT3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZU9wYWNpdHk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAoZDogYW55KSA9PiBkLmlzRHVtbXkgPyAnNCw0JyA6IG51bGwpOyAvLyBEYXNoZWQgZm9yIGR1bW15IGxpbmtzXG5cbiAgICAvLyBBcHBseSBkcmF3aW5nIGFuaW1hdGlvbiBvbmx5IG9uIGNhdGVnb3J5IGNoYW5nZXMgdG8gcHJldmVudCBmbGlja2VyaW5nXG4gICAgaWYgKGlzQ2F0ZWdvcnlDaGFuZ2UpIHtcbiAgICAgIG5ld0xpbmtzLmVhY2goZnVuY3Rpb24gKGQ6IGFueSkge1xuICAgICAgICBjb25zdCBwYXRoID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9ICh0aGlzIGFzIFNWR1BhdGhFbGVtZW50KS5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBpbnZpc2libGUgcGF0aFxuICAgICAgICBwYXRoXG4gICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCB0b3RhbExlbmd0aClcbiAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCB0b3RhbExlbmd0aClcbiAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDApXG4gICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5kZWxheSgoZDogYW55LCBpOiBudW1iZXIpID0+IGkgKiAyNSkgLy8gUmVkdWNlZCBzdGFnZ2VyIGRlbGF5XG4gICAgICAgICAgLmR1cmF0aW9uKDYwMCkgLy8gUmVkdWNlZCBmcm9tIDEyMDBtcyB0byA2MDBtc1xuICAgICAgICAgIC5lYXNlKGQzLmVhc2VDdWJpY0luT3V0KVxuICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgKGQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgLy8gQWRqdXN0IG9wYWNpdHkgYmFzZWQgb24gZGFyayBtb2RlIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICAgICAgY29uc3QgYmFzZU9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMC44NSA6IDAuNDtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodE9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMS4wIDogMC45O1xuICAgICAgICAgICAgY29uc3QgZGltT3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAwLjQgOiAwLjE7XG5cbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodCBsaW5rcyBmcm9tIHRoZSBhY3RpdmUgc291cmNlIG9yIHRvIHRoZSBhY3RpdmUgdGFyZ2V0XG4gICAgICAgICAgICBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgICAgICBjb25zdCBob3ZlcmVkU291cmNlID0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdO1xuICAgICAgICAgICAgICByZXR1cm4gZC5zb3VyY2UubmFtZSA9PT0gaG92ZXJlZFNvdXJjZSA/IGhpZ2hsaWdodE9wYWNpdHkgOiBkaW1PcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhvdmVyZWRUYXJnZXRJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICAgICAgY29uc3QgaG92ZXJlZFRhcmdldCA9IHNvcnRlZFRhcmdldHNbaG92ZXJlZFRhcmdldEluZGV4XTtcbiAgICAgICAgICAgICAgcmV0dXJuIGQudGFyZ2V0Lm5hbWUgPT09IGhvdmVyZWRUYXJnZXQgPyBoaWdobGlnaHRPcGFjaXR5IDogZGltT3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYXNlT3BhY2l0eTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaG9mZnNldCcsIDApXG4gICAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1saW5lY2FwJywgJ2J1dHQnKSAvLyBjcmlzcCBlZGdlIGFmdGVyIGFuaW1hdGlvblxuICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsIG51bGwpXG4gICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaG9mZnNldCcsIG51bGwpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBub24tY2F0ZWdvcnkgY2hhbmdlcywganVzdCBzZXQgdGhlIG9wYWNpdHkgZGlyZWN0bHlcbiAgICAgIG5ld0xpbmtzLmF0dHIoJ29wYWNpdHknLCAoZDogYW55KSA9PiB7XG4gICAgICAgIC8vIEFkanVzdCBvcGFjaXR5IGJhc2VkIG9uIGRhcmsgbW9kZSBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgY29uc3QgYmFzZU9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMC44NSA6IDAuNDtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0T3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAxLjAgOiAwLjk7XG4gICAgICAgIGNvbnN0IGRpbU9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMC40IDogMC4xO1xuXG4gICAgICAgIC8vIEhpZ2hsaWdodCBsaW5rcyBmcm9tIHRoZSBhY3RpdmUgc291cmNlIG9yIHRvIHRoZSBhY3RpdmUgdGFyZ2V0XG4gICAgICAgIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgY29uc3QgaG92ZXJlZFNvdXJjZSA9IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XTtcbiAgICAgICAgICByZXR1cm4gZC5zb3VyY2UubmFtZSA9PT0gaG92ZXJlZFNvdXJjZSA/IGhpZ2hsaWdodE9wYWNpdHkgOiBkaW1PcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0SW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgY29uc3QgaG92ZXJlZFRhcmdldCA9IHNvcnRlZFRhcmdldHNbaG92ZXJlZFRhcmdldEluZGV4XTtcbiAgICAgICAgICByZXR1cm4gZC50YXJnZXQubmFtZSA9PT0gaG92ZXJlZFRhcmdldCA/IGhpZ2hsaWdodE9wYWNpdHkgOiBkaW1PcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlT3BhY2l0eTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCBob3ZlciBpbnRlcmFjdGlvbnNcbiAgICBuZXdMaW5rc1xuICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQ6IGFueSwgZDogYW55KSB7XG4gICAgICAgIHNldEhvdmVyZWRMaW5rKGQpO1xuICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgICAgIHk6IGV2ZW50Lm9mZnNldFksXG4gICAgICAgICAgY29udGVudDogKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb250LWJvbGRcIj57ZC5zb3VyY2UubmFtZX0g4oaSIHtkLnRhcmdldC5uYW1lfTwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2PntkLnZhbHVlfSBhdHRlbmRlZXM8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICksXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0SG92ZXJlZExpbmsobnVsbCk7XG4gICAgICAgIHNldFRvb2x0aXAobnVsbCk7XG4gICAgICB9KTtcblxuICAgIC8vIC0tLSBOb2RlcyB1cGRhdGUgcGF0dGVybiAocmVjdHMpIC0tLVxuXG5cbiAgICBjb25zdCBmaWx0ZXJlZE5vZGVzID0gc2Fua2V5RGF0YS5ub2RlcztcbiAgICBjb25zdCBub2RlU2VsID0gbm9kZXNHLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAuZGF0YShmaWx0ZXJlZE5vZGVzLCAoZDogYW55KSA9PiBkLmlkKTtcbiAgICBub2RlU2VsLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBub2RlU2VsLmpvaW4oXG4gICAgICBlbnRlciA9PiBlbnRlci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cigneCcsIChkOiBhbnkpID0+IGQueDApXG4gICAgICAgIC5hdHRyKCd5JywgKGQ6IGFueSkgPT4gZC55MClcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkOiBhbnkpID0+IGQueTEgLSBkLnkwKVxuICAgICAgICAuYXR0cignd2lkdGgnLCAoZDogYW55KSA9PiBkLngxIC0gZC54MClcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZDogYW55KSA9PiBnZXROb2RlQ29sb3IoZCwgZ2V0Q3VycmVudFRoZW1lQ29sb3JzKCksIHNldHRpbmdzLmlzRGFya01vZGUpKVxuICAgICAgICAuYXR0cignc3Ryb2tlJywgc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICcjNDQ0JyA6ICcjMjIyMjNiJylcbiAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAoZDogYW55KSA9PiB7XG4gICAgICAgICAgLy8gU291cmNlIG5vZGVzOiBvbmx5IHRoZSBoaWdobGlnaHRlZCBvbmUgaXMgYnJpZ2h0XG4gICAgICAgICAgaWYgKGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XSA/IDEgOiAwLjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC45OyAvLyBJbmNyZWFzZWQgZnJvbSAwLjYgdG8gMC45IGZvciBtb3JlIHByb21pbmVuY2VcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGFyZ2V0IG5vZGVzOiBvbmx5IHRob3NlIGNvbm5lY3RlZCB0byB0aGUgaGlnaGxpZ2h0ZWQgc291cmNlIG9yIGhvdmVyZWQgdGFyZ2V0IGFyZSBicmlnaHRcbiAgICAgICAgICBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZFNvdXJjZSA9IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gZmlsdGVyZWRMaW5rcy5zb21lKGwgPT4gbC5zb3VyY2UubmFtZSA9PT0gaG92ZXJlZFNvdXJjZSAmJiBsLnRhcmdldC5uYW1lID09PSBkLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkID8gMSA6IDAuMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhvdmVyZWRUYXJnZXRJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRUYXJnZXQgPSBzb3J0ZWRUYXJnZXRzW2hvdmVyZWRUYXJnZXRJbmRleF07XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBob3ZlcmVkVGFyZ2V0ID8gMSA6IDAuMztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDAuOTsgLy8gSW5jcmVhc2VkIGZyb20gMC42IHRvIDAuOSBmb3IgbW9yZSBwcm9taW5lbmNlXG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2ZW50OiBhbnksIGQ6IGFueSkge1xuICAgICAgICAgIHNldEhvdmVyZWROb2RlKGQpO1xuICAgICAgICAgIHNldFRvb2x0aXAoe1xuICAgICAgICAgICAgeDogZXZlbnQub2Zmc2V0WCxcbiAgICAgICAgICAgIHk6IGV2ZW50Lm9mZnNldFksXG4gICAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb250LWJvbGRcIj57ZC5uYW1lfTwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXY+Q2F0ZWdvcnk6IHtkLmNhdGVnb3J5fTwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXY+UmVzcG9uc2VzOiB7ZC52YWx1ZX08L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2V0SG92ZXJlZE5vZGUobnVsbCk7XG4gICAgICAgICAgc2V0VG9vbHRpcChudWxsKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGV2ZW50OiBhbnksIGQ6IGFueSkge1xuICAgICAgICAgIGlmIChkLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBzb3J0ZWRTb3VyY2VzLmluZGV4T2YoZC5uYW1lKTtcbiAgICAgICAgICAgIHNldEhvdmVyZWRTb3VyY2VJbmRleChpZHgpO1xuICAgICAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZC5jYXRlZ29yeSA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gc29ydGVkVGFyZ2V0cy5pbmRleE9mKGQubmFtZSk7XG4gICAgICAgICAgICBzZXRIb3ZlcmVkVGFyZ2V0SW5kZXgoaWR4KTtcbiAgICAgICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChldmVudDogYW55LCBkOiBhbnkpIHtcbiAgICAgICAgICBpZiAoZC5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSkge1xuICAgICAgICAgICAgc2V0SG92ZXJlZFNvdXJjZUluZGV4KG51bGwpO1xuICAgICAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2Z1bGwnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHNldEhvdmVyZWRUYXJnZXRJbmRleChudWxsKTtcbiAgICAgICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgIHVwZGF0ZSA9PiB1cGRhdGVcbiAgICAgICAgLnRyYW5zaXRpb24oZDMudHJhbnNpdGlvbigpLmR1cmF0aW9uKDc1MCkuZWFzZShkMy5lYXNlQ3ViaWNJbk91dCkpXG4gICAgICAgIC5hdHRyKCd4JywgKGQ6IGFueSkgPT4gZC54MClcbiAgICAgICAgLmF0dHIoJ3knLCAoZDogYW55KSA9PiBkLnkwKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQ6IGFueSkgPT4gZC55MSAtIGQueTApXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkOiBhbnkpID0+IGQueDEgLSBkLngwKVxuICAgICAgICAuYXR0cignZmlsbCcsIChkOiBhbnkpID0+IGdldE5vZGVDb2xvcihkLCBnZXRDdXJyZW50VGhlbWVDb2xvcnMoKSwgc2V0dGluZ3MuaXNEYXJrTW9kZSkpXG4gICAgICAgIC5hdHRyKCdvcGFjaXR5JywgKGQ6IGFueSkgPT4ge1xuICAgICAgICAgIC8vIFNvdXJjZSBub2Rlczogb25seSB0aGUgaGlnaGxpZ2h0ZWQgb25lIGlzIGJyaWdodFxuICAgICAgICAgIGlmIChkLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsICYmIGFuaW1hdGlvblBoYXNlID09PSAnaGlnaGxpZ2h0aW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF0gPyAxIDogMC4zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuOTsgLy8gSW5jcmVhc2VkIGZyb20gMC42IHRvIDAuOSBmb3IgbW9yZSBwcm9taW5lbmNlXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRhcmdldCBub2Rlczogb25seSB0aG9zZSBjb25uZWN0ZWQgdG8gdGhlIGhpZ2hsaWdodGVkIHNvdXJjZSBvciBob3ZlcmVkIHRhcmdldCBhcmUgYnJpZ2h0XG4gICAgICAgICAgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRTb3VyY2UgPSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF07XG4gICAgICAgICAgICBjb25zdCBpc0Nvbm5lY3RlZCA9IGZpbHRlcmVkTGlua3Muc29tZShsID0+IGwuc291cmNlLm5hbWUgPT09IGhvdmVyZWRTb3VyY2UgJiYgbC50YXJnZXQubmFtZSA9PT0gZC5uYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBpc0Nvbm5lY3RlZCA/IDEgOiAwLjM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0SW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBob3ZlcmVkVGFyZ2V0ID0gc29ydGVkVGFyZ2V0c1tob3ZlcmVkVGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaG92ZXJlZFRhcmdldCA/IDEgOiAwLjM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwLjk7IC8vIEluY3JlYXNlZCBmcm9tIDAuNiB0byAwLjkgZm9yIG1vcmUgcHJvbWluZW5jZVxuICAgICAgICB9KVxuICAgICk7XG5cbiAgICAvLyAtLS0gTm9kZSBsYWJlbHMgKHJlLXJlbmRlciBhcyBiZWZvcmUpIC0tLVxuICAgIGcuc2VsZWN0QWxsKCdnLmxhYmVsLWxheWVyJykucmVtb3ZlKCk7XG4gICAgY29uc3QgbGFiZWxMYXllciA9IGcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbGFiZWwtbGF5ZXInKTtcbiAgICBjb25zdCBzb3VyY2VOb2RlU2V0ID0gbmV3IFNldChzb3J0ZWRTb3VyY2VzKTtcbiAgICBjb25zdCB0YXJnZXROb2RlU2V0ID0gbmV3IFNldChzb3J0ZWRUYXJnZXRzKTtcbiAgICBjb25zdCBzb3VyY2VOb2RlcyA9IHNhbmtleURhdGEubm9kZXMuZmlsdGVyKGQgPT4gZC5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSk7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZXMgPSBzYW5rZXlEYXRhLm5vZGVzLmZpbHRlcihkID0+IGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRUYXJnZXQpO1xuICAgIHNvdXJjZU5vZGVzLmZvckVhY2goKG5vZGU6IGFueSkgPT4ge1xuICAgICAgaWYgKHNvdXJjZU5vZGVTZXQuaGFzKG5vZGUubmFtZSkpIHtcbiAgICAgICAgbGFiZWxMYXllclxuICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCd4JywgLWxhYmVsUGFkZGluZylcbiAgICAgICAgICAuYXR0cigneScsIChub2RlLnkwICsgbm9kZS55MSkgLyAyKVxuICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxuICAgICAgICAgIC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcbiAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCBub2RlTGFiZWxGb250RmFtaWx5KVxuICAgICAgICAgIC5hdHRyKCdmb250LXdlaWdodCcsIG5vZGVMYWJlbEZvbnRXZWlnaHQpXG4gICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGxhYmVsRm9udFNpemUpXG4gICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBub2RlTGFiZWxDb2xvcilcbiAgICAgICAgICAuYXR0cignYXJpYS1sYWJlbCcsIG5vZGUubmFtZSlcbiAgICAgICAgICAuYXR0cignb3BhY2l0eScsIG5vZGUudmFsdWUgPT09IDAgPyAwLjUgOiAxKVxuICAgICAgICAgIC50ZXh0KG5vZGUubmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFyZ2V0Tm9kZXMuZm9yRWFjaCgobm9kZTogYW55KSA9PiB7XG4gICAgICBpZiAodGFyZ2V0Tm9kZVNldC5oYXMobm9kZS5uYW1lKSkge1xuICAgICAgICBsYWJlbExheWVyXG4gICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgLmF0dHIoJ3gnLCBjaGFydFdpZHRoICsgbGFiZWxQYWRkaW5nKVxuICAgICAgICAgIC5hdHRyKCd5JywgKG5vZGUueTAgKyBub2RlLnkxKSAvIDIpXG4gICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcbiAgICAgICAgICAuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpXG4gICAgICAgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5Jywgbm9kZUxhYmVsRm9udEZhbWlseSlcbiAgICAgICAgICAuYXR0cignZm9udC13ZWlnaHQnLCBub2RlTGFiZWxGb250V2VpZ2h0KVxuICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBsYWJlbEZvbnRTaXplKVxuICAgICAgICAgIC5hdHRyKCdmaWxsJywgbm9kZUxhYmVsQ29sb3IpXG4gICAgICAgICAgLmF0dHIoJ2FyaWEtbGFiZWwnLCBub2RlLm5hbWUpXG4gICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBub2RlLnZhbHVlID09PSAwID8gMC41IDogMSlcbiAgICAgICAgICAudGV4dChub2RlLm5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gNi4gVXBkYXRlIGluc2lnaHRzXG4gICAgbGV0IG1vc3RDb21tb246IHR5cGVvZiBsaW5rc1swXSB8IHVuZGVmaW5lZCA9IGxpbmtzLmxlbmd0aCA+IDAgPyBsaW5rcy5yZWR1Y2UoKGEsIGIpID0+IChiLnZhbHVlID4gYS52YWx1ZSA/IGIgOiBhKSwgbGlua3NbMF0pIDogdW5kZWZpbmVkO1xuICAgIHNldEluc2lnaHRzKFtcbiAgICAgIHsgdGl0bGU6ICdUb3RhbCBSZXNwb25zZXMnLCB2YWx1ZTogZGF0YS5sZW5ndGggfSxcbiAgICAgIHsgdGl0bGU6ICdDdXJyZW50IFZpZXcnLCB2YWx1ZTogYCR7Y3VycmVudFNvdXJjZX0g4oaSICR7Y3VycmVudFRhcmdldH1gIH0sXG4gICAgICBtb3N0Q29tbW9uXG4gICAgICAgID8geyB0aXRsZTogJ01vc3QgQ29tbW9uIEZsb3cnLCB2YWx1ZTogYCR7bW9zdENvbW1vbi5zb3VyY2Uuc3BsaXQoJzonKVsxXX0g4oaSICR7bW9zdENvbW1vbi50YXJnZXQuc3BsaXQoJzonKVsxXX1gLCBkZXNjcmlwdGlvbjogYCR7bW9zdENvbW1vbi52YWx1ZX0gYXR0ZW5kZWVzYCB9XG4gICAgICAgIDogeyB0aXRsZTogJ01vc3QgQ29tbW9uIEZsb3cnLCB2YWx1ZTogJ04vQScsIGRlc2NyaXB0aW9uOiAnJyB9LFxuICAgIF0pO1xuXG4gICAgLy8gNy4gQXV0b21hdGljIGFuaW1hdGlvbiBvbiBxdWVzdGlvbiBjaGFuZ2Ugb25seVxuICAgIGNvbnN0IHRyYW5zaXRpb24gPSBkMy50cmFuc2l0aW9uKCkuZHVyYXRpb24oNzUwKS5lYXNlKGQzLmVhc2VDdWJpY0luT3V0KTtcblxuICAgIC8vIEFuaW1hdGUgbm9kZXNcbiAgICBub2RlU2VsXG4gICAgICAudHJhbnNpdGlvbih0cmFuc2l0aW9uKVxuICAgICAgLmF0dHIoJ3gnLCAoZDogYW55KSA9PiBkLngwKVxuICAgICAgLmF0dHIoJ3knLCAoZDogYW55KSA9PiBkLnkwKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIChkOiBhbnkpID0+IGQueTEgLSBkLnkwKVxuICAgICAgLmF0dHIoJ3dpZHRoJywgKGQ6IGFueSkgPT4gZC54MSAtIGQueDApXG4gICAgICAuYXR0cignZmlsbCcsIChkOiBhbnkpID0+IGdldE5vZGVDb2xvcihkLCBnZXRDdXJyZW50VGhlbWVDb2xvcnMoKSwgc2V0dGluZ3MuaXNEYXJrTW9kZSkpO1xuXG4gIH0sIFtmaWx0ZXJlZERhdGEsIGN1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXQsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQsIHNldHRpbmdzLmNhdGVnb3J5Q29sb3JzLCBzZXR0aW5ncy5pc0RhcmtNb2RlLCBsYXN0Q2F0ZWdvcnlDaGFuZ2UsIGdldEN1cnJlbnRUaGVtZUNvbG9yc10pO1xuXG4gIC8vIENyZWF0ZSBzb3J0ZWQgdGFyZ2V0cyBmb3IgY29uc2lzdGVudCBoaWdobGlnaHRpbmdcbiAgY29uc3Qgc29ydGVkVGFyZ2V0c0ZvckhpZ2hsaWdodCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHNvcnRlZCA9IFsuLi50YXJnZXRzXTtcbiAgICBpZiAoY3VycmVudFRhcmdldCA9PT0gJ3llYXJzX2F0X21lZHRyb25pYycpIHtcbiAgICAgIHNvcnRlZC5zb3J0KChhLCBiKSA9PiBZRUFSU19DQVRFR09SSUVTLmluZGV4T2YoYSkgLSBZRUFSU19DQVRFR09SSUVTLmluZGV4T2YoYikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3J0ZWQuc29ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gc29ydGVkO1xuICB9LCBbdGFyZ2V0cywgY3VycmVudFRhcmdldF0pO1xuXG4gIC8vIFNlcGFyYXRlIGVmZmVjdCB0byB1cGRhdGUgdmlzdWFsIGhpZ2hsaWdodGluZyBkdXJpbmcgYW5pbWF0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzdmdSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgc3ZnID0gZDMuc2VsZWN0PFNWR1NWR0VsZW1lbnQsIHVua25vd24+KHN2Z1JlZi5jdXJyZW50KTtcbiAgICBjb25zdCBnID0gc3ZnLnNlbGVjdCgnZycpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBub2RlIG9wYWNpdHkgYmFzZWQgb24gYW5pbWF0aW9uIHN0YXRlXG4gICAgZy5zZWxlY3RBbGwoJ3JlY3QnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgIC5hdHRyKCdvcGFjaXR5JywgZnVuY3Rpb24oZDogYW55KSB7XG4gICAgICAgIC8vIFNvdXJjZSBub2Rlczogb25seSB0aGUgaGlnaGxpZ2h0ZWQgb25lIGlzIGJyaWdodFxuICAgICAgICBpZiAoZC5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSkge1xuICAgICAgICAgIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF0gPyAxIDogMC4yOyAvLyBTbGlnaHRseSBoaWdoZXIgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwLjk7IC8vIEluY3JlYXNlZCBmcm9tIDAuNiB0byAwLjkgZm9yIG1vcmUgcHJvbWluZW5jZVxuICAgICAgICB9XG4gICAgICAgIC8vIFRhcmdldCBub2RlczogaGlnaGxpZ2h0IHRob3NlIGNvbm5lY3RlZCB0byB0aGUgaGlnaGxpZ2h0ZWQgc291cmNlXG4gICAgICAgIGlmIChob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgY29uc3QgaG92ZXJlZFNvdXJjZSA9IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XTtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHRhcmdldCBub2RlIGlzIGNvbm5lY3RlZCB0byB0aGUgaGlnaGxpZ2h0ZWQgc291cmNlXG4gICAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBzdmcuc2VsZWN0QWxsKCdwYXRoJykuZGF0YSgpLnNvbWUoKGxpbms6IGFueSkgPT4gXG4gICAgICAgICAgICBsaW5rLnNvdXJjZS5uYW1lID09PSBob3ZlcmVkU291cmNlICYmIGxpbmsudGFyZ2V0Lm5hbWUgPT09IGQubmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkID8gMSA6IDAuMjsgLy8gU2xpZ2h0bHkgaGlnaGVyIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICB9XG4gICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0SW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgY29uc3QgaG92ZXJlZFRhcmdldCA9IHNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHRbaG92ZXJlZFRhcmdldEluZGV4XTtcbiAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBob3ZlcmVkVGFyZ2V0ID8gMSA6IDAuMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMC45OyAvLyBJbmNyZWFzZWQgZnJvbSAwLjYgdG8gMC45IGZvciBtb3JlIHByb21pbmVuY2VcbiAgICAgIH0pXG4gICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgZnVuY3Rpb24oZDogYW55KSB7XG4gICAgICAgIC8vIEFkZCB0aGlja2VyIHN0cm9rZSB0byBoaWdobGlnaHRlZCBzb3VyY2Ugbm9kZVxuICAgICAgICBpZiAoZC5jYXRlZ29yeSA9PT0gY3VycmVudFNvdXJjZSAmJiBob3ZlcmVkU291cmNlSW5kZXggIT09IG51bGwgJiYgYW5pbWF0aW9uUGhhc2UgPT09ICdoaWdobGlnaHRpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdID8gMyA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBsaW5rIG9wYWNpdHkgYmFzZWQgb24gYW5pbWF0aW9uIHN0YXRlXG4gICAgZy5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgIC5hdHRyKCdvcGFjaXR5JywgZnVuY3Rpb24oZDogYW55KSB7XG4gICAgICAgIC8vIEFkanVzdCBvcGFjaXR5IGJhc2VkIG9uIGRhcmsgbW9kZSBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgY29uc3QgYmFzZU9wYWNpdHkgPSBzZXR0aW5ncy5pc0RhcmtNb2RlID8gMC44NSA6IDAuNDtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0T3BhY2l0eSA9IHNldHRpbmdzLmlzRGFya01vZGUgPyAxLjAgOiAwLjk1O1xuICAgICAgICBjb25zdCBkaW1PcGFjaXR5ID0gc2V0dGluZ3MuaXNEYXJrTW9kZSA/IDAuMzUgOiAwLjA1O1xuXG4gICAgICAgIC8vIERlZmF1bHQgb3BhY2l0eSB3aGVuIG5vIGhpZ2hsaWdodGluZ1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2UgIT09ICdoaWdobGlnaHRpbmcnKSByZXR1cm4gYmFzZU9wYWNpdHk7XG5cbiAgICAgICAgLy8gSGlnaGxpZ2h0IGxpbmtzIGZyb20gdGhlIGFjdGl2ZSBzb3VyY2VcbiAgICAgICAgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGhvdmVyZWRTb3VyY2UgPSBzb3J0ZWRTb3VyY2VzW2hvdmVyZWRTb3VyY2VJbmRleF07XG4gICAgICAgICAgcmV0dXJuIGQuc291cmNlLm5hbWUgPT09IGhvdmVyZWRTb3VyY2UgPyBoaWdobGlnaHRPcGFjaXR5IDogZGltT3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhpZ2hsaWdodCBsaW5rcyB0byB0aGUgYWN0aXZlIHRhcmdldFxuICAgICAgICBpZiAoaG92ZXJlZFRhcmdldEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgaG92ZXJlZFRhcmdldCA9IHNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHRbaG92ZXJlZFRhcmdldEluZGV4XTtcbiAgICAgICAgICByZXR1cm4gZC50YXJnZXQubmFtZSA9PT0gaG92ZXJlZFRhcmdldCA/IGhpZ2hsaWdodE9wYWNpdHkgOiBkaW1PcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2VPcGFjaXR5O1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbihkOiBhbnkpIHtcbiAgICAgICAgLy8gTWFrZSBoaWdobGlnaHRlZCBsaW5rcyB0aGlja2VyXG4gICAgICAgIGlmIChhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycgJiYgaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgaG92ZXJlZFNvdXJjZSA9IHNvcnRlZFNvdXJjZXNbaG92ZXJlZFNvdXJjZUluZGV4XTtcbiAgICAgICAgICByZXR1cm4gZC5zb3VyY2UubmFtZSA9PT0gaG92ZXJlZFNvdXJjZSA/IE1hdGgubWF4KDIsIGQud2lkdGggKiAxLjIpIDogTWF0aC5tYXgoMSwgZC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDEsIGQud2lkdGgpO1xuICAgICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZygn8J+OqCBWaXN1YWwgaGlnaGxpZ2h0aW5nIHVwZGF0ZWQ6Jywge1xuICAgICAgaG92ZXJlZFNvdXJjZUluZGV4LFxuICAgICAgc291cmNlTmFtZTogaG92ZXJlZFNvdXJjZUluZGV4ICE9PSBudWxsID8gc29ydGVkU291cmNlc1tob3ZlcmVkU291cmNlSW5kZXhdIDogbnVsbCxcbiAgICAgIGhvdmVyZWRUYXJnZXRJbmRleCxcbiAgICAgIHRhcmdldE5hbWU6IGhvdmVyZWRUYXJnZXRJbmRleCAhPT0gbnVsbCA/IHNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHRbaG92ZXJlZFRhcmdldEluZGV4XSA6IG51bGwsXG4gICAgICBhbmltYXRpb25QaGFzZVxuICAgIH0pO1xuXG4gIH0sIFtob3ZlcmVkU291cmNlSW5kZXgsIGhvdmVyZWRUYXJnZXRJbmRleCwgYW5pbWF0aW9uUGhhc2UsIHNvcnRlZFNvdXJjZXMsIHNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHQsIGN1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXRdKTtcblxuICAvLyBTZXBhcmF0ZSBlZmZlY3QgZm9yIGhvdmVyIGludGVyYWN0aW9ucyAoZG9lc24ndCByZS1yZW5kZXIgdGhlIHdob2xlIHZpc3VhbGl6YXRpb24pXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzdmdSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgc3ZnID0gZDMuc2VsZWN0PFNWR1NWR0VsZW1lbnQsIHVua25vd24+KHN2Z1JlZi5jdXJyZW50KTtcbiAgICBjb25zdCBnID0gc3ZnLnNlbGVjdCgnZycpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBsaW5rIGhvdmVyIGVmZmVjdHNcbiAgICBnLnNlbGVjdEFsbCgncGF0aCcpXG4gICAgICAuZWFjaChmdW5jdGlvbihkOiBhbnkpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gaG92ZXJlZExpbmsgPT09IGQ7XG4gICAgICAgIHBhdGguYXR0cignZmlsdGVyJywgaXNIb3ZlcmVkID8gJ3VybCgjZ2xvdyknIDogbnVsbCk7XG4gICAgICB9KTtcblxuICB9LCBbaG92ZXJlZE5vZGUsIGhvdmVyZWRMaW5rXSk7XG5cbiAgLy8gVG9vbHRpcCByZW5kZXJpbmcgd2l0aCBkYXJrIG1vZGUgc3VwcG9ydFxuICBjb25zdCB0b29sdGlwRWwgPSB0b29sdGlwID8gKFxuICAgIDxkaXZcbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBsZWZ0OiB0b29sdGlwLnggKyAxNixcbiAgICAgICAgdG9wOiB0b29sdGlwLnkgKyAxNixcbiAgICAgICAgYmFja2dyb3VuZDogc2V0dGluZ3MuaXNEYXJrTW9kZSA/ICdyZ2JhKDIwLDIwLDMwLDAuOTgpJyA6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuOTgpJyxcbiAgICAgICAgY29sb3I6IHNldHRpbmdzLmlzRGFya01vZGUgPyAnI2ZmZicgOiAnIzE3MEY1RicsXG4gICAgICAgIHBhZGRpbmc6ICc4cHggMTJweCcsXG4gICAgICAgIGJvcmRlclJhZGl1czogNixcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICB6SW5kZXg6IDEwMCxcbiAgICAgICAgZm9udEZhbWlseTogJ0F2ZW5pciBOZXh0IFdvcmxkLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgZm9udFdlaWdodDogNjAwLFxuICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgIGJveFNoYWRvdzogc2V0dGluZ3MuaXNEYXJrTW9kZSBcbiAgICAgICAgICA/ICcwIDRweCAyNHB4IDAgcmdiYSgxNiwgMTYsIDIzNSwgMC4xMiknIFxuICAgICAgICAgIDogJzAgNHB4IDI0cHggMCByZ2JhKDAsIDAsIDAsIDAuMTUpJyxcbiAgICAgICAgYm9yZGVyOiBzZXR0aW5ncy5pc0RhcmtNb2RlID8gJzFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMSknIDogJzFweCBzb2xpZCByZ2JhKDAsMCwwLDAuMSknLFxuICAgICAgICBtYXhXaWR0aDogMjgwLFxuICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICB9fVxuICAgICAgcm9sZT1cInRvb2x0aXBcIlxuICAgICAgYXJpYS1saXZlPVwicG9saXRlXCJcbiAgICA+XG4gICAgICB7dG9vbHRpcC5jb250ZW50fVxuICAgIDwvZGl2PlxuICApIDogbnVsbDtcblxuICAvLyBDcmVhdGUgc29ydGVkIHNvdXJjZXMgYXJyYXkgZm9yIGhpZ2hsaWdodGluZyAoc2FtZSBhcyByZW5kZXJpbmcgYW5kIGFuaW1hdGlvbilcbiAgY29uc3Qgc29ydGVkU291cmNlc0ZvckhpZ2hsaWdodCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCB2aXN1YWxPcmRlcjogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoZmlsdGVyZWREYXRhLmxlbmd0aCAmJiBjaGFydFdpZHRoID4gMCAmJiBjaGFydEhlaWdodCA+IDApIHtcbiAgICAgIGNvbnN0IHNvdXJjZXNGb3JOb2RlcyA9IFsuLi5zb3VyY2VzXTtcbiAgaWYgKGN1cnJlbnRTb3VyY2UgPT09ICd5ZWFyc19hdF9tZWR0cm9uaWMnKSB7XG4gICAgICAgIHNvdXJjZXNGb3JOb2Rlcy5zb3J0KChhLCBiKSA9PiBZRUFSU19DQVRFR09SSUVTLmluZGV4T2YoYSkgLSBZRUFSU19DQVRFR09SSUVTLmluZGV4T2YoYikpO1xuICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VzRm9yTm9kZXMuc29ydCgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9kZXMgPSBbXG4gICAgICAgIC4uLnNvdXJjZXNGb3JOb2Rlcy5tYXAoKG5hbWUpID0+ICh7IGlkOiBgJHtjdXJyZW50U291cmNlfToke25hbWV9YCwgbmFtZSwgY2F0ZWdvcnk6IGN1cnJlbnRTb3VyY2UgfSkpLFxuICAgICAgICAuLi50YXJnZXRzLm1hcCgobmFtZSkgPT4gKHsgaWQ6IGAke2N1cnJlbnRUYXJnZXR9OiR7bmFtZX1gLCBuYW1lLCBjYXRlZ29yeTogY3VycmVudFRhcmdldCB9KSksXG4gICAgICBdO1xuICAgICAgY29uc3QgbGlua3NNYXAgPSBuZXcgTWFwPHN0cmluZywgeyBzb3VyY2U6IHN0cmluZzsgdGFyZ2V0OiBzdHJpbmc7IHZhbHVlOiBudW1iZXIsIGlzRHVtbXk/OiBib29sZWFuIH0+KCk7XG4gICAgICBmaWx0ZXJlZERhdGEuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBjdXJyZW50U291cmNlID09PSAneWVhcnNfYXRfbWVkdHJvbmljJyA/IGdldFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMCkgOiAoZCBhcyBhbnkpW2N1cnJlbnRTb3VyY2VdO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBjdXJyZW50VGFyZ2V0ID09PSAneWVhcnNfYXRfbWVkdHJvbmljJyA/IGdldFllYXJzQ2F0ZWdvcnkoZC55ZWFyc19hdF9tZWR0cm9uaWMgfHwgMCkgOiAoZCBhcyBhbnkpW2N1cnJlbnRUYXJnZXRdO1xuICAgICAgICBjb25zdCBzb3VyY2VJZCA9IGAke2N1cnJlbnRTb3VyY2V9OiR7c291cmNlfWA7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gYCR7Y3VycmVudFRhcmdldH06JHt0YXJnZXR9YDtcbiAgICAgICAgaWYgKCFzb3VyY2VzRm9yTm9kZXMuaW5jbHVkZXMoc291cmNlKSB8fCAhdGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGtleSA9IGAke3NvdXJjZUlkfeKGkiR7dGFyZ2V0SWR9YDtcbiAgICAgICAgaWYgKCFsaW5rc01hcC5oYXMoa2V5KSkge1xuICAgICAgICAgIGxpbmtzTWFwLnNldChrZXksIHsgc291cmNlOiBzb3VyY2VJZCwgdGFyZ2V0OiB0YXJnZXRJZCwgdmFsdWU6IDAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlua3NNYXAuZ2V0KGtleSkhLnZhbHVlICs9IDE7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxpbmtzID0gQXJyYXkuZnJvbShsaW5rc01hcC52YWx1ZXMoKSk7XG4gICAgICBjb25zdCBzYW5rZXlHZW5lcmF0b3IgPSBzYW5rZXk8YW55LCBhbnk+KClcbiAgICAgICAgLm5vZGVJZCgoZDogYW55KSA9PiBkLmlkKVxuICAgICAgICAubm9kZVdpZHRoKDEyKVxuICAgICAgICAubm9kZVBhZGRpbmcobm9kZVBhZGRpbmcpXG4gICAgICAgIC5leHRlbnQoW1swLCAwXSwgW2NoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0XV0pO1xuICAgICAgY29uc3Qgc2Fua2V5RGF0YSA9IHNhbmtleUdlbmVyYXRvcih7XG4gICAgICAgIG5vZGVzOiBub2Rlcy5tYXAoKGQpID0+ICh7IC4uLmQgfSkpLFxuICAgICAgICBsaW5rczogbGlua3MubWFwKChkKSA9PiAoeyAuLi5kIH0pKSxcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc291cmNlTm9kZXMgPSBzYW5rZXlEYXRhLm5vZGVzLmZpbHRlcigoZDogYW55KSA9PiBkLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlKTtcbiAgICAgIHZpc3VhbE9yZGVyID0gc291cmNlTm9kZXNcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiBhLnkwIC0gYi55MClcbiAgICAgICAgLm1hcCgoZDogYW55KSA9PiBkLm5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmlzdWFsT3JkZXIubGVuZ3RoID8gdmlzdWFsT3JkZXIgOiBbLi4uc291cmNlc107XG4gIH0sIFtmaWx0ZXJlZERhdGEsIGN1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXQsIHNvdXJjZXMsIHRhcmdldHMsIGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0LCBub2RlUGFkZGluZ10pO1xuXG4gIC8vIERldGVybWluZSB3aGljaCBzb3VyY2Ugb3IgdGFyZ2V0IHRvIGhpZ2hsaWdodCBiYXNlZCBvbiBhbmltYXRpb24gc3RhdGVcbiAgbGV0IGhpZ2hsaWdodFNvdXJjZU5hbWU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBsZXQgaGlnaGxpZ2h0VGFyZ2V0TmFtZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIGlmIChpc0luRnVsbE9wYWNpdHlTdGF0ZSkge1xuICAgIGhpZ2hsaWdodFNvdXJjZU5hbWUgPSBudWxsO1xuICAgIGhpZ2hsaWdodFRhcmdldE5hbWUgPSBudWxsO1xuICB9IGVsc2UgaWYgKGhvdmVyZWRTb3VyY2VJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICBoaWdobGlnaHRTb3VyY2VOYW1lID0gc29ydGVkU291cmNlc0ZvckhpZ2hsaWdodFtob3ZlcmVkU291cmNlSW5kZXhdO1xuICB9IGVsc2UgaWYgKGhvdmVyZWRUYXJnZXRJbmRleCAhPT0gbnVsbCAmJiBhbmltYXRpb25QaGFzZSA9PT0gJ2hpZ2hsaWdodGluZycpIHtcbiAgICBoaWdobGlnaHRUYXJnZXROYW1lID0gdGFyZ2V0c1tob3ZlcmVkVGFyZ2V0SW5kZXhdO1xuICB9XG5cbiAgLy8gRW5oYW5jZWQgYW5pbWF0aW9uIHBhdXNlL3Jlc3VtZSB3aXRoIGRlYnVnIHRyYWNraW5nXG4gIGNvbnN0IHBhdXNlQW5pbWF0aW9uID0gdXNlQ2FsbGJhY2soKHJlYXNvbjogc3RyaW5nKSA9PiB7XG4gICAgaWYgKGFuaW1hdGlvblJlZi5jdXJyZW50LnJ1bm5pbmcgJiYgIWFuaW1hdGlvblJlZi5jdXJyZW50LmlzUGF1c2VkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4o+477iPICBQQVVTSU5HIEFOSU1BVElPTjonLCByZWFzb24sIHtcbiAgICAgICAgY3VycmVudFNvdXJjZUluZGV4OiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50U291cmNlSW5kZXgsXG4gICAgICAgIGN1cnJlbnRUYXJnZXRJbmRleDogYW5pbWF0aW9uUmVmLmN1cnJlbnQuY3VycmVudFRhcmdldEluZGV4LFxuICAgICAgICBjdXJyZW50U291cmNlLFxuICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQgPSB0cnVlO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQucGF1c2VkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblJlZi5jdXJyZW50LnRpbWVyKTtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQudGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2N1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXRdKTtcblxuICBjb25zdCByZXN1bWVBbmltYXRpb24gPSB1c2VDYWxsYmFjaygocmVhc29uOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyAmJiBhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KWtu+4jyAgUkVTVU1JTkcgQU5JTUFUSU9OOicsIHJlYXNvbiwge1xuICAgICAgICBjdXJyZW50U291cmNlSW5kZXg6IGFuaW1hdGlvblJlZi5jdXJyZW50LmN1cnJlbnRTb3VyY2VJbmRleCxcbiAgICAgICAgY3VycmVudFRhcmdldEluZGV4OiBhbmltYXRpb25SZWYuY3VycmVudC5jdXJyZW50VGFyZ2V0SW5kZXgsXG4gICAgICAgIHBhdXNlZER1cmF0aW9uOiBEYXRlLm5vdygpIC0gYW5pbWF0aW9uUmVmLmN1cnJlbnQucGF1c2VkQXRcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhbmltYXRpb25SZWYuY3VycmVudC5pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQucmVzdW1lRnJvbSA9ICdzb3VyY2UnO1xuICAgICAgXG4gICAgICAvLyBSZXN1bWUgYW5pbWF0aW9uIGZyb20gY3VycmVudCBwb3NpdGlvbiB3aXRoIGEgc21hbGwgZGVsYXkgdG8gZW5zdXJlIHN0YXRlIGlzIHVwZGF0ZWRcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoYW5pbWF0aW9uUmVmLmN1cnJlbnQucnVubmluZyAmJiAhYW5pbWF0aW9uUmVmLmN1cnJlbnQuaXNQYXVzZWQpIHtcbiAgICAgICAgICBhbmltYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICB9LCBbYW5pbWF0ZV0pO1xuXG4gIC8vIFVwZGF0ZSBob3ZlciBoYW5kbGVycyB3aXRoIHByb3BlciBzdGF0ZSBtYW5hZ2VtZW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzdmdSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgc3ZnID0gZDMuc2VsZWN0KHN2Z1JlZi5jdXJyZW50KTtcbiAgICBcbiAgICAvLyBVcGRhdGUgbGluayBob3ZlciBiZWhhdmlvclxuICAgIHN2Zy5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZXZlbnQ6IGFueSwgZDogYW55KSB7XG4gICAgICAgIC8vIFBhdXNlIGFuaW1hdGlvbiBkdXJpbmcgaG92ZXJcbiAgICAgICAgcGF1c2VBbmltYXRpb24oJ2xpbmsgaG92ZXInKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCBob3ZlciBzdGF0ZXNcbiAgICAgICAgc2V0SG92ZXJlZExpbmsoZCk7XG4gICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdoaWdobGlnaHRpbmcnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEhhbmRsZSBzb3VyY2Ugbm9kZSBob3ZlclxuICAgICAgICBpZiAoZC5zb3VyY2UgJiYgZC5zb3VyY2UuY2F0ZWdvcnkgPT09IGN1cnJlbnRTb3VyY2UpIHtcbiAgICAgICAgICBjb25zdCBpZHggPSBzb3J0ZWRTb3VyY2VzLmluZGV4T2YoZC5zb3VyY2UubmFtZSk7XG4gICAgICAgICAgc2V0SG92ZXJlZFNvdXJjZUluZGV4KGlkeCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gTWFudWFsIHNvdXJjZSBoaWdobGlnaHQ6JywgZC5zb3VyY2UubmFtZSwgJ2luZGV4OicsIGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEhhbmRsZSB0YXJnZXQgbm9kZSBob3ZlclxuICAgICAgICBpZiAoZC50YXJnZXQgJiYgZC50YXJnZXQuY2F0ZWdvcnkgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCBpZHggPSBzb3J0ZWRUYXJnZXRzRm9ySGlnaGxpZ2h0LmluZGV4T2YoZC50YXJnZXQubmFtZSk7XG4gICAgICAgICAgc2V0SG92ZXJlZFRhcmdldEluZGV4KGlkeCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gTWFudWFsIHRhcmdldCBoaWdobGlnaHQ6JywgZC50YXJnZXQubmFtZSwgJ2luZGV4OicsIGlkeCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUmVzdW1lIGFuaW1hdGlvblxuICAgICAgICByZXN1bWVBbmltYXRpb24oJ2xpbmsgaG92ZXIgZW5kJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBob3ZlciBzdGF0ZXNcbiAgICAgICAgc2V0SG92ZXJlZExpbmsobnVsbCk7XG4gICAgICAgIHNldEhvdmVyZWRTb3VyY2VJbmRleChudWxsKTtcbiAgICAgICAgc2V0SG92ZXJlZFRhcmdldEluZGV4KG51bGwpO1xuICAgICAgICBzZXRBbmltYXRpb25QaGFzZSgnZnVsbCcpO1xuICAgICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgbm9kZSBob3ZlciBiZWhhdmlvclxuICAgIHN2Zy5zZWxlY3RBbGwoJ3JlY3QnKVxuICAgICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZXZlbnQ6IGFueSwgZDogYW55KSB7XG4gICAgICAgIC8vIFBhdXNlIGFuaW1hdGlvbiBkdXJpbmcgaG92ZXJcbiAgICAgICAgcGF1c2VBbmltYXRpb24oJ25vZGUgaG92ZXInKTtcbiAgICAgICAgc2V0QW5pbWF0aW9uUGhhc2UoJ2hpZ2hsaWdodGluZycpO1xuICAgICAgICBcbiAgICAgICAgLy8gSGFuZGxlIHNvdXJjZSBub2RlIGhvdmVyXG4gICAgICAgIGlmIChkLmNhdGVnb3J5ID09PSBjdXJyZW50U291cmNlKSB7XG4gICAgICAgICAgY29uc3QgaWR4ID0gc29ydGVkU291cmNlcy5pbmRleE9mKGQubmFtZSk7XG4gICAgICAgICAgc2V0SG92ZXJlZFNvdXJjZUluZGV4KGlkeCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gTWFudWFsIHNvdXJjZSBub2RlIGhpZ2hsaWdodDonLCBkLm5hbWUsICdpbmRleDonLCBpZHgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgdGFyZ2V0IG5vZGUgaG92ZXJcbiAgICAgICAgaWYgKGQuY2F0ZWdvcnkgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCBpZHggPSBzb3J0ZWRUYXJnZXRzRm9ySGlnaGxpZ2h0LmluZGV4T2YoZC5uYW1lKTtcbiAgICAgICAgICBzZXRIb3ZlcmVkVGFyZ2V0SW5kZXgoaWR4KTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+OryBNYW51YWwgdGFyZ2V0IG5vZGUgaGlnaGxpZ2h0OicsIGQubmFtZSwgJ2luZGV4OicsIGlkeCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUmVzdW1lIGFuaW1hdGlvblxuICAgICAgICByZXN1bWVBbmltYXRpb24oJ25vZGUgaG92ZXIgZW5kJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBob3ZlciBzdGF0ZXNcbiAgICAgICAgc2V0SG92ZXJlZFNvdXJjZUluZGV4KG51bGwpO1xuICAgICAgICBzZXRIb3ZlcmVkVGFyZ2V0SW5kZXgobnVsbCk7XG4gICAgICAgIHNldEFuaW1hdGlvblBoYXNlKCdmdWxsJyk7XG4gICAgICB9KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBDbGVhbiB1cCBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBzdmcuc2VsZWN0QWxsKCdwYXRoLCByZWN0JylcbiAgICAgICAgLm9uKCdtb3VzZWVudGVyJywgbnVsbClcbiAgICAgICAgLm9uKCdtb3VzZWxlYXZlJywgbnVsbCk7XG4gICAgfTtcbiAgfSwgW3NvcnRlZFNvdXJjZXMsIHNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHQsIGN1cnJlbnRTb3VyY2UsIGN1cnJlbnRUYXJnZXQsIHBhdXNlQW5pbWF0aW9uLCByZXN1bWVBbmltYXRpb25dKTtcblxuICAvLyBNYWluIHJlbmRlcmluZyBlZmZlY3RcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN2Z1JlZi5jdXJyZW50IHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIFRoZSBtYWluIHJlbmRlcmluZyBsb2dpYyBoYW5kbGVzIGFsbCBvcGFjaXR5IHVwZGF0ZXNcbiAgICAvLyBUaGlzIGVuc3VyZXMgZGF0YSBiaW5kaW5nIGlzIGNvcnJlY3QgYW5kIHByZXZlbnRzIHRoZSB1bmRlZmluZWQgZXJyb3JcbiAgICBcbiAgfSwgW2ZpbHRlcmVkRGF0YSwgaG92ZXJlZFNvdXJjZUluZGV4LCBob3ZlcmVkVGFyZ2V0SW5kZXgsIGFuaW1hdGlvblBoYXNlLCBzb3J0ZWRTb3VyY2VzLCB0YXJnZXRzLCBjdXJyZW50U291cmNlLCBjdXJyZW50VGFyZ2V0XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHJlZj17Y29udGFpbmVyUmVmfSBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJywgbWluSGVpZ2h0OiAyMjAsIG1pbldpZHRoOiAzMjAsIHBvc2l0aW9uOiAncmVsYXRpdmUnIH19PlxuICAgICAgey8qIFNob3cgYSBtZXNzYWdlIGlmIGRhdGEgaXMgdmVyeSBzcGFyc2UgKi99XG4gICAgICB7KG5vZGVDb3VudCA8PSAyIHx8IChzb3VyY2VzLmxlbmd0aCA8PSAxIHx8IHRhcmdldHMubGVuZ3RoIDw9IDEpKSAmJiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6IDQwLFxuICAgICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSknLFxuICAgICAgICAgIGJhY2tncm91bmQ6ICdyZ2JhKDI1NSwyNTUsMjAwLDAuOTUpJyxcbiAgICAgICAgICBjb2xvcjogJyMxNzBGNUYnLFxuICAgICAgICAgIHBhZGRpbmc6ICcxMnB4IDI0cHgnLFxuICAgICAgICAgIGJvcmRlclJhZGl1czogOCxcbiAgICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgICAgZm9udFNpemU6IDE4LFxuICAgICAgICAgIHpJbmRleDogMTAsXG4gICAgICAgICAgYm94U2hhZG93OiAnMCAycHggMTJweCAwIHJnYmEoMCwwLDAsMC4wOCknXG4gICAgICAgIH19PlxuICAgICAgICAgIE5vdCBlbm91Z2ggZGF0YSB0byBzaG93IGEgbWVhbmluZ2Z1bCBmbG93IGRpYWdyYW0uXG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIDxzdmdcbiAgICAgICAgcmVmPXtzdmdSZWZ9XG4gICAgICAgIHdpZHRoPXtjaGFydFdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHR9XG4gICAgICAgIGhlaWdodD17Y2hhcnRIZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbX1cbiAgICAgICAgdmlld0JveD17YDAgMCAke2NoYXJ0V2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodH0gJHtjaGFydEhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tfWB9XG4gICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdibG9jaycsIHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnLCBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnIH19XG4gICAgICA+XG4gICAgICAgIHsvKiBNYWluIGNoYXJ0IGdyb3VwLCB0cmFuc2xhdGVkIGJ5IG1hcmdpbiAqL31cbiAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCR7bWFyZ2luLnRvcH0pYH0+XG4gICAgICAgICAgey8qIC4uLiBub2RlcyBhbmQgbGlua3MgLi4uICovfVxuICAgICAgICA8L2c+XG4gICAgICAgIHsvKiBEZWJ1ZyBvdXRsaW5lcyBmb3IgYWxpZ25tZW50IChvbmx5IGlmIGRlYnVnT24pICovfVxuICAgICAgICB7ZGVidWdPbiAmJiAoXG4gICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCR7bWFyZ2luLnRvcH0pYH0+XG4gICAgICAgICAgICB7LyogTm9kZSBkZWJ1ZyBvdXRsaW5lcyAqL31cbiAgICAgICAgICAgIHtBcnJheS5pc0FycmF5KGRlYnVnU2Fua2V5RGF0YT8ubm9kZXMpICYmIGRlYnVnU2Fua2V5RGF0YS5ub2Rlcy5tYXAoKGQ6IGFueSwgaTogbnVtYmVyKSA9PiAoXG4gICAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgICAga2V5PXtgZGVidWctbm9kZS0ke2l9YH1cbiAgICAgICAgICAgICAgICB4PXtkLngwfVxuICAgICAgICAgICAgICAgIHk9e2QueTB9XG4gICAgICAgICAgICAgICAgd2lkdGg9e2QueDEgLSBkLngwfVxuICAgICAgICAgICAgICAgIGhlaWdodD17ZC55MSAtIGQueTB9XG4gICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgIHN0cm9rZT1cIm1hZ2VudGFcIlxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjQgMlwiXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50cz1cIm5vbmVcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICB7LyogTGluayBkZWJ1ZyBvdXRsaW5lcyAoaWYgYW55KSAqL31cbiAgICAgICAgICAgIHtBcnJheS5pc0FycmF5KGRlYnVnU2Fua2V5RGF0YT8ubGlua3MpICYmIGRlYnVnU2Fua2V5RGF0YS5saW5rcy5tYXAoKGQ6IGFueSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBzYW5rZXlMaW5rSG9yaXpvbnRhbCgpKGQpIHx8ICcnO1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICBrZXk9e2BkZWJ1Zy1saW5rLSR7aX1gfVxuICAgICAgICAgICAgICAgICAgZD17cGF0aH1cbiAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN5YW5cIlxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgIDwvZz5cbiAgICAgICAgKX1cbiAgICAgIDwvc3ZnPlxuICAgICAge3Rvb2x0aXBFbH1cbiAgICA8L2Rpdj5cbiAgKTtcbn0gIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCJkMyIsInNhbmtleSIsInNhbmtleUxpbmtIb3Jpem9udGFsIiwidXNlVmlzdWFsaXphdGlvbkRhdGEiLCJnZXRZZWFyc0NhdGVnb3J5IiwiZ2V0Tm9kZUNvbG9yIiwidXNlQXBwQ29udGV4dCIsImF2YWlsYWJsZUZpZWxkcyIsInZhbHVlIiwibGFiZWwiLCJZRUFSU19DQVRFR09SSUVTIiwiZ2V0VmFsaWRZZWFyc0NhdGVnb3J5IiwieWVhcnMiLCJpc05hTiIsInNhbmtleUxpbmtXYXZlIiwiZCIsIndhdmVBbXBsaXR1ZGUiLCJ3YXZlRnJlcXVlbmN5IiwiY2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0IiwieDAiLCJzb3VyY2UiLCJ4MSIsInRhcmdldCIsInkwIiwieTEiLCJNYXRoIiwibWF4IiwibWluIiwibWlkWCIsIndhdmVZMCIsInNpbiIsIlBJIiwid2F2ZVkxIiwiQWxsdXZpYWxEaWFncmFtIiwid2lkdGgiLCJoZWlnaHQiLCJhdXRvUGxheSIsIm9uUXVlc3Rpb25DaGFuZ2UiLCJjb250YWluZXJSZWYiLCJjb250YWluZXJXaWR0aCIsInNldENvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0Iiwic2V0Q29udGFpbmVySGVpZ2h0IiwiY3VycmVudCIsIm9ic2VydmVyIiwid2luZG93IiwiUmVzaXplT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZW50cnkiLCJjb250ZW50UmVjdCIsIm9ic2VydmUiLCJkaXNjb25uZWN0Iiwic3ZnUmVmIiwiZGF0YSIsImlzTG9hZGluZyIsImVycm9yIiwic2V0dGluZ3MiLCJnZXRDdXJyZW50VGhlbWVDb2xvcnMiLCJjdXJyZW50U291cmNlIiwic2V0Q3VycmVudFNvdXJjZSIsImN1cnJlbnRUYXJnZXQiLCJzZXRDdXJyZW50VGFyZ2V0IiwiZmlsdGVyZWREYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwidXNlVGVzdERhdGEiLCJmaWx0ZXIiLCJpdGVtIiwidGVzdF9kYXRhIiwic291cmNlcyIsImNhdCIsInNvbWUiLCJ5ZWFyc19hdF9tZWR0cm9uaWMiLCJmcm9tIiwiU2V0IiwibWFwIiwidGFyZ2V0cyIsInNvcnQiLCJNSU5fQ0hBUlRfSEVJR0hUIiwiTUFYX0NIQVJUX0hFSUdIVCIsIk1JTl9DSEFSVF9XSURUSCIsIk1BWF9DSEFSVF9XSURUSCIsIm5vZGVDb3VudCIsImF2YWlsYWJsZUhlaWdodCIsIm1pbk5vZGVIZWlnaHQiLCJtYXhOb2RlSGVpZ2h0IiwibWluUGFkZGluZyIsIm5vZGVIZWlnaHQiLCJmbG9vciIsIm5vZGVQYWRkaW5nIiwibGFiZWxGb250U2l6ZSIsIm1lYXN1cmVUZXh0V2lkdGgiLCJ0ZXh0IiwiZm9udCIsIl9jYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjYW52YXMiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsIm1lYXN1cmVUZXh0IiwibGFiZWxGb250IiwiYWxsTGFiZWxzIiwibGFiZWxXaWR0aHMiLCJtYXhMYWJlbFdpZHRoIiwibGFiZWxQYWRkaW5nIiwibWFyZ2luIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiY29uc29sZSIsImxvZyIsImN1cnJlbnRTb3VyY2VSZWYiLCJjdXJyZW50VGFyZ2V0UmVmIiwiaW5zaWdodHMiLCJzZXRJbnNpZ2h0cyIsImhvdmVyZWROb2RlIiwic2V0SG92ZXJlZE5vZGUiLCJob3ZlcmVkTGluayIsInNldEhvdmVyZWRMaW5rIiwidG9vbHRpcCIsInNldFRvb2x0aXAiLCJsYXN0Q2F0ZWdvcnlDaGFuZ2UiLCJzZXRMYXN0Q2F0ZWdvcnlDaGFuZ2UiLCJjdXJyZW50VGFyZ2V0SW5kZXgiLCJzZXRDdXJyZW50VGFyZ2V0SW5kZXgiLCJpc0FuaW1hdGluZyIsInNldElzQW5pbWF0aW5nIiwiaG92ZXJlZFNvdXJjZUluZGV4Iiwic2V0SG92ZXJlZFNvdXJjZUluZGV4IiwiaG92ZXJlZFRhcmdldEluZGV4Iiwic2V0SG92ZXJlZFRhcmdldEluZGV4IiwiaXNJbkZ1bGxPcGFjaXR5U3RhdGUiLCJzZXRJc0luRnVsbE9wYWNpdHlTdGF0ZSIsImFuaW1hdGlvblBoYXNlIiwic2V0QW5pbWF0aW9uUGhhc2UiLCJhbmltYXRpb25SZWYiLCJ0aW1lciIsInJ1bm5pbmciLCJjdXJyZW50U291cmNlSW5kZXgiLCJpc1BhdXNlZCIsInBhdXNlZEF0IiwiRGF0ZSIsIm5vdyIsInJlc3VtZUZyb20iLCJjeWNsZUNvdW50IiwicHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImJhc2VTcGVlZCIsImF1dG9QbGF5U3BlZWQiLCJyZWR1Y3Rpb25GYWN0b3IiLCJzdGVwRHVyYXRpb24iLCJwYXVzZUR1cmF0aW9uIiwiY2F0ZWdvcnlQYXVzZUR1cmF0aW9uIiwibGlua1RyYW5zaXRpb25EdXJhdGlvbiIsInNvcnRlZFNvdXJjZXMiLCJzb3VyY2VzRm9yTm9kZXMiLCJhIiwiYiIsImluZGV4T2YiLCJub2RlcyIsIm5hbWUiLCJpZCIsImNhdGVnb3J5IiwibGlua3NNYXAiLCJNYXAiLCJmb3JFYWNoIiwiaW5jbHVkZXMiLCJzb3VyY2VJZCIsInRhcmdldElkIiwia2V5IiwiaGFzIiwic2V0IiwiZ2V0IiwibGlua3MiLCJ2YWx1ZXMiLCJzYW5rZXlHZW5lcmF0b3IiLCJub2RlSWQiLCJub2RlV2lkdGgiLCJleHRlbnQiLCJzYW5rZXlEYXRhIiwic291cmNlTm9kZXMiLCJhbmltYXRlIiwiZGF0YUxlbmd0aCIsInRhcmdldE9wdGlvbnMiLCJmIiwic291cmNlSW5kZXgiLCJ0YXJnZXRJbmRleCIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwic291cmNlT3B0aW9ucyIsInNvdXJjZVByb2dyZXNzIiwidGFyZ2V0UHJvZ3Jlc3MiLCJpc0xhc3RTb3VyY2UiLCJoYXNNb3JlVGFyZ2V0cyIsIm5leHRUaW1lb3V0IiwicHJvZ3Jlc3MiLCJzZXRUaW1lb3V0IiwidGFyZ2V0T3B0aW9uc0xlbmd0aCIsImF2YWlsYWJsZVRhcmdldHMiLCJjbGVhclRpbWVvdXQiLCJuZXh0VGFyZ2V0IiwicHJldmlvdXNUYXJnZXQiLCJhbGxUYXJnZXRPcHRpb25zIiwibmV4dFNvdXJjZUluZGV4IiwibmV4dFNvdXJjZSIsIm5ld1RhcmdldE9wdGlvbnMiLCJmaXJzdFRhcmdldCIsImlzQXV0b1BsYXlFbmFibGVkIiwic3ZnUmVmRXhpc3RzIiwiaXNSdW5uaW5nIiwic291cmNlQ2F0ZWdvcnkiLCJ0b3RhbFNvdXJjZXMiLCJ0b3RhbFRhcmdldHMiLCJzcGVlZCIsIm5vZGVMYWJlbEZvbnRTaXplIiwibm9kZUxhYmVsRm9udFdlaWdodCIsIm5vZGVMYWJlbENvbG9yIiwiaXNEYXJrTW9kZSIsIm5vZGVMYWJlbEZvbnRGYW1pbHkiLCJub2RlTGFiZWxPZmZzZXQiLCJsb2NhbERlYnVnIiwic2V0TG9jYWxEZWJ1ZyIsInNob3dUaGVtZVRvZ2dsZSIsInNldFNob3dUaGVtZVRvZ2dsZSIsImRlYnVnT24iLCJkZWJ1Z1NhbmtleURhdGEiLCJzZXREZWJ1Z1NhbmtleURhdGEiLCJzdmciLCJzZWxlY3QiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJhdHRyIiwic29ydGVkVGFyZ2V0cyIsInNvdXJjZUFjY2Vzc29yIiwidGFyZ2V0QWNjZXNzb3IiLCJ2YWxpZERhdGEiLCJpc0R1bW15IiwibGluayIsIm5vZGVZcyIsImZsYXQiLCJtaW5ZIiwibWF4WSIsInVzZWRIZWlnaHQiLCJvZmZzZXRZIiwiZyIsImFwcGVuZCIsImRlZnMiLCJlbXB0eSIsImxpbmtzRyIsIm5vZGVzRyIsImdsb3dGaWx0ZXIiLCJmZU1lcmdlIiwiZmlsdGVyZWRMaW5rcyIsInN0eWxlIiwibGlua0tleSIsImxpbmtTZWwiLCJleGl0IiwidHJhbnNpdGlvbiIsImR1cmF0aW9uIiwiaXNDYXRlZ29yeUNoYW5nZSIsIm5ld0xpbmtzIiwiZW50ZXIiLCJiYXNlT3BhY2l0eSIsImhpZ2hsaWdodE9wYWNpdHkiLCJkaW1PcGFjaXR5IiwiaG92ZXJlZFNvdXJjZSIsImhvdmVyZWRUYXJnZXQiLCJlYWNoIiwicGF0aCIsInRvdGFsTGVuZ3RoIiwiZ2V0VG90YWxMZW5ndGgiLCJkZWxheSIsImkiLCJlYXNlIiwiZWFzZUN1YmljSW5PdXQiLCJvbiIsImV2ZW50IiwieCIsIm9mZnNldFgiLCJ5IiwiY29udGVudCIsImRpdiIsImNsYXNzTmFtZSIsImZpbHRlcmVkTm9kZXMiLCJub2RlU2VsIiwiam9pbiIsImlzQ29ubmVjdGVkIiwibCIsImlkeCIsInVwZGF0ZSIsImxhYmVsTGF5ZXIiLCJzb3VyY2VOb2RlU2V0IiwidGFyZ2V0Tm9kZVNldCIsInRhcmdldE5vZGVzIiwibm9kZSIsIm1vc3RDb21tb24iLCJyZWR1Y2UiLCJ1bmRlZmluZWQiLCJ0aXRsZSIsInNwbGl0IiwiZGVzY3JpcHRpb24iLCJjYXRlZ29yeUNvbG9ycyIsInNvcnRlZFRhcmdldHNGb3JIaWdobGlnaHQiLCJzb3J0ZWQiLCJpc0hvdmVyZWQiLCJ0b29sdGlwRWwiLCJwb3NpdGlvbiIsImJhY2tncm91bmQiLCJjb2xvciIsInBhZGRpbmciLCJib3JkZXJSYWRpdXMiLCJwb2ludGVyRXZlbnRzIiwiekluZGV4IiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJmb250U2l6ZSIsImJveFNoYWRvdyIsImJvcmRlciIsIm1heFdpZHRoIiwid2hpdGVTcGFjZSIsIm92ZXJmbG93IiwidGV4dE92ZXJmbG93Iiwicm9sZSIsImFyaWEtbGl2ZSIsInNvcnRlZFNvdXJjZXNGb3JIaWdobGlnaHQiLCJ2aXN1YWxPcmRlciIsInNsaWNlIiwiaGlnaGxpZ2h0U291cmNlTmFtZSIsImhpZ2hsaWdodFRhcmdldE5hbWUiLCJwYXVzZUFuaW1hdGlvbiIsInJlYXNvbiIsInJlc3VtZUFuaW1hdGlvbiIsInBhdXNlZER1cmF0aW9uIiwicmVmIiwibWluSGVpZ2h0IiwibWluV2lkdGgiLCJ0cmFuc2Zvcm0iLCJ2aWV3Qm94IiwiZGlzcGxheSIsInJlY3QiLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlV2lkdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/DataVisualization/AlluvialDiagram.tsx\n"));

/***/ })

});